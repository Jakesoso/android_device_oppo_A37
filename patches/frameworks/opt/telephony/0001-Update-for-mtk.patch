From 8163ec618f05d7fabe9b1bfae1e2c7575ed27a0a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E7=A7=8B=E5=8F=B6=E9=9A=8F=E9=A3=8Eivan?=
 <yanziily@gmail.com>
Date: Sun, 3 Jan 2016 21:28:59 +0800
Subject: [PATCH] Update for mtk
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: I3d9ff9bcb8c7ee46b5820d9ba1be0406236c09fb
Signed-off-by: 秋叶随风ivan <yanziily@gmail.com>
---
 .../android/internal/telephony/BaseCommands.java   |  209 ++
 .../internal/telephony/CommandsInterface.java      |  250 +++
 .../android/internal/telephony/HardwareConfig.java |    2 +
 .../com/android/internal/telephony/IccCard.java    |   89 +
 .../android/internal/telephony/MediaTekRIL.java    | 2259 ++++++++++++++++++++
 src/java/com/android/internal/telephony/Phone.java |   35 +
 .../com/android/internal/telephony/PhoneBase.java  |   62 +-
 .../android/internal/telephony/PhoneFactory.java   |   20 +
 .../com/android/internal/telephony/PhoneProxy.java |   23 +
 src/java/com/android/internal/telephony/RIL.java   |  527 ++++-
 .../internal/telephony/ServiceStateTracker.java    |   22 +
 .../telephony/SubscriptionInfoUpdater.java         |    2 +-
 .../cdma/CdmaSubscriptionSourceManager.java        |    2 +-
 .../telephony/dataconnection/ApnSetting.java       |   30 +-
 .../telephony/dataconnection/DcTracker.java        |   10 +
 .../telephony/dataconnection/DcTrackerBase.java    |    6 +-
 .../android/internal/telephony/gsm/GSMPhone.java   |   85 +-
 .../android/internal/telephony/gsm/GsmMmiCode.java |  102 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |   43 +-
 .../internal/telephony/imsphone/ImsPhone.java      |   18 +
 .../imsphone/ImsPhoneCommandInterface.java         |   47 +
 .../telephony/imsphone/ImsPhoneMmiCode.java        |   21 +
 .../telephony/sip/SipCommandInterface.java         |   47 +
 .../internal/telephony/test/SimulatedCommands.java |   33 +
 .../internal/telephony/uicc/IccCardProxy.java      |  209 +-
 .../internal/telephony/uicc/IccConstants.java      |   30 +
 .../internal/telephony/uicc/IccFileHandler.java    |  219 +-
 .../internal/telephony/uicc/RuimRecords.java       |   10 +-
 .../internal/telephony/uicc/SIMRecords.java        |   10 +-
 .../android/internal/telephony/uicc/UiccCard.java  |  107 +
 .../telephony/uicc/UiccCardApplication.java        |  163 ++
 .../internal/telephony/uicc/UiccController.java    |  421 +++-
 .../internal/telephony/uicc/UsimFileHandler.java   |    7 +
 .../internal/telephony/EtwsNotification.java       |   42 +
 .../com/mediatek/internal/telephony/EtwsUtils.java |   31 +
 .../mediatek/internal/telephony/FemtoCellInfo.aidl |   19 +
 .../mediatek/internal/telephony/FemtoCellInfo.java |  154 ++
 .../internal/telephony/ModemSwitchHandler.java     |  244 +++
 .../internal/telephony/NetworkInfoWithAcT.aidl     |   57 +
 .../internal/telephony/NetworkInfoWithAcT.java     |  201 ++
 .../internal/telephony/NetworkManager.java         |  101 +
 .../telephony/RadioCapabilitySwitchUtil.java       |  310 +++
 .../telephony/dataconnection/FdManager.java        |  421 ++++
 .../internal/telephony/uicc/IccCardProxyEx.java    |  390 ++++
 .../internal/telephony/worldphone/IWorldPhone.java |   86 +
 .../telephony/worldphone/WorldPhoneOm.java         |  912 ++++++++
 .../telephony/worldphone/WorldPhoneUtil.java       |  246 +++
 .../telephony/worldphone/WorldPhoneWrapper.java    |   86 +
 48 files changed, 8359 insertions(+), 61 deletions(-)
 create mode 100644 src/java/com/android/internal/telephony/MediaTekRIL.java
 create mode 100644 src/java/com/mediatek/internal/telephony/EtwsNotification.java
 create mode 100644 src/java/com/mediatek/internal/telephony/EtwsUtils.java
 create mode 100755 src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
 create mode 100755 src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
 create mode 100755 src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
 create mode 100755 src/java/com/mediatek/internal/telephony/NetworkManager.java
 create mode 100755 src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
 create mode 100755 src/java/com/mediatek/internal/telephony/dataconnection/FdManager.java
 create mode 100755 src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index 3b5cb4e..9d4bee8 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -97,6 +97,25 @@ public abstract class BaseCommands implements CommandsInterface {
     protected Registrant mCatCcAlphaRegistrant;
     protected Registrant mSsRegistrant;
 
+    // MTK registrants
+    protected RegistrantList mPhoneRatFamilyChangedRegistrants = new RegistrantList();
+    protected RegistrantList mSessionChangedRegistrants = new RegistrantList();
+    protected RegistrantList mSimMissing = new RegistrantList();
+    protected RegistrantList mSimRecovery = new RegistrantList();
+    protected RegistrantList mVirtualSimOn = new RegistrantList();
+    protected RegistrantList mVirtualSimOff = new RegistrantList();
+    protected RegistrantList mSimPlugOutRegistrants = new RegistrantList();
+    protected RegistrantList mSimPlugInRegistrants = new RegistrantList();
+    protected RegistrantList mCommonSlotNoChangedRegistrants = new RegistrantList();
+    protected RegistrantList mDataAllowedRegistrants = new RegistrantList();
+    protected RegistrantList mNeighboringInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNetworkInfoRegistrants = new RegistrantList();
+    protected RegistrantList mPlmnChangeNotificationRegistrant = new RegistrantList();
+    protected RegistrantList mPsNetworkStateRegistrants = new RegistrantList();
+    protected Registrant mRegistrationSuspendedRegistrant;
+    // M: fast dormancy.
+    protected Registrant mScriResultRegistrant;
+
     // Preferred network type received from PhoneFactory.
     // This is used when establishing a connection to the
     // vendor ril so it starts up in the correct mode.
@@ -108,6 +127,12 @@ public abstract class BaseCommands implements CommandsInterface {
     // RIL Version
     protected int mRilVersion = -1;
 
+    // MTK states
+    /* M: call control part start */
+    protected boolean mbWaitingForECFURegistrants = false;
+    protected Object mCfuReturnValue = null; ///* M: SS part */
+    /* M: call control part end */
+
     public BaseCommands(Context context) {
         mContext = context;  // May be null (if so we won't log statistics)
     }
@@ -936,4 +961,188 @@ public abstract class BaseCommands implements CommandsInterface {
         return TelephonyManager.getLteOnGsmModeStatic();
     }
 
+    // MTK additions
+
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response) {
+    }
+
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result) {
+    }
+
+    @Override
+    public void iccIOForAppEx(int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, String aid, int channel, Message response) {
+    }
+
+    @Override
+    public void registerForSessionChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSessionChangedRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForSessionChanged(Handler h) {
+        mSessionChangedRegistrants.remove(h);
+    }
+    //MTK-END Support Multi-Application
+
+    //MTK-START Support SIM ME lock
+    @Override
+    public void queryNetworkLock(int categrory, Message response){};
+
+    @Override
+    public void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response){};
+    //MTK-END Support SIM ME lock
+
+    @Override
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                          String param2, Message response) {
+    }
+
+    public void registerForSimMissing(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimMissing.add(r);
+    }
+    public void unregisterForSimMissing(Handler h) {
+        mSimMissing.remove(h);
+    }
+
+    public void registerForSimRecovery(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimRecovery.add(r);
+    }
+
+    public void unregisterForSimRecovery(Handler h) {
+        mSimRecovery.remove(h);
+    }
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOn.add(r);
+    }
+
+    public void unregisterForVirtualSimOn(Handler h) {
+        mVirtualSimOn.remove(h);
+    }
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOff.add(r);
+    }
+
+    public void unregisterForVirtualSimOff(Handler h) {
+        mVirtualSimOff.remove(h);
+    }
+
+    public void registerForSimPlugOut(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugOutRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugOut(Handler h) {
+        mSimPlugOutRegistrants.remove(h);
+    }
+
+    public void registerForSimPlugIn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugInRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugIn(Handler h) {
+        mSimPlugInRegistrants.remove(h);
+    }
+
+    public void registerForCommonSlotNoChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCommonSlotNoChangedRegistrants.add(r);
+    }
+
+    public void unregisterForCommonSlotNoChanged(Handler h) {
+        mCommonSlotNoChangedRegistrants.remove(h);
+    }
+
+    public void registerForPsNetworkStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mPsNetworkStateRegistrants.add(r);
+    }
+
+    public void unregisterForPsNetworkStateChanged(Handler h) {
+        mPsNetworkStateRegistrants.remove(h);
+    }
+
+    public void registerForNeighboringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNeighboringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNeighboringInfo(Handler h) {
+        mNeighboringInfoRegistrants.remove(h);
+    }
+
+    public void registerForNetworkInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNetworkInfo(Handler h) {
+        mNetworkInfoRegistrants.remove(h);
+    }
+
+    public void setTrm(int mode, Message result) {}
+
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPlmnChangeNotificationRegistrant.add(r);
+    }
+
+    public void unSetOnPlmnChangeNotification(Handler h) {
+        mPlmnChangeNotificationRegistrant.remove(h);
+    }
+
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+        mRegistrationSuspendedRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnRegistrationSuspended(Handler h) {
+        mRegistrationSuspendedRegistrant.clear();
+    }
+
+    @Override
+    public void setPhoneRatFamily(int ratFamily, Message response) {
+    }
+
+    @Override
+    public void getPhoneRatFamily(Message response) {
+    }
+
+    @Override
+    public void registerForPhoneRatFamilyChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPhoneRatFamilyChangedRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForPhoneRatFamilyChanged(Handler h) {
+        mPhoneRatFamilyChangedRegistrants.remove(h);
+    }
+
+    // M: fast dormancy
+    public void setScriResult(Handler h, int what, Object obj) {
+        mScriResultRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetScriResult(Handler h) {
+        mScriResultRegistrant.clear();
+    }
+
+    public void setScri(boolean forceRelease, Message response){
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response){
+    }
 }
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 89e30ae..dfa968e 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -102,6 +102,15 @@ public interface CommandsInterface {
     static final int USSD_MODE_NOT_SUPPORTED = 4;
     static final int USSD_MODE_NW_TIMEOUT    = 5;
 
+    /* M: SS part */
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    static final int USSD_SESSION_END               = 2;
+    static final int USSD_HANDLED_BY_STK            = 3;
+    static final int USSD_OPERATION_NOT_SUPPORTED   = 4;
+    static final int USSD_NETWORK_TIMEOUT           = 5;
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+    /* M: SS part end */
+
     // GSM SMS fail cause for acknowledgeLastIncomingSMS. From TS 23.040, 9.2.3.22.
     static final int GSM_SMS_FAIL_CAUSE_MEMORY_CAPACITY_EXCEEDED    = 0xD3;
     static final int GSM_SMS_FAIL_CAUSE_USIM_APP_TOOLKIT_BUSY       = 0xD4;
@@ -114,6 +123,19 @@ public interface CommandsInterface {
     static final int CDMA_SMS_FAIL_CAUSE_OTHER_TERMINAL_PROBLEM     = 39;
     static final int CDMA_SMS_FAIL_CAUSE_ENCODING_PROBLEM           = 96;
 
+    //MTK AT CMD +ESMLCK
+    static final int CAT_NETWOEK                = 0;
+    static final int CAT_NETOWRK_SUBSET         = 1;
+    static final int CAT_SERVICE_PROVIDER       = 2;
+    static final int CAT_CORPORATE              = 3;
+    static final int CAT_SIM                    = 4;
+
+    static final int OP_UNLOCK                  = 0;
+    static final int OP_LOCK                    = 1;
+    static final int OP_ADD                     = 2;
+    static final int OP_REMOVE                  = 3;
+    static final int OP_PERMANENT_UNLOCK        = 4;
+
     //***** Methods
     RadioState getRadioState();
 
@@ -2018,4 +2040,232 @@ public interface CommandsInterface {
      */
     void setOnCatSendSmsResult(Handler h, int what, Object obj);
     void unSetOnCatSendSmsResult(Handler h);
+
+    // MTK additions
+
+    //MTK-START multiple application support
+    /**
+     * M: Open application in the UICC
+     *
+     * @param application: application ID
+     * @param response The message to send.
+     */
+    public void openIccApplication(int application, Message response);
+
+    /**
+     * Query application status
+     *
+     * @param sessionId: The channel ID
+     * @param response The message to send.
+     */
+    public void getIccApplicationStatus(int sessionId, Message result);
+
+    /**
+     * parameters equivalent to 27.007 AT+CRLA command
+     * channel is used to assign which application to get EF file.
+     * response.obj will be an AsyncResult
+     * response.obj.userObj will be a IccIoResult on success
+     */
+    void iccIOForAppEx(int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, String aid, int channel, Message response);
+
+    /**
+     * Register the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSessionChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSessionChanged(Handler h);
+    //MTK-END multiple application support
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  0 for Network personalisation category
+     *                  1 for Network subset personalisation category
+     *                  2 for Service provider personalisation category
+     *                  3 for Corporate(GID) personalisation category
+     *                  4 for SIM/USIM(IMSI) personalisation category
+     * @param response Callback message containing response structure.
+     */
+    void queryNetworkLock(int categrory, Message response);
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  "0" for Network personalisation category
+     *                  "1" for Network subset personalisation category
+     *                  "2" for Service provider personalisation category
+     *                  "3" for Corporate(GID) personalisation category
+     *                  "4" for SIM/USIM(IMSI) personalisation category
+     * @param lockop lock operation
+     *               "0" for unlock opreation
+     *               "1" for lock opreation
+     *               "2" for add lock opreation
+     *               "3" for remove lock opreation
+     *               "4" for disable lock category opreation
+     * @param password password of indicated network lock
+     * @param data_imsi IMSI value used to setup lock
+     * @param gid1 GID1 value used to setup lock
+     * @param gid2 GID2 value used to setup lock
+     * @param response Callback message containing response structure.
+     */
+    void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response);
+
+
+    /**
+     * Request security context authentication for SIM/USIM/ISIM
+     */
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                                    String param2, Message response);
+
+    void iccGetATR(Message result);
+    void iccOpenChannelWithSw(String AID, Message result);
+
+    void registerForSimMissing(Handler h, int what, Object obj);
+    void unregisterForSimMissing(Handler h);
+
+    void registerForSimRecovery(Handler h, int what, Object obj);
+    void unregisterForSimRecovery(Handler h);
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOn(Handler h);
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOff(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugOut(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugOut(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugIn(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugIn(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void registerForCommonSlotNoChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void unregisterForCommonSlotNoChanged(Handler h);
+
+    void registerForPsNetworkStateChanged(Handler h, int what, Object obj);
+    void unregisterForPsNetworkStateChanged(Handler h);
+
+    /**
+     * unlike the register* methods, there's only one Neighboring cell info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the RAT
+     * ((Object[])AsyncResult.result)[1] is a String containing the neighboring cell info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNeighboringInfo(Handler h, int what, Object obj);
+    void unregisterForNeighboringInfo(Handler h);
+
+    /**
+     * unlike the register* methods, there's only one Network info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the type
+     * ((Object[])AsyncResult.result)[1] is a String contain the network info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNetworkInfo(Handler h, int what, Object obj);
+    void unregisterForNetworkInfo(Handler h);
+
+    void setTrm(int mode, Message result);
+
+    void setOnPlmnChangeNotification(Handler h, int what, Object obj);
+    void unSetOnPlmnChangeNotification(Handler h);
+    void setOnRegistrationSuspended(Handler h, int what, Object obj);
+    void unSetOnRegistrationSuspended(Handler h);
+    void setResumeRegistration(int sessionId, Message response);
+    void storeModemType(int modemType, Message response);
+    void queryModemType(Message response);
+
+    /**
+     *  Set phone RAT family.
+     *
+     *  @param ratFamily bit mask to identify PhoneRatFamily.PHONE_RAT_FAMILY_2G,
+     *         PhoneRatFamily.PHONE_RAT_FAMILY_3G, PhoneRatFamily.PHONE_RAT_FAMILY_4G
+     *  @param result Callback message.
+     */
+    public void setPhoneRatFamily(int ratFamily, Message result);
+
+    /**
+     *  Get phone RAT family.
+     *
+     *  @param result Callback message.
+     */
+    public void getPhoneRatFamily(Message result);
+
+    /**
+     * Registers the handler when phone RAT family is changed.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    public void registerForPhoneRatFamilyChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for notifications when phone RAT family is changed.
+     *
+     * @param h Handler to be removed from the registrant list.
+     */
+    public void unregisterForPhoneRatFamilyChanged(Handler h);
+
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result);
+
+    // Fast Dormancy
+    void setScri(boolean forceRelease, Message response);
+    void setFDMode(int mode, int parameter1, int parameter2, Message response);
+    public void setScriResult(Handler h, int what, Object obj);
+    public void unSetScriResult(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/HardwareConfig.java b/src/java/com/android/internal/telephony/HardwareConfig.java
index 0f855de..9a35a01 100644
--- a/src/java/com/android/internal/telephony/HardwareConfig.java
+++ b/src/java/com/android/internal/telephony/HardwareConfig.java
@@ -161,6 +161,7 @@ public class HardwareConfig {
             maxActiveVoiceCall = maxV;
             maxActiveDataCall = maxD;
             maxStandby = maxS;
+            Rlog.d(LOG_TAG, "assignModem: result=" + this.toString());
         }
     }
 
@@ -169,6 +170,7 @@ public class HardwareConfig {
             uuid = id;
             modemUuid = link;
             state = state;
+            Rlog.d(LOG_TAG, "assignSim: result=" + this.toString());
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/IccCard.java b/src/java/com/android/internal/telephony/IccCard.java
index 7d182be..6e1d35b 100644
--- a/src/java/com/android/internal/telephony/IccCard.java
+++ b/src/java/com/android/internal/telephony/IccCard.java
@@ -21,6 +21,7 @@ import android.os.Message;
 
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccRecords;
 
@@ -231,4 +232,92 @@ public interface IccCard {
      * @return true if ICC card is PUK2 blocked
      */
     public boolean getIccPuk2Blocked();
+
+    // MTK additions
+
+    // Added by M begin
+    /**
+     * Use to query the network lock type.
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public PersoSubState getNetworkPersoType();
+
+    /**
+     * Use to query indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void queryIccNetworkLock(int category, Message onComplete);
+
+    /**
+     * Use to set indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param lockop 0: Unlock, 1: Lock, 2:Add, 3:Remove, 4:Permanently unlock
+     * @param password password of indicated category lock
+     * @param data_imsi IMSI
+     * @param gid1 GID1 value
+     * @param gid2 GID2 value
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete);
+
+    /**
+     * Use to repolling icc card status (Used by SIM ME lock related enhancement feature)
+     *
+     * @param needIntent indicated need an Intent to notify needed to unlock another SIM or not.
+     *                   if yes, will broadcast TelephonyIntents.ACTION_UNLOCK_SIM_LOCK to notify.
+     *                   if no, will notify by original TelephonyIntents.ACTION_SIM_STATE_CHANGED.
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent);
+
+    /**
+     * NFC API, use to exchange SIM IO.
+     *
+     * @internal
+     */
+    public void exchangeSimIo(int fileID, int command,
+            int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete);
+
+    /**
+     * NFC API, use to get ATR.
+     *
+     * @internal
+     */
+    public void iccGetAtr(Message onComplete);
+
+    public String getIccCardType();
+
+     /**
+     * NFC API, use to open logical channel with sw.
+     *
+     * @internal
+     */
+    public void openLogicalChannelWithSw(String AID, Message onComplete);
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    public void registerForFdnChanged(Handler h, int what, Object obj);
+    public void unregisterForFdnChanged(Handler h);
+
+    // Added by M end
 }
diff --git a/src/java/com/android/internal/telephony/MediaTekRIL.java b/src/java/com/android/internal/telephony/MediaTekRIL.java
new file mode 100644
index 0000000..947fc3f
--- /dev/null
+++ b/src/java/com/android/internal/telephony/MediaTekRIL.java
@@ -0,0 +1,2259 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project <http://www.omnirom.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.PhoneRatFamily;
+import android.telephony.Rlog;
+import android.telephony.SignalStrength;
+
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Vector;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.UiccController;
+
+public class MediaTekRIL extends RIL implements CommandsInterface {
+
+    // TODO: Support multiSIM
+    // Sim IDs are 0 / 1
+    int mSimId = 0;
+
+    /* ALPS00799783: for restore previous preferred network type when set type fail */
+    private int mPreviousPreferredType = -1;
+
+    /* M: call control part start */
+    /* DTMF request will be ignored when duplicated sending */
+    private class dtmfQueueHandler {
+
+        public dtmfQueueHandler() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public void start() {
+            mDtmfStatus = DTMF_STATUS_START;
+        }
+
+        public void stop() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public boolean isStart() {
+            return (mDtmfStatus == DTMF_STATUS_START);
+        }
+
+        public void add(RILRequest o) {
+            mDtmfQueue.addElement(o);
+        }
+
+        public void remove(RILRequest o) {
+            mDtmfQueue.remove(o);
+        }
+
+        public void remove(int idx) {
+            mDtmfQueue.removeElementAt(idx);
+        }
+
+        public RILRequest get() {
+            return (RILRequest) mDtmfQueue.get(0);
+        }
+
+        public int size() {
+            return mDtmfQueue.size();
+        }
+
+        public void setPendingRequest(RILRequest r) {
+            mPendingCHLDRequest = r;
+        }
+
+        public RILRequest getPendingRequest() {
+            return mPendingCHLDRequest;
+        }
+
+        public void setSendChldRequest() {
+            mIsSendChldRequest = true;
+        }
+
+        public void resetSendChldRequest() {
+            mIsSendChldRequest = false;
+        }
+
+        public boolean hasSendChldRequest() {
+            riljLog("mIsSendChldRequest = " + mIsSendChldRequest);
+            return mIsSendChldRequest;
+        }
+
+        public final int MAXIMUM_DTMF_REQUEST = 32;
+        private final boolean DTMF_STATUS_START = true;
+        private final boolean DTMF_STATUS_STOP = false;
+
+        private boolean mDtmfStatus = DTMF_STATUS_STOP;
+        private Vector mDtmfQueue = new Vector(MAXIMUM_DTMF_REQUEST);
+
+        private RILRequest mPendingCHLDRequest = null;
+        private boolean mIsSendChldRequest = false;
+    }
+
+    private dtmfQueueHandler mDtmfReqQueue = new dtmfQueueHandler();
+    /* M: call control part end */
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription) {
+	    super(context, networkMode, cdmaSubscription, null);
+    }
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription, Integer instanceId) {
+	    super(context, networkMode, cdmaSubscription, instanceId);
+    }
+
+    public static byte[] hexStringToBytes(String s) {
+        byte[] ret;
+
+        if (s == null) return null;
+
+        int len = s.length();
+        ret = new byte[len/2];
+
+        for (int i=0 ; i <len ; i+=2) {
+            ret[i/2] = (byte) ((hexCharToInt(s.charAt(i)) << 4)
+                                | hexCharToInt(s.charAt(i+1)));
+        }
+
+        return ret;
+    }
+
+    static int hexCharToInt(char c) {
+         if (c >= '0' && c <= '9') return (c - '0');
+         if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
+         if (c >= 'a' && c <= 'f') return (c - 'a' + 10);
+
+         throw new RuntimeException ("invalid hex char '" + c + "'");
+    }
+
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        if (mInstanceId == null || mInstanceId == 0) {
+            mSimId = 0;
+        } else {
+            mSimId = mInstanceId;
+        }
+
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multiples of 4");
+        }
+
+        String lacStr = SystemProperties.get("gsm.cops.lac");
+        boolean lacValid = false;
+        int lacIndex=0;
+
+        Rlog.d(RILJ_LOG_TAG, "lacStr = " + lacStr+" lacStr.length="+lacStr.length()+" strings.length="+strings.length);
+        if((lacStr.length() > 0) && (lacStr.length()%4 == 0) && ((lacStr.length()/4) == (strings.length/5 ))){
+            Rlog.d(RILJ_LOG_TAG, "lacValid set to true");
+            lacValid = true;
+        }
+
+        SystemProperties.set("gsm.cops.lac","");
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            if((strings[i+0] != null) && (strings[i+0].startsWith("uCs2") == true)) {
+                riljLog("responseOperatorInfos handling UCS2 format name");
+
+                try {
+                    strings[i+0] = new String(hexStringToBytes(strings[i+0].substring(4)), "UTF-16");
+                } catch(UnsupportedEncodingException ex) {
+                    riljLog("responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+
+            if ((lacValid == true) && (strings[i] != null)) {
+                UiccController uiccController = UiccController.getInstance();
+                IccRecords iccRecords = uiccController.getIccRecords(mSimId, UiccController.APP_FAM_3GPP);
+                int lacValue = -1;
+                String sEons = null;
+                String lac = lacStr.substring(lacIndex,lacIndex+4);
+                Rlog.d(RILJ_LOG_TAG, "lacIndex="+lacIndex+" lacValue="+lacValue+" lac="+lac+" plmn numeric="+strings[i+2]+" plmn name"+strings[i+0]);
+
+                if(lac != "") {
+                    lacValue = Integer.parseInt(lac, 16);
+                    lacIndex += 4;
+                    if(lacValue != 0xfffe) {
+                        /*sEons = iccRecords.getEonsIfExist(strings[i+2],lacValue,true);
+                        if(sEons != null) {
+                            strings[i] = sEons;
+                            Rlog.d(RILJ_LOG_TAG, "plmn name update to Eons: "+strings[i]);
+                        }*/
+                    } else {
+                        Rlog.d(RILJ_LOG_TAG, "invalid lac ignored");
+                    }
+                }
+            }
+
+            if (strings[i] != null && (strings[i].equals("") || strings[i].equals(strings[i+2]))) {
+                Operators init = new Operators ();
+                String temp = init.unOptimizedOperatorReplace(strings[i+2]);
+                riljLog("lookup RIL responseOperatorInfos() " + strings[i+2] + " gave " + temp);
+                strings[i] = temp;
+                strings[i+1] = temp;
+            }
+
+            // NOTE: We don't have the 5th element in MTK, and I don't know about
+            // the cases that make this processing necessary. Disable for now.
+            /*
+            // 1, 2 = 2G
+            // > 2 = 3G
+            String property_name = "gsm.baseband.capability";
+            if(mSimId > 0) {
+                property_name = property_name + (mSimId+1);
+            }
+
+            int basebandCapability = SystemProperties.getInt(property_name, 3);
+            Rlog.d(RILJ_LOG_TAG, "property_name="+property_name+", basebandCapability=" + basebandCapability);
+            if (3 < basebandCapability) {
+                strings[i+0] = strings[i+0].concat(" " + strings[i+4]);
+                strings[i+1] = strings[i+1].concat(" " + strings[i+4]);
+            }
+            */
+
+            ret.add(
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+
+    private Object
+    responseCrssNotification(Parcel p) {
+        /*SuppCrssNotification notification = new SuppCrssNotification();
+
+        notification.code = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+        notification.alphaid = p.readString();
+        notification.cli_validity = p.readInt();
+
+        return notification;*/
+
+        Rlog.e(RILJ_LOG_TAG, "NOT PROCESSING CRSS NOTIFICATION");
+        return null;
+    }
+
+    private Object responseEtwsNotification(Parcel p) {
+        /*EtwsNotification response = new EtwsNotification();
+
+        response.warningType = p.readInt();
+        response.messageId = p.readInt();
+        response.serialNumber = p.readInt();
+        response.plmnId = p.readString();
+        response.securityInfo = p.readString();
+
+        return response;*/
+        Rlog.e(RILJ_LOG_TAG, "NOT PROCESSING ETWS NOTIFICATION");
+
+        return null;
+    }
+
+    private Object responseSetupDedicateDataCall(Parcel p) {
+        int number = p.readInt();
+        if (RILJ_LOGD) riljLog("responseSetupDedicateDataCall number=" + number);
+        /*
+        DedicateDataCallState[] dedicateDataCalls = new DedicateDataCallState[number];
+        for (int i=0; i<number; i++) {
+            DedicateDataCallState dedicateDataCall = new DedicateDataCallState();
+            dedicateDataCall.readFrom(p);
+            dedicateDataCalls[i] = dedicateDataCall;
+
+            riljLog("[" + dedicateDataCall.interfaceId + ", " + dedicateDataCall.defaultCid + ", " + dedicateDataCall.cid + ", " + dedicateDataCall.active +
+                ", " + dedicateDataCall.signalingFlag + ", " + dedicateDataCall.failCause + ", Qos" + dedicateDataCall.qosStatus +
+                ", Tft" + dedicateDataCall.tftStatus + ", PCSCF" + dedicateDataCall.pcscfInfo);
+        }
+
+        if (number > 1)
+            return dedicateDataCalls;
+        else if (number > 0)
+            return dedicateDataCalls[0];
+        else
+            return null;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseSetupDedicateDataCall: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseSetPhoneRatChanged(Parcel p) {
+        int num = p.readInt();
+        int rat = p.readInt();
+        PhoneRatFamily response = new PhoneRatFamily(mInstanceId, rat);
+
+        return response;
+    }
+
+    private Object
+    responseNetworkInfoWithActs(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseNetworkInfoWithActs: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseOperatorInfosWithAct(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseOperatorInfosWithAct: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseFemtoCellInfos(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseFemtoCellInfos: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseSmsParams(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseSmsParams: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseSimSmsMemoryStatus(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseSimSmsMemoryStatus: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseCbConfig(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseCbConfig: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseModifyDataCall(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseModifyDataCall: stub!");
+
+        return null;
+    }
+
+    private Object
+    responsePcscfDiscovery(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responsePcscfDiscovery: stub!");
+
+        return null;
+    }
+
+    private Object
+    responseGetNitzTime(Parcel p) {
+        Rlog.e(RILJ_LOG_TAG, "responseGetNitzTime: stub!");
+
+        return null;
+    }
+
+    @Override
+    public void setLocalCallHold(int lchStatus) {
+        byte[] payload = new byte[]{(byte)(lchStatus & 0x7F)};
+        Rlog.d(RILJ_LOG_TAG, "setLocalCallHold: lchStatus is " + lchStatus);
+
+        // sendOemRilRequestRaw(OEMHOOK_EVT_HOOK_SET_LOCAL_CALL_HOLD, 1, payload, null);
+        Rlog.e(RILJ_LOG_TAG, "setLocalCallHold: stub!");
+    }
+
+    @Override
+    public void getModemCapability(Message response) {
+        Rlog.d(RILJ_LOG_TAG, "GetModemCapability");
+        // sendOemRilRequestRaw(OEMHOOK_EVT_HOOK_GET_MODEM_CAPABILITY, 0, null, response);
+        Rlog.w(RILJ_LOG_TAG, "GetModemCapability: not really implemented!");
+        AsyncResult.forMessage(response, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
+        response.sendToTarget();
+    }
+
+    @Override
+    public void updateStackBinding(int stack, int enable, Message response) {
+        byte[] payload = new byte[]{(byte)stack,(byte)enable};
+        Rlog.d(RILJ_LOG_TAG, "UpdateStackBinding: on Stack: " + stack +
+                ", enable/disable: " + enable);
+
+        // sendOemRilRequestRaw(OEMHOOK_EVT_HOOK_UPDATE_SUB_BINDING, 2, payload, response);
+        Rlog.e(RILJ_LOG_TAG, "UpdateStackBinding: stub!");
+    }
+
+    @Override
+    public void
+    startDtmf(char c, Message result) {
+        /* M: call control part start */
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (!mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+                    rr.mParcel.writeString(Character.toString(c));
+                    mDtmfReqQueue.start();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send start dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /* M: call control part end */
+    }
+    @Override
+    public void
+    stopDtmf(Message result) {
+        /* M: call control part start */
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
+
+                    mDtmfReqQueue.stop();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send stop dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /* M: call control part end */
+    }
+
+    @Override
+    public void
+    switchWaitingOrHoldingAndActive (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(
+                        RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE,
+                                        result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /* M: call control part start */
+        handleChldRelatedRequest(rr);
+        /* M: call control part end */
+    }
+
+    @Override
+    public void
+    conference (Message result) {
+
+        /* M: call control part start */
+        /*
+        if (MobileManagerUtils.isSupported()) {
+            if (!checkMoMSSubPermission(SubPermissions.MAKE_CONFERENCE_CALL)) {
+                return;
+            }
+        }
+        */
+        /* M: call control part end */
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /* M: call control part start */
+        handleChldRelatedRequest(rr);
+        /* M: call control part end */
+    }
+
+    @Override
+    public void
+    separateConnection (int gsmIndex, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SEPARATE_CONNECTION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                            + " " + gsmIndex);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(gsmIndex);
+
+        /* M: call control part start */
+        handleChldRelatedRequest(rr);
+        /* M: call control part end */
+    }
+
+    @Override
+    public void
+    explicitCallTransfer (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_EXPLICIT_CALL_TRANSFER, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /* M: call control part start */
+        handleChldRelatedRequest(rr);
+        /* M: call control part end */
+    }
+
+    // all that C&P just for responseOperator overriding?
+    @Override
+    protected RILRequest
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return null;
+        }
+
+        /* M: call control part start */
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        if ((rr.mRequest == RIL_REQUEST_DTMF_START) ||
+            (rr.mRequest == RIL_REQUEST_DTMF_STOP)) {
+            synchronized (mDtmfReqQueue) {
+                mDtmfReqQueue.remove(rr);
+                riljLog("remove first item in dtmf queue done, size = " + mDtmfReqQueue.size());
+                if (mDtmfReqQueue.size() > 0) {
+                    RILRequest rr2 = mDtmfReqQueue.get();
+                    if (RILJ_LOGD) riljLog(rr2.serialString() + "> " + requestToString(rr2.mRequest));
+                    send(rr2);
+                } else {
+                    if (mDtmfReqQueue.getPendingRequest() != null) {
+                        riljLog("send pending switch request");
+                        send(mDtmfReqQueue.getPendingRequest());
+                        mDtmfReqQueue.setSendChldRequest();
+                        mDtmfReqQueue.setPendingRequest(null);
+                    }
+                }
+            }
+        }
+        /* M: call control part end */
+        Object ret = null;
+
+        if ((rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS) ||
+            (rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT)) {
+            // mGetAvailableNetworkDoneRegistrant.notifyRegistrants();
+            Rlog.e(RILJ_LOG_TAG, "mGetAvailableNetworkDoneRegistrant.notifyRegistrants(); -- not implemented!");
+        }
+
+        /* ALPS00799783 START */
+        if (rr.mRequest == RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE) {
+            if ((error != 0) && (mPreviousPreferredType != -1)) {
+                riljLog("restore mPreferredNetworkType from " + mPreferredNetworkType + " to " + mPreviousPreferredType);
+                mPreferredNetworkType = mPreviousPreferredType;
+            }
+            mPreviousPreferredType = -1; //reset
+        }
+        /* ALPS00799783 END */
+
+        /* M: call control part start */
+        if (rr.mRequest == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ||
+            rr.mRequest == RIL_REQUEST_CONFERENCE ||
+            rr.mRequest == RIL_REQUEST_SEPARATE_CONNECTION ||
+            rr.mRequest == RIL_REQUEST_EXPLICIT_CALL_TRANSFER) {
+            riljLog("clear mIsSendChldRequest");
+            mDtmfReqQueue.resetSendChldRequest();
+        }
+        /* M: call control part end */
+
+        if (error == 0 || p.dataAvail() > 0) {
+
+            /* Convert RIL_REQUEST_GET_MODEM_VERSION back */
+            if (SystemProperties.get("ro.cm.device").indexOf("e73") == 0 &&
+                  rr.mRequest == 220) {
+                rr.mRequest = RIL_REQUEST_BASEBAND_VERSION;
+            }
+
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret = responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseOperator(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret = responseDeactivateDataCall(p); break; //VoLTE
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseGetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_ISIM_AUTHENTICATION: ret =  responseString(p); break;
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: ret = responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_VOICE_RADIO_TECH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_CELL_INFO_LIST: ret = responseCellInfoList(p); break;
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_DATA_PROFILE: ret = responseVoid(p); break;
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: ret = responseInts(p); break;
+            case RIL_REQUEST_IMS_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: ret  = responseInts(p); break;
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: ret  = responseVoid(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_NV_READ_ITEM: ret = responseString(p); break;
+            case RIL_REQUEST_NV_WRITE_ITEM: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_RESET_CONFIG: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: ret = responseVoid(p); break;
+            case RIL_REQUEST_ALLOW_DATA: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: ret = responseHardwareConfig(p); break;
+            case RIL_REQUEST_SIM_AUTHENTICATION: ret =  responseICC_IOBase64(p); break;
+            case RIL_REQUEST_SHUTDOWN: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_PHONE_RAT_FAMILY: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_PHONE_RAT_FAMILY: ret =  responsePhoneId(); break;
+
+            /* M: call control part start */
+            case RIL_REQUEST_HANGUP_ALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_FORCE_RELEASE_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CALL_INDICATION: ret = responseVoid(p); break;
+            case RIL_REQUEST_EMERGENCY_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_LIST: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: ret = responseVoid(p); break;
+            /* M: call control part end */
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: ret = responseVoid(p); break;
+            case RIL_REQUEST_RETRIEVE_HELD_CALL: ret = responseVoid(p); break;
+            /// @}
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            //MTK-END SIM ME lock
+            //MTK-START multiple application support
+            case RIL_REQUEST_GENERAL_SIM_AUTH: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: ret = responseIccCardStatus(p); break;
+            //MTK-END multiple application support
+            case RIL_REQUEST_SIM_IO_EX: ret =  responseICC_IO(p); break;
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_PHB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY: {
+                // ret = responsePhbEntries(p); break;
+                Rlog.e(RILJ_LOG_TAG, "RIL_REQUEST_READ_PHB_ENTRY: stub!");
+                ret = responseVoid(p); break;
+            }
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_READ_UPB_GRP: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_UPB_GRP: ret = responseVoid(p); break;
+            case RIL_REQUEST_EDIT_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_DELETE_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_UPB_GAS_LIST: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: {
+                // ret = responseGetPhbMemStorage(p); break;
+                Rlog.e(RILJ_LOG_TAG, "RIL_REQUEST_GET_PHB_MEM_STORAGE: stub!");
+                ret = responseVoid(p); break;
+            }
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: {
+                // ret = responseReadPhbEntryExt(p); break;
+                Rlog.e(RILJ_LOG_TAG, "RIL_REQUEST_READ_PHB_ENTRY_EXT: stub!");
+                ret = responseVoid(p); break;
+            }
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: ret = responseVoid(p); break;
+            // PHB End
+
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_POL_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_POL_LIST: ret = responseNetworkInfoWithActs(p); break;
+            case RIL_REQUEST_SET_POL_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_TRM: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : ret =  responseOperatorInfosWithAct(p); break;
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: ret = responseVoid(p); break;
+
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: ret = responseFemtoCellInfos(p); break;
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: ret = responseVoid(p); break;
+            case RIL_REQUEST_SELECT_FEMTOCELL: ret = responseVoid(p); break;
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+
+            case RIL_REQUEST_QUERY_MODEM_TYPE: ret = responseInts(p); break;
+            case RIL_REQUEST_STORE_MODEM_TYPE: ret = responseVoid(p); break;
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_FD_MODE: ret = responseInts(p); break;
+
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: ret = responseSmsParams(p); break;
+            case RIL_REQUEST_SET_SMS_PARAMS: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: ret = responseSimSmsMemoryStatus(p); break;
+            case RIL_REQUEST_SET_ETWS: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: ret = responseCbConfig(p); break;
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: ret = responseVoid(p); break;
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: ret = responseVoid(p); break;
+
+            //VoLTE
+            case RIL_REQUEST_SETUP_DEDICATE_DATA_CALL: ret = responseSetupDedicateDataCall(p); break;
+            case RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_MODIFY_DATA_CALL: ret = responseModifyDataCall(p); break;
+            case RIL_REQUEST_ABORT_SETUP_DATA_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_PCSCF_DISCOVERY_PCO: ret=responsePcscfDiscovery(p); break;
+            case RIL_REQUEST_CLEAR_DATA_BEARER: ret=responseVoid(p); break;
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: ret = responseVoid(p); break;
+
+            case RIL_REQUEST_BTSIM_CONNECT: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: ret = responseVoid(p); break;
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: ret = responseString(p); break;
+
+            /* M: call control part start */
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: ret = responseVoid(p); break;
+            /* M: call control part end */
+
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: ret = responseGetNitzTime(p); break;
+            case RIL_REQUEST_QUERY_UIM_INSERTED: ret = responseInts(p); break;
+            case RIL_REQUEST_SWITCH_HPF: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_AVOID_SYS: ret = responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVOID_SYS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_LOCAL_INFO: ret =  responseInts(p); break;
+            case RIL_REQUEST_UTK_REFRESH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION: ret = responseInts(p); break;
+            case RIL_REQUEST_AGPS_TCP_CONNIND: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: ret = responseStrings(p); break;
+            case RIL_REQUEST_SET_MEID: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REG_RESUME: ret =  responseVoid(p); break;
+            case RIL_REQUEST_ENABLE_REG_PAUSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ETS_DEV: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_MDN: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_VIA_TRM: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: ret =  responseVoid(p); break;
+            /* M: C2K part end */
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                return rr;
+            }
+        }
+
+        if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
+            // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
+            // regardless of error code to continue shutdown procedure.
+            riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " +
+                    error + " Setting Radio State to Unavailable regardless of error.");
+            setRadioState(RadioState.RADIO_UNAVAILABLE);
+        }
+
+        // Here and below fake RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, see b/7255789.
+        // This is needed otherwise we don't automatically transition to the main lock
+        // screen when the pin or puk is entered incorrectly.
+        switch (rr.mRequest) {
+            case RIL_REQUEST_ENTER_SIM_PUK:
+            case RIL_REQUEST_ENTER_SIM_PUK2:
+                if (mIccStatusChangedRegistrants != null) {
+                    if (RILJ_LOGD) {
+                        riljLog("ON enter sim puk fakeSimStatusChanged: reg count="
+                                + mIccStatusChangedRegistrants.size());
+                    }
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+        }
+
+        if (error != 0) {
+            switch (rr.mRequest) {
+                case RIL_REQUEST_ENTER_SIM_PIN:
+                case RIL_REQUEST_ENTER_SIM_PIN2:
+                case RIL_REQUEST_CHANGE_SIM_PIN:
+                case RIL_REQUEST_CHANGE_SIM_PIN2:
+                case RIL_REQUEST_SET_FACILITY_LOCK:
+                    if (mIccStatusChangedRegistrants != null) {
+                        if (RILJ_LOGD) {
+                            riljLog("ON some errors fakeSimStatusChanged: reg count="
+                                    + mIccStatusChangedRegistrants.size());
+                        }
+                        mIccStatusChangedRegistrants.notifyRegistrants();
+                    }
+                    break;
+
+                case RIL_REQUEST_SET_PHONE_RAT_FAMILY:
+                    if (RILJ_LOGD) {
+                        riljLog("Set phone RAT failed, send response with phone ID");
+                    }
+                    ret = responsePhoneId();
+                    break;
+            }
+
+            rr.onError(error, ret);
+            return rr;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        return rr;
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition(); // save off position within the Parcel
+        int response = p.readInt();
+
+        switch(response) {
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_INVALID_SIM:  ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_ACMT: ret = responseInts(p); break;
+            case RIL_UNSOL_IMEI_LOCK: ret = responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_EVDL_CALL: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_CALL_CTRL: ret = responseStrings(p); break;
+
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: ret =  responseInts(p); break;
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: ret = responseHardwareConfig(p); break;
+            // fxxk this conflicts with RIL_UNSOL_RADIO_CAPABILITY...
+            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE:
+                     ret = responseSetPhoneRatChanged(p); break;
+            /* M: call control part start */
+            case RIL_UNSOL_CALL_FORWARDING: ret = responseInts(p); break;
+            case RIL_UNSOL_CRSS_NOTIFICATION: ret = responseCrssNotification(p); break;
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: ret = responseStrings(p); break;
+            case RIL_UNSOL_CIPHER_INDICATION: ret = responseStrings(p); break;
+            case RIL_UNSOL_CNAP: ret = responseStrings(p); break;
+            case RIL_UNSOL_SPEECH_CODEC_INFO: ret =  responseInts(p); break;
+            /* M: call control part end */
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: ret = responseInts(p); break;
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_RECOVERY: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_ON: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_PLUG_OUT: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_PLUG_IN: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: ret = responseVoid(p); break;
+            case RIL_UNSOL_DATA_ALLOWED: ret = responseVoid(p); break;
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: ret = responseVoid(p); break;
+            // IMS
+            case RIL_UNSOL_IMS_ENABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_DISABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: ret = responseInts(p); break;
+            //VoLTE
+            case RIL_UNSOL_DEDICATE_BEARER_ACTIVATED: ret = responseSetupDedicateDataCall(p);break;
+            case RIL_UNSOL_DEDICATE_BEARER_MODIFIED: ret = responseSetupDedicateDataCall(p);break;
+            case RIL_UNSOL_DEDICATE_BEARER_DEACTIVATED: ret = responseInts(p);break;
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: ret = responseInts(p); break;
+
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [End]
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT: ret = responseInts(p); break;
+
+            /// M: IMS feature. @{
+            //For updating call ids for conference call after SRVCC is done.
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: ret = responseInts(p); break;
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: ret = responseStrings(p); break;
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : ret = responseStrings(p); break;
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:ret = responseInts(p); break;
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: ret = responseVoid(p); break;
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: ret = responseVoid(p); break;
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: ret = responseInts(p); break;
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SSAC_BARRING_INFO: ret = responseInts(p); break;
+//MTK_TC1_FEATURE for LGE CSMCC_MO_CALL_MODIFIED {
+            case RIL_UNSOL_RESPONSE_MO_CALL_STATE_CHANGED: ret =  responseStrings(p); break;
+//}
+            /* M: C2K part start*/
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_VIA_GPS_EVENT: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE: ret = responseStrings(p); break;
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: ret = responseVoid(p); break;
+            /* M: C2K part end*/
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        // To avoid duplicating code from RIL.java, we rewrite some response codes to fit
+        // AOSP's one (when they do the same effect)
+        boolean rewindAndReplace = false;
+        int newResponseCode = 0;
+
+        switch (response) {
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mNeighboringInfoRegistrants != null) {
+                    mNeighboringInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_NETWORK_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mNetworkInfoRegistrants != null) {
+                    mNetworkInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                riljLog("mPhoneRatFamilyreg size :" + mPhoneRatFamilyChangedRegistrants.size());
+                if (mPhoneRatFamilyChangedRegistrants != null) {
+                    mPhoneRatFamilyChangedRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_PHB_READY_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                Rlog.e(RILJ_LOG_TAG, "RIL_UNSOL_PHB_READY_NOTIFICATION: stub!");
+                /*
+                if (mPhbReadyRegistrants != null) {
+                    mPhbReadyRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                */
+                break;
+
+            case RIL_UNSOL_STK_EVDL_CALL:
+                Rlog.e(RILJ_LOG_TAG, "RIL_UNSOL_STK_EVDL_CALL: stub!");
+                /*
+                if (false == SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    if (RILJ_LOGD) unsljLogvRet(response, ret);
+                    if (mStkEvdlCallRegistrant != null) {
+                        mStkEvdlCallRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                    }
+                }
+                */
+                break;
+
+            case RIL_UNSOL_STK_CALL_CTRL:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                Rlog.e(RILJ_LOG_TAG, "RIL_UNSOL_STK_CALL_CTRL: stub!");
+                /*
+                if (mStkCallCtrlRegistrant != null) {
+                    mStkCallCtrlRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                */
+                break;
+
+            case RIL_UNSOL_STK_SETUP_MENU_RESET:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                Rlog.e(RILJ_LOG_TAG, "RIL_UNSOL_STK_SETUP_MENU_RESET: stub!");
+                /*
+                if (mStkSetupMenuResetRegistrant != null) {
+                    mStkSetupMenuResetRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                */
+                break;
+
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: {
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSessionChangedRegistrants != null) {
+                    mSessionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            }
+            //MTK-END multiple application support
+
+            case RIL_UNSOL_SIM_MISSING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimMissing != null) {
+                    mSimMissing.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_RECOVERY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimRecovery != null) {
+                    mSimRecovery.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_VIRTUAL_SIM_ON:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOn != null) {
+                    mVirtualSimOn.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_VIRTUAL_SIM_OFF:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOff != null) {
+                    mVirtualSimOff.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_PLUG_OUT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugOutRegistrants != null) {
+                    mSimPlugOutRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                mCfuReturnValue = null;
+                break;
+
+            case RIL_UNSOL_SIM_PLUG_IN:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugInRegistrants != null) {
+                    mSimPlugInRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mCommonSlotNoChangedRegistrants != null) {
+                    mCommonSlotNoChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mPlmnChangeNotificationRegistrant != null) {
+                    mPlmnChangeNotificationRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRegistrationSuspendedRegistrant != null) {
+                    mRegistrationSuspendedRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT:
+                Integer scriResult = (((int[]) ret)[0]);
+                riljLog("s:" + scriResult + ":" + (((int[]) ret)[0]));
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mScriResultRegistrant != null) {
+                   mScriResultRegistrant.notifyRegistrant(new AsyncResult(null, scriResult, null));
+                }
+                break;
+
+            /*
+            case RIL_UNSOL_CALL_PROGRESS_INFO:
+                rewindAndReplace = true;
+                newResponseCode = RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED;
+                break;
+                */
+
+            case RIL_UNSOL_INCOMING_CALL_INDICATION:
+                setCallIndication((String[])ret);
+                rewindAndReplace = true;
+                newResponseCode = RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED;
+                break;
+
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mPsNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+
+            case RIL_UNSOL_SMS_READY_NOTIFICATION:
+                Rlog.e(RILJ_LOG_TAG, "RIL_UNSOL_SMS_READY_NOTIFICATION: stub!");
+                /*if (mGsmSmsRegistrant != null) {
+                    mGsmSmsRegistrant
+                        .notifyRegistrant();
+                }*/
+                break;
+
+            default:
+                Rlog.i(RILJ_LOG_TAG, "Unprocessed unsolicited known MTK response: " + response);
+        }
+
+        if (rewindAndReplace) {
+            Rlog.w(RILJ_LOG_TAG, "Rewriting MTK unsolicited response " + response + " to " + newResponseCode);
+
+            // Rewrite
+            p.setDataPosition(dataPosition);
+            p.writeInt(newResponseCode);
+
+            // And rewind again in front
+            p.setDataPosition(dataPosition);
+
+            super.processUnsolicited(p);
+        }
+    }
+
+	static String
+    requestToString(int request) {
+/*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
+*/
+        switch(request) {
+            case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+            case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+            case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+            case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+            case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+            case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+            case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+            case RIL_REQUEST_ENTER_DEPERSONALIZATION_CODE: return "ENTER_DEPERSONALIZATION_CODE";
+            case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+            case RIL_REQUEST_DIAL: return "DIAL";
+            case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+            case RIL_REQUEST_HANGUP: return "HANGUP";
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+            case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+            case RIL_REQUEST_UDUB: return "UDUB";
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
+            case RIL_REQUEST_OPERATOR: return "OPERATOR";
+            case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+            case RIL_REQUEST_DTMF: return "DTMF";
+            case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+            case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+            case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            /* M: SS part */
+            ///M: For query CNAP
+            case RIL_REQUEST_SEND_CNAP: return "SEND_CNAP";
+            /* M: SS part end */
+            case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+            case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+            case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+            case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+            case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+            case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+            case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+            case RIL_REQUEST_ANSWER: return "ANSWER";
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+            case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
+            case RIL_REQUEST_DTMF_START: return "DTMF_START";
+            case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+            case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+            case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+            case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+            case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+            case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+            case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+            case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+            case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+            case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
+            case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+            case RIL_REQUEST_STK_GET_PROFILE: return "REQUEST_STK_GET_PROFILE";
+            case RIL_REQUEST_STK_SET_PROFILE: return "REQUEST_STK_SET_PROFILE";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "REQUEST_EXPLICIT_CALL_TRANSFER";
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "REQUEST_GET_NEIGHBORING_CELL_IDS";
+            case RIL_REQUEST_SET_LOCATION_UPDATES: return "REQUEST_SET_LOCATION_UPDATES";
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
+            case RIL_REQUEST_SET_TTY_MODE: return "RIL_REQUEST_SET_TTY_MODE";
+            case RIL_REQUEST_QUERY_TTY_MODE: return "RIL_REQUEST_QUERY_TTY_MODE";
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_FLASH: return "RIL_REQUEST_CDMA_FLASH";
+            case RIL_REQUEST_CDMA_BURST_DTMF: return "RIL_REQUEST_CDMA_BURST_DTMF";
+            case RIL_REQUEST_CDMA_SEND_SMS: return "RIL_REQUEST_CDMA_SEND_SMS";
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
+            case RIL_REQUEST_DEVICE_IDENTITY: return "RIL_REQUEST_DEVICE_IDENTITY";
+            case RIL_REQUEST_GET_SMSC_ADDRESS: return "RIL_REQUEST_GET_SMSC_ADDRESS";
+            case RIL_REQUEST_SET_SMSC_ADDRESS: return "RIL_REQUEST_SET_SMSC_ADDRESS";
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_ISIM_AUTHENTICATION: return "RIL_REQUEST_ISIM_AUTHENTICATION";
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
+            case RIL_REQUEST_VOICE_RADIO_TECH: return "RIL_REQUEST_VOICE_RADIO_TECH";
+            case RIL_REQUEST_GET_CELL_INFO_LIST: return "RIL_REQUEST_GET_CELL_INFO_LIST";
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
+            case RIL_REQUEST_SET_DATA_PROFILE: return "RIL_REQUEST_SET_DATA_PROFILE";
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: return "RIL_REQUEST_IMS_REGISTRATION_STATE";
+            case RIL_REQUEST_IMS_SEND_SMS: return "RIL_REQUEST_IMS_SEND_SMS";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: return "RIL_REQUEST_SIM_OPEN_CHANNEL";
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
+            case RIL_REQUEST_NV_READ_ITEM: return "RIL_REQUEST_NV_READ_ITEM";
+            case RIL_REQUEST_NV_WRITE_ITEM: return "RIL_REQUEST_NV_WRITE_ITEM";
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
+            case RIL_REQUEST_NV_RESET_CONFIG: return "RIL_REQUEST_NV_RESET_CONFIG";
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
+            case RIL_REQUEST_ALLOW_DATA: return "RIL_REQUEST_ALLOW_DATA";
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
+            case RIL_REQUEST_SIM_AUTHENTICATION: return "RIL_REQUEST_SIM_AUTHENTICATION";
+            case RIL_REQUEST_SHUTDOWN: return "RIL_REQUEST_SHUTDOWN";
+            case RIL_REQUEST_SET_PHONE_RAT_FAMILY: return "RIL_REQUEST_SET_PHONE_RAT_FAMILY";
+            case RIL_REQUEST_GET_PHONE_RAT_FAMILY: return "RIL_REQUEST_GET_PHONE_RAT_FAMILY";
+
+            /* M: call control part start */
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /* M: call control part end */
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RETRIEVE_HELD_CALL: return "RIL_REQUEST_RETRIEVE_HELD_CALL";
+            /// @}
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+            //VoLTE
+            case RIL_REQUEST_SETUP_DEDICATE_DATA_CALL: return "RIL_REQUEST_SETUP_DEDICATE_DATA_CALL";
+            case RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL: return "RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL";
+            case RIL_REQUEST_MODIFY_DATA_CALL: return "RIL_REQUEST_MODIFY_DATA_CALL";
+            case RIL_REQUEST_ABORT_SETUP_DATA_CALL: return "RIL_REQUEST_ABORT_SETUP_DATA_CALL";
+            case RIL_REQUEST_PCSCF_DISCOVERY_PCO: return "RIL_REQUEST_PCSCF_DISCOVERY_PCO";
+            case RIL_REQUEST_CLEAR_DATA_BEARER: return "RIL_REQUEST_CLEAR_DATA_BEARER";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /* M: call control part start */
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /* M: call control part end */
+
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS:
+                return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION:
+                return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_REG_RESUME: return "RIL_REQUEST_SET_REG_RESUME";
+            case RIL_REQUEST_ENABLE_REG_PAUSE: return "RIL_REQUEST_ENABLE_REG_PAUSE";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            /* M: C2K part end */
+            default: return "<unknown request> (" + request + ")";
+        }
+    }
+
+    // VoLTE
+    private Object
+    responseDeactivateDataCall(Parcel p) {
+        int [] cidArray = null;
+        if (p.dataSize() > 0 ) {    //checking Parcel data value
+            cidArray = (int []) responseInts(p);
+        }
+
+        return cidArray;
+    }
+
+    private Object
+    responseOperator(Parcel p) {
+        int num;
+        String response[] = null;
+
+        response = p.readStringArray();
+
+        if (false) {
+            num = p.readInt();
+
+            response = new String[num];
+            for (int i = 0; i < num; i++) {
+                response[i] = p.readString();
+            }
+        }
+
+        for (int i = 0; i < response.length; i++) {
+            if((response[i] != null) && (response[i].startsWith("uCs2") == true))
+            {
+                riljLog("responseOperator handling UCS2 format name: response[" + i + "]");
+                try{
+                    response[i] = new String(hexStringToBytes(response[i].substring(4)),"UTF-16");
+                }catch(UnsupportedEncodingException ex){
+                    riljLog("responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+        }
+
+        // NOTE: the original code seemingly has some nontrivial SpnOverride
+        // modifications, so I'm not going to port that.
+        if (response.length > 2 && response[2] != null) {
+            if (response[0] != null && (response[0].equals("") || response[0].equals(response[2]))) {
+	        Operators init = new Operators ();
+	        String temp = init.unOptimizedOperatorReplace(response[2]);
+	        riljLog("lookup RIL responseOperator() " + response[2] + " gave " + temp + " was " + response[0] + "/" + response[1] + " before.");
+	        response[0] = temp;
+	        response[1] = temp;
+            }
+        }
+
+        return response;
+    }
+
+    private Object
+    responsePhoneId() {
+        return mInstanceId;
+    }
+
+    static String
+    responseToString(int request)
+    {
+/*
+ cat libs/telephony/ril_unsol_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
+*/
+        switch(request) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
+            case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
+            case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST";
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
+            case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
+            case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
+            case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
+            case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_RESPONSE_CDMA_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
+            case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
+            case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
+            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
+            case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
+            case RIL_UNSOl_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
+            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
+            case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
+            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
+                return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
+                    return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
+                    return "UNSOL_SRVCC_STATE_NOTIFY";
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
+            case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
+            case RIL_UNSOL_STK_SEND_SMS_RESULT: return "RIL_UNSOL_STK_SEND_SMS_RESULT";
+            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE:
+                    return "RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE";
+            /* M: call control part start */
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "UNSOL_CIPHER_INDICATION";
+            case RIL_UNSOL_CNAP: return "UNSOL_CNAP";
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /* M: call control part end */
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_INVALID_SIM: return "RIL_UNSOL_INVALID_SIM";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //VoLTE
+            case RIL_UNSOL_DEDICATE_BEARER_ACTIVATED: return "RIL_UNSOL_DEDICATE_BEARER_ACTIVATED";
+            case RIL_UNSOL_DEDICATE_BEARER_MODIFIED: return "RIL_UNSOL_DEDICATE_BEARER_MODIFIED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: return "RIL_UNSOL_MO_DATA_BARRING_INFO";
+            case RIL_UNSOL_SSAC_BARRING_INFO: return "RIL_UNSOL_SSAC_BARRING_INFO";
+//MTK_TC1_FEATURE for LGE CSMCC_MO_CALL_MODIFIED {
+			case RIL_UNSOL_RESPONSE_MO_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_MO_CALL_STATE_CHANGED";
+//}
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: return "RIL_UNSOL_CDMA_CALL_ACCEPTED";
+            case RIL_UNSOL_UTK_SESSION_END: return "RIL_UNSOL_UTK_SESSION_END";
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: return "RIL_UNSOL_UTK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: return "RIL_UNSOL_UTK_EVENT_NOTIFY";
+            case RIL_UNSOL_VIA_GPS_EVENT: return "RIL_UNSOL_VIA_GPS_EVENT";
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: return "RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE";
+            case RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE: return "RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE";
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: return "RIL_UNSOL_VIA_INVALID_SIM_DETECTED";
+            /* M: C2K part end */
+            default: return "<unknown response> (" + request + ")";
+        }
+    }
+
+    /*
+     * to protect modem status we need to avoid two case :
+     * 1. DTMF start -> CHLD request -> DTMF stop
+     * 2. CHLD request -> DTMF request
+     */
+    private void handleChldRelatedRequest(RILRequest rr) {
+        synchronized (mDtmfReqQueue) {
+            int queueSize = mDtmfReqQueue.size();
+            int i, j;
+            if (queueSize > 0) {
+                RILRequest rr2 = mDtmfReqQueue.get();
+                if (rr2.mRequest == RIL_REQUEST_DTMF_START) {
+                    // need to send the STOP command
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is START, send stop dtmf and pending switch");
+                    if (queueSize > 1) {
+                        j = 2;
+                    } else {
+                        // need to create a new STOP command
+                        j = 1;
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  " + mDtmfReqQueue.size());
+
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  after " + mDtmfReqQueue.size());
+                    if (mDtmfReqQueue.size() == 1) { // only start command, we need to add stop command
+                        RILRequest rr3 = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, null);
+                        if (RILJ_LOGD) riljLog("add dummy stop dtmf request");
+                        mDtmfReqQueue.stop();
+                        mDtmfReqQueue.add(rr3);
+                    }
+                }
+                else {
+                    // first request is STOP, just remove it and send switch
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is STOP, penging switch");
+                    j = 1;
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                }
+                mDtmfReqQueue.setPendingRequest(rr);
+            } else {
+                if (RILJ_LOGD) riljLog("DTMF queue is 0, send switch Immediately");
+                mDtmfReqQueue.setSendChldRequest();
+                send(rr);
+            }
+        }
+    }
+
+    private
+    void setCallIndication(String[] incomingCallInfo) {
+	RILRequest rr
+            = RILRequest.obtain(RIL_REQUEST_SET_CALL_INDICATION, null);
+
+	int callId = Integer.parseInt(incomingCallInfo[0]);
+        int callMode = Integer.parseInt(incomingCallInfo[3]);
+        int seqNumber = Integer.parseInt(incomingCallInfo[4]);
+
+	// some guess work is needed here, for now, just 0
+	callMode = 0;
+
+        rr.mParcel.writeInt(3);
+
+        rr.mParcel.writeInt(callMode);
+        rr.mParcel.writeInt(callId);
+        rr.mParcel.writeInt(seqNumber);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+            + requestToString(rr.mRequest) + " " + callMode + " " + callId + " " + seqNumber);
+
+        send(rr);
+    }
+
+    // Override setupDataCall as the MTK RIL needs 8th param CID (hardwired to 1?)
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mParcel.writeInt(8);
+
+        rr.mParcel.writeString(radioTechnology);
+        rr.mParcel.writeString(profile);
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(user);
+        rr.mParcel.writeString(password);
+        rr.mParcel.writeString(authType);
+        rr.mParcel.writeString(protocol);
+        rr.mParcel.writeString("1");
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol + "1");
+
+        send(rr);
+    }
+
+    protected Object
+    responseSignalStrength(Parcel p) {
+        SignalStrength s = SignalStrength.makeSignalStrengthFromRilParcel(p);
+	return new SignalStrength(s.getGsmSignalStrength(),
+				  s.getGsmBitErrorRate(),
+				  s.getCdmaDbm(),
+				  s.getCdmaEcio(),
+				  s.getEvdoDbm(),
+				  s.getEvdoEcio(),
+				  s.getEvdoSnr(),
+				  true);
+    }
+
+    private void setRadioStateFromRILInt (int stateCode) {
+        switch (stateCode) {
+	case 0: case 1: break; // radio off
+	default:
+	    {
+	        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_GPRS_TRANSFER_TYPE, null);
+
+		if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+		rr.mParcel.writeInt(1);
+		rr.mParcel.writeInt(1);
+
+		send(rr);
+	    }
+	    {
+	        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_GPRS_CONNECT_TYPE, null);
+
+		if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+		rr.mParcel.writeInt(1);
+		rr.mParcel.writeInt(1);
+
+		send(rr);
+	    }
+	}
+    }
+
+    /* Oh well... this broke non-dual-SIM phones including MX4 :-/
+    @Override
+    public void
+    setRadioPower(boolean on, Message result) {
+	if ((mInstanceId != null && mInstanceId == 1)) {
+		riljLog("SetRadioPower: on/off ignored on SIM2");
+		return;
+	}
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DUAL_SIM_MODE_SWITCH, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(on ? 3 : -1); // SIM1 | SIM2 ?
+        send(rr);
+    }
+    */
+
+    @Override
+    public void setUiccSubscription(int slotId, int appIndex, int subId,
+				    int subStatus, Message result) {
+	    if (RILJ_LOGD) riljLog("setUiccSubscription" + slotId + " " + appIndex + " " + subId + " " + subStatus);
+
+	    // Fake response (note: should be sent before mSubscriptionStatusRegistrants or
+	    // SubscriptionManager might not set the readiness correctly)
+	    AsyncResult.forMessage(result, 0, null);
+	    result.sendToTarget();
+
+	    // TODO: Actually turn off/on the radio (and don't fight with the ServiceStateTracker)
+	    if (subStatus == 1 /* ACTIVATE */) {
+		    // Subscription changed: enabled
+		    if (mSubscriptionStatusRegistrants != null) {
+			    mSubscriptionStatusRegistrants.notifyRegistrants(
+									     new AsyncResult (null, new int[] {1}, null));
+		    }
+	    } else if (subStatus == 0 /* DEACTIVATE */) {
+		    // Subscription changed: disabled
+		    if (mSubscriptionStatusRegistrants != null) {
+			    mSubscriptionStatusRegistrants.notifyRegistrants(
+									     new AsyncResult (null, new int[] {0}, null));
+		    }
+	    }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(networkType);
+
+        mPreviousPreferredType = mPreferredNetworkType; //ALPS00799783
+        mPreferredNetworkType = networkType;
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+
+        send(rr);
+    }
+
+    /** M: add extra parameter */
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Message result) {
+        Rlog.e(RILJ_LOG_TAG, "setInitialAttachApn: operatorNumeric is required on MTK!");
+        setInitialAttachApn(apn, protocol, authType, username, password, "", false, result);
+    }
+
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_INITIAL_ATTACH_APN, null);
+
+        if (RILJ_LOGD) riljLog("Set RIL_REQUEST_SET_INITIAL_ATTACH_APN");
+
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(protocol);
+        rr.mParcel.writeInt(authType);
+        rr.mParcel.writeString(username);
+        rr.mParcel.writeString(password);
+
+        /** M: start */
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeInt(canHandleIms ? 1 : 0);
+        /* M: end */
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", apn:" + apn + ", protocol:" + protocol + ", authType:" + authType
+                + ", username:" + username + ", password:" + password
+                + ", operatorNumeric:" + operatorNumeric + ", canHandleIms:" + canHandleIms);
+
+        send(rr);
+    }
+
+    private static int readRilMessage(InputStream is, byte[] buffer)
+            throws IOException {
+        int countRead;
+        int offset;
+        int remaining;
+        int messageLength;
+
+        // First, read in the length of the message
+        offset = 0;
+        remaining = 4;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message length");
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        messageLength = ((buffer[0] & 0xff) << 24)
+                | ((buffer[1] & 0xff) << 16)
+                | ((buffer[2] & 0xff) << 8)
+                | (buffer[3] & 0xff);
+
+        // Then, re-use the buffer and read in the message itself
+        offset = 0;
+        remaining = messageLength;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message.  messageLength=" + messageLength
+                        + " remaining=" + remaining);
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        return messageLength;
+    }
+
+	protected RILReceiver createRILReceiver() {
+        return new MTKRILReceiver();
+    }
+
+	protected class MTKRILReceiver extends RILReceiver {
+        byte[] buffer;
+
+        protected MTKRILReceiver() {
+            buffer = new byte[RIL_MAX_COMMAND_BYTES];
+        }
+
+        @Override
+        public void
+        run() {
+            int retryCount = 0;
+            String rilSocket = "rild";
+
+            try {for (;;) {
+                LocalSocket s = null;
+                LocalSocketAddress l;
+
+                if (mInstanceId == null || mInstanceId == 0 ) {
+                    rilSocket = SOCKET_NAME_RIL[0];
+                } else {
+                    rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                }
+
+                int currentSim;
+                if (mInstanceId == null || mInstanceId ==0) {
+                    currentSim = 0;
+                } else {
+                    currentSim = mInstanceId;
+                }
+
+                int m3GsimId = 0;
+                m3GsimId =  SystemProperties.getInt("gsm.3gswitch", 0);
+                if((m3GsimId > 0) && (m3GsimId <= 2)) {
+                    --m3GsimId;
+                } else {
+                    m3GsimId = 0;
+                }
+
+                if (m3GsimId >= 1) {
+                    if (currentSim == 0) {
+                       rilSocket = SOCKET_NAME_RIL[m3GsimId];
+                    }
+                    else if(currentSim == m3GsimId) {
+                       rilSocket = SOCKET_NAME_RIL[0];
+                    }
+                    if (RILJ_LOGD) riljLog("Capability switched, swap sockets [" + currentSim + ", " + rilSocket + "]");
+                }
+
+                try {
+                    s = new LocalSocket();
+                    l = new LocalSocketAddress(rilSocket,
+                            LocalSocketAddress.Namespace.RESERVED);
+                    s.connect(l);
+                } catch (IOException ex){
+                    try {
+                        if (s != null) {
+                            s.close();
+                        }
+                    } catch (IOException ex2) {
+                        //ignore failure to close after failure to connect
+                    }
+
+                    // don't print an error message after the the first time
+                    // or after the 8th time
+
+                    if (retryCount == 8) {
+                        Rlog.e (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket after " + retryCount
+                            + " times, continuing to retry silently");
+                    } else if (retryCount >= 0 && retryCount < 8) {
+                        Rlog.i (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket; retrying after timeout");
+                    }
+
+                    try {
+                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                    } catch (InterruptedException er) {
+                    }
+
+                    retryCount++;
+                    continue;
+                }
+
+                retryCount = 0;
+
+                mSocket = s;
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '"
+                        + rilSocket + "' socket");
+
+                /* Compatibility with qcom's DSDS (Dual SIM) stack */
+                if (needsOldRilFeature("qcomdsds")) {
+                    String str = "SUB1";
+                    byte[] data = str.getBytes();
+                    try {
+                        mSocket.getOutputStream().write(data);
+                        Rlog.i(RILJ_LOG_TAG, "Data sent!!");
+                    } catch (IOException ex) {
+                            Rlog.e(RILJ_LOG_TAG, "IOException", ex);
+                    } catch (RuntimeException exc) {
+                        Rlog.e(RILJ_LOG_TAG, "Uncaught exception ", exc);
+                    }
+                }
+
+                int length = 0;
+                try {
+                    InputStream is = mSocket.getInputStream();
+
+                    for (;;) {
+                        Parcel p;
+
+                        length = readRilMessage(is, buffer);
+
+                        if (length < 0) {
+                            // End-of-stream reached
+                            break;
+                        }
+
+                        p = Parcel.obtain();
+                        p.unmarshall(buffer, 0, length);
+                        p.setDataPosition(0);
+
+                        //Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
+
+                        processResponse(p);
+                        p.recycle();
+                    }
+                } catch (java.io.IOException ex) {
+                    Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed",
+                          ex);
+                } catch (Throwable tr) {
+                    Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length +
+                        "Exception:" + tr.toString());
+                }
+
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket
+                      + "' socket");
+
+                setRadioState (RadioState.RADIO_UNAVAILABLE);
+
+                try {
+                    mSocket.close();
+                } catch (IOException ex) {
+                }
+
+                mSocket = null;
+                RILRequest.resetSerial();
+
+                // Clear request list on close
+                clearRequestList(RADIO_NOT_AVAILABLE, false);
+            }} catch (Throwable tr) {
+                Rlog.e(RILJ_LOG_TAG,"Uncaught exception", tr);
+            }
+
+            /* We're disconnected so we don't know the ril version */
+            notifyRegistrantsRilConnectionChanged(-1);
+        }
+    }
+
+    /* broken by new version of MTK RIL, disable for now */
+    /*
+    public void handle3GSwitch() {
+        int simId = mInstanceId == null ? 0 : mInstanceId;
+        int newsim = SystemProperties.getInt("gsm.3gswitch", 0);
+        newsim = newsim - 1;
+        if(!(simId==newsim)) {
+	    int prop = SystemProperties.getInt("gsm.3gswitch", 0);
+            if (RILJ_LOGD) riljLog("Setting data subscription on SIM" + (simId + 1) + " mInstanceid=" + mInstanceId + " gsm.3gswitch=" + prop);
+            RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_3G_CAPABILITY, null);
+            rr.mParcel.writeInt(1);
+            int realsim = simId + 1;
+            rr.mParcel.writeInt(realsim);
+            if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+            send(rr);
+	    try {
+                Thread.sleep(1000);
+            } catch (InterruptedException er) {
+            }
+	    resetRadio(null);
+	    try {
+                Thread.sleep(4*1000);
+            } catch (InterruptedException er) {
+            }
+	}
+	else {
+            if (RILJ_LOGD) riljLog("Not setting data subscription on same SIM");
+	}
+    }
+
+    public void setDataAllowed(boolean allowed, Message result) {
+        handle3GSwitch();
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ALLOW_DATA, result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + allowed);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(allowed ? 1 : 0);
+        send(rr);
+    }
+    */
+}
diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index b412f2b..6b8ba87 100644
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -2064,4 +2064,39 @@ public interface Phone {
      * @return true if IMS is Registered
      */
     public boolean isImsRegistered();
+
+    // MTK addditions
+
+    /**
+     *  Set phone RAT family.
+     *
+     *  @param ratFamily bit mask to identify PhoneRatFamily.PHONE_RAT_FAMILY_2G,
+     *         PhoneRatFamily.PHONE_RAT_FAMILY_3G, PhoneRatFamily.PHONE_RAT_FAMILY_4G
+     *  @param response Callback message.
+     */
+    public void setPhoneRatFamily(int ratFamily, Message response);
+
+    /**
+     *  Get phone RAT family.
+     *
+     *  @return a bit mask to identify PhoneRatFamily.PHONE_RAT_FAMILY_2G,
+     *          PhoneRatFamily.PHONE_RAT_FAMILY_3G, PhoneRatFamily.PHONE_RAT_FAMILY_4G
+     */
+    public int getPhoneRatFamily();
+
+    /**
+     * Registers the handler when phone RAT family is changed.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    public void registerForPhoneRatFamilyChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for notifications when phone RAT family is changed.
+     *
+     * @param h Handler to be removed from the registrant list.
+     */
+    public void unregisterForPhoneRatFamilyChanged(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index 5ef81eb..dfbe0c2 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -42,6 +42,7 @@ import android.telephony.CellIdentityCdma;
 import android.telephony.CellInfo;
 import android.telephony.CellInfoCdma;
 import android.telephony.DataConnectionRealTimeInfo;
+import android.telephony.PhoneRatFamily;
 import android.telephony.VoLteServiceState;
 import android.telephony.Rlog;
 import android.telephony.ServiceState;
@@ -179,7 +180,21 @@ public abstract class PhoneBase extends Handler implements Phone {
     protected static final int EVENT_SET_CALL_FORWARD_TIMER_DONE    = 37;
     protected static final int EVENT_GET_CALL_FORWARD_TIMER_DONE    = 38;
     protected static final int EVENT_GET_CALLFORWARDING_STATUS      = 39;
-    protected static final int EVENT_LAST                   = EVENT_GET_CALLFORWARDING_STATUS;
+    // MTK
+    protected static final int EVENT_GET_PHONE_RAT_FAMILY              = 41;
+    protected static final int EVENT_PHONE_RAT_FAMILY_CHANGED_NOTIFY   = 42;
+    protected static final int EVENT_LAST                   = EVENT_PHONE_RAT_FAMILY_CHANGED_NOTIFY;
+
+    // MTK again - wtf
+    /// M: c2k modify, event constants. @{
+    protected static final int EVENT_SET_MEID_DONE                  = 101;
+    protected static final int EVENT_RUIM_READY                     = 102;
+    /// @}
+
+    /** M: for suspend data during plmn list */
+    protected static final int EVENT_GET_AVAILABLE_NETWORK_DONE = 500520;
+    protected static final int EVENT_DC_SWITCH_STATE_CHANGE = 500521;
+    protected static final int EVENT_GET_AVAILABLE_NETWORK = 500522;
 
     // For shared prefs.
     private static final String GSM_ROAMING_LIST_OVERRIDE_PREFIX = "gsm_roaming_list_";
@@ -252,6 +267,9 @@ public abstract class PhoneBase extends Handler implements Phone {
     private boolean mImsServiceReady = false;
     protected static ImsPhone mImsPhone = null;
 
+    // give the empty phone RAT family at initial, we will update it when radio available
+    protected int mPhoneRatFamily = PhoneRatFamily.PHONE_RAT_FAMILY_NONE;
+
     @Override
     public String getPhoneName() {
         return mName;
@@ -349,6 +367,9 @@ public abstract class PhoneBase extends Handler implements Phone {
     protected final RegistrantList mVideoCapabilityChangedRegistrants
             = new RegistrantList();
 
+    // MTK
+    protected final RegistrantList mPhoneRatFamilyChangedRegistrants
+            = new RegistrantList();
 
     protected Looper mLooper; /* to insure registrants are in correct thread*/
 
@@ -608,6 +629,19 @@ public abstract class PhoneBase extends Handler implements Phone {
                 }
                 break;
 
+            case EVENT_PHONE_RAT_FAMILY_CHANGED_NOTIFY:
+                ar = (AsyncResult) msg.obj;
+                Rlog.d(LOG_TAG, "Event EVENT_PHONE_RAT_FAMILY_CHANGED_NOTIFY "
+                        + mPhoneRatFamilyChangedRegistrants.size());
+                if (ar.exception == null) {
+                    PhoneRatFamily rat = (PhoneRatFamily)(ar.result);
+                    Rlog.d(LOG_TAG, "update mPhoneRatFamily, "
+                        + mPhoneRatFamilyChangedRegistrants.size() + ", " + rat);
+                    mPhoneRatFamily = rat.getRatFamily();
+                }
+                mPhoneRatFamilyChangedRegistrants.notifyRegistrants((AsyncResult) msg.obj);
+                break;
+
             default:
                 throw new RuntimeException("unexpected event not handled");
         }
@@ -2338,6 +2372,32 @@ public abstract class PhoneBase extends Handler implements Phone {
                 + this);
     }
 
+    // MTK additions
+
+    @Override
+    public void setPhoneRatFamily(int ratFamily, Message response) {
+        mCi.setPhoneRatFamily(ratFamily, response);
+    }
+
+    @Override
+    public int getPhoneRatFamily() {
+        Rlog.d(LOG_TAG, "getPhoneRatFamily:ID:" + mPhoneId + ", RAT:" + mPhoneRatFamily);
+        return mPhoneRatFamily;
+    }
+
+    @Override
+    public void registerForPhoneRatFamilyChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPhoneRatFamilyChangedRegistrants.add(r);
+        mCi.registerForPhoneRatFamilyChanged(this, EVENT_PHONE_RAT_FAMILY_CHANGED_NOTIFY, null);
+    }
+
+    @Override
+    public void unregisterForPhoneRatFamilyChanged(Handler h) {
+        mPhoneRatFamilyChangedRegistrants.remove(h);
+        mCi.unregisterForPhoneRatFamilyChanged(this);
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("PhoneBase: subId=" + getSubId());
         pw.println(" mPhoneId=" + mPhoneId);
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 08ea27c..9440e36 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -42,6 +42,10 @@ import com.android.internal.telephony.sip.SipPhoneFactory;
 import com.android.internal.telephony.uicc.IccCardProxy;
 import com.android.internal.telephony.uicc.UiccController;
 
+import com.mediatek.internal.telephony.worldphone.IWorldPhone;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneWrapper;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.reflect.Constructor;
@@ -75,6 +79,9 @@ public class PhoneFactory {
     static private PhoneNotifier sPhoneNotifier;
     static private Context sContext;
 
+    // MTK
+    static private IWorldPhone sWorldPhone = null;
+
     //***** Class Methods
 
     public static void makeDefaultPhones(Context context) {
@@ -236,6 +243,11 @@ public class PhoneFactory {
                 sSubInfoRecordUpdater = new SubscriptionInfoUpdater(context,
                         sProxyPhones, sCommandsInterfaces);
                 SubscriptionController.getInstance().updatePhonesAvailability(sProxyPhones);
+
+                // MTK
+                if (WorldPhoneUtil.isWorldPhoneSupport()) {
+                    sWorldPhone = WorldPhoneWrapper.getWorldPhoneInstance();
+                }
             }
         }
     }
@@ -257,6 +269,14 @@ public class PhoneFactory {
         }
     }
 
+    public static IWorldPhone getWorldPhone() {
+        if (sWorldPhone == null) {
+            Rlog.d(LOG_TAG, "sWorldPhone is null");
+        }
+
+        return sWorldPhone;
+    }
+
     private static <T> T instantiateCustomRIL(
                       String sRILClassname, Context context, int networkMode, int cdmaSubscription, Integer instanceId)
                       throws Exception {
diff --git a/src/java/com/android/internal/telephony/PhoneProxy.java b/src/java/com/android/internal/telephony/PhoneProxy.java
index 8246d23..18b6e15 100644
--- a/src/java/com/android/internal/telephony/PhoneProxy.java
+++ b/src/java/com/android/internal/telephony/PhoneProxy.java
@@ -1589,4 +1589,27 @@ public class PhoneProxy extends Handler implements Phone {
         pw.flush();
         pw.println("++++++++++++++++++++++++++++++++");
     }
+
+    // MTK additions
+
+    @Override
+    public void setPhoneRatFamily(int ratFamily, Message response) {
+        mActivePhone.setPhoneRatFamily(ratFamily, response);
+    }
+
+    @Override
+    public int getPhoneRatFamily() {
+        return mActivePhone.getPhoneRatFamily();
+    }
+
+    @Override
+    public void registerForPhoneRatFamilyChanged(Handler h, int what, Object obj) {
+        mActivePhone.registerForPhoneRatFamilyChanged(h, what, obj);
+    }
+
+    @Override
+    public void unregisterForPhoneRatFamilyChanged(Handler h) {
+        mActivePhone.unregisterForPhoneRatFamilyChanged(h);
+    }
+
 }
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 330679e..be26c8f 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -55,6 +55,7 @@ import android.telephony.SignalStrength;
 import android.telephony.SmsManager;
 import android.telephony.SmsMessage;
 import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.SparseArray;
 import android.view.Display;
@@ -289,6 +290,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
     // divide the response array without prior knowledge of the number of elements.
     protected int mQANElements = 4;
 
+    // MTK
+    // save the status of screen
+    private boolean isScreenOn = true;
+
     //***** Events
 
     static final int EVENT_SEND                 = 1;
@@ -2483,6 +2488,9 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     protected void sendScreenState(boolean on) {
+        // MTK
+        isScreenOn = on;
+
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
         rr.mParcel.writeInt(1);
         rr.mParcel.writeInt(on ? 1 : 0);
@@ -3387,12 +3395,19 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_RIL_CONNECTED: {
                 if (RILJ_LOGD) unsljLogRet(response, ret);
 
+                // Set ecc list before MO call
+                if  (TelephonyManager.getDefault().getMultiSimConfiguration() == TelephonyManager.MultiSimVariants.DSDA
+                        || mInstanceId == 0) {
+                    setEccList();
+                }
+
                 // Initial conditions
-                setRadioPower(false, null);
+                // setRadioPower(false, null);
                 setPreferredNetworkType(mPreferredNetworkType, null);
                 setCdmaSubscriptionSource(mCdmaSubscription, null);
                 setCellInfoListRate(Integer.MAX_VALUE, null);
                 notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                sendScreenState(isScreenOn);
                 break;
             }
             case RIL_UNSOL_CELL_INFO_LIST: {
@@ -4378,6 +4393,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
             case RIL_REQUEST_SIM_IO: return "SIM_IO";
             case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            /* M: SS part */
+            ///M: For query CNAP
+            case RIL_REQUEST_SEND_CNAP: return "SEND_CNAP";
+            /* M: SS part end */
             case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
             case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
             case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
@@ -4397,6 +4416,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
             case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
             case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
             case RIL_REQUEST_DTMF_START: return "DTMF_START";
             case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
             case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
@@ -4477,6 +4497,135 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
             case RIL_REQUEST_SIM_AUTHENTICATION: return "RIL_REQUEST_SIM_AUTHENTICATION";
             case RIL_REQUEST_SHUTDOWN: return "RIL_REQUEST_SHUTDOWN";
+            case RIL_REQUEST_SET_PHONE_RAT_FAMILY: return "RIL_REQUEST_SET_PHONE_RAT_FAMILY";
+            case RIL_REQUEST_GET_PHONE_RAT_FAMILY: return "RIL_REQUEST_GET_PHONE_RAT_FAMILY";
+
+            /* M: call control part start */
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /* M: call control part end */
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RETRIEVE_HELD_CALL: return "RIL_REQUEST_RETRIEVE_HELD_CALL";
+            /// @}
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+            //VoLTE
+            case RIL_REQUEST_SETUP_DEDICATE_DATA_CALL: return "RIL_REQUEST_SETUP_DEDICATE_DATA_CALL";
+            case RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL: return "RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL";
+            case RIL_REQUEST_MODIFY_DATA_CALL: return "RIL_REQUEST_MODIFY_DATA_CALL";
+            case RIL_REQUEST_ABORT_SETUP_DATA_CALL: return "RIL_REQUEST_ABORT_SETUP_DATA_CALL";
+            case RIL_REQUEST_PCSCF_DISCOVERY_PCO: return "RIL_REQUEST_PCSCF_DISCOVERY_PCO";
+            case RIL_REQUEST_CLEAR_DATA_BEARER: return "RIL_REQUEST_CLEAR_DATA_BEARER";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /* M: call control part start */
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /* M: call control part end */
+
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS: return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION: return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_REG_RESUME: return "RIL_REQUEST_SET_REG_RESUME";
+            case RIL_REQUEST_ENABLE_REG_PAUSE: return "RIL_REQUEST_ENABLE_REG_PAUSE";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            /* M: C2K part end */
             default: return "<unknown request>";
         }
     }
@@ -4534,9 +4683,85 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                     return "UNSOL_SRVCC_STATE_NOTIFY";
             case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
-            case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
-            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
-            case RIL_UNSOL_STK_SEND_SMS_RESULT: return "RIL_UNSOL_STK_SEND_SMS_RESULT";
+            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE: return "RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE";
+            /* M: call control part start */
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "UNSOL_CIPHER_INDICATION";
+            case RIL_UNSOL_CNAP: return "UNSOL_CNAP";
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /* M: call control part end */
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_INVALID_SIM: return "RIL_UNSOL_INVALID_SIM";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //VoLTE
+            case RIL_UNSOL_DEDICATE_BEARER_ACTIVATED: return "RIL_UNSOL_DEDICATE_BEARER_ACTIVATED";
+            case RIL_UNSOL_DEDICATE_BEARER_MODIFIED: return "RIL_UNSOL_DEDICATE_BEARER_MODIFIED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: return "RIL_UNSOL_MO_DATA_BARRING_INFO";
+            case RIL_UNSOL_SSAC_BARRING_INFO: return "RIL_UNSOL_SSAC_BARRING_INFO";
+            //MTK_TC1_FEATURE for LGE CSMCC_MO_CALL_MODIFIED {
+            case RIL_UNSOL_RESPONSE_MO_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_MO_CALL_STATE_CHANGED";
+            //}
+
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: return "RIL_UNSOL_CDMA_CALL_ACCEPTED";
+            case RIL_UNSOL_UTK_SESSION_END: return "RIL_UNSOL_UTK_SESSION_END";
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: return "RIL_UNSOL_UTK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: return "RIL_UNSOL_UTK_EVENT_NOTIFY";
+            case RIL_UNSOL_VIA_GPS_EVENT: return "RIL_UNSOL_VIA_GPS_EVENT";
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: return "RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE";
+            case RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE: return "RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE";
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: return "RIL_UNSOL_VIA_INVALID_SIM_DETECTED";
+            /* M: C2K part end */
             default: return "<unknown response>";
         }
     }
@@ -4878,6 +5103,13 @@ public class RIL extends BaseCommands implements CommandsInterface {
         send(rr);
     }
 
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result) {
+        // On generic RIL implementation we just ignore the MTK-specific parameters
+        setInitialAttachApn(apn, protocol, authType, username, password, result);
+    }
+
     public void setDataProfile(DataProfile[] dps, Message result) {
         if (RILJ_LOGD) riljLog("Set RIL_REQUEST_SET_DATA_PROFILE");
 
@@ -5098,4 +5330,291 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
         send(rr);
     }
+
+    // MTK additions
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_OPEN_ICC_APPLICATION, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(application);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", application = " + application);
+        send(rr);
+    }
+
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_ICC_APPLICATION_STATUS, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", session = " + sessionId);
+        send(rr);
+    }
+
+    @Override
+    public void iccIOForAppEx(int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, String aid, int channel , Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO_EX, result);
+
+        rr.mParcel.writeInt(command);
+        rr.mParcel.writeInt(fileid);
+        rr.mParcel.writeString(path);
+        rr.mParcel.writeInt(p1);
+        rr.mParcel.writeInt(p2);
+        rr.mParcel.writeInt(p3);
+        rr.mParcel.writeString(data);
+        rr.mParcel.writeString(pin2);
+        rr.mParcel.writeString(aid);
+        rr.mParcel.writeInt(channel);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: "
+                + requestToString(rr.mRequest)
+                + " 0x" + Integer.toHexString(command)
+                + " 0x" + Integer.toHexString(fileid) + " "
+                + " path: " + path + ","
+                + p1 + "," + p2 + "," + p3 + ",channel:" + channel
+                + " aid: " + aid);
+
+        send(rr);
+    }
+    //MTK-END Support Multi-Application
+
+    @Override
+    public void queryNetworkLock(int category, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("queryNetworkLock:" + category);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(category);
+
+        send(rr);
+    }
+
+    @Override
+    public void setNetworkLock(int catagory, int lockop, String password,
+                        String data_imsi, String gid1, String gid2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("setNetworkLock:" + catagory + ", " + lockop + ", " + password + ", " + data_imsi
+                + ", " + gid1 + ", " + gid2);
+
+        rr.mParcel.writeInt(6);
+        rr.mParcel.writeString(Integer.toString(catagory));
+        rr.mParcel.writeString(Integer.toString(lockop));
+        if (null != password) {
+            rr.mParcel.writeString(password);
+        } else {
+            rr.mParcel.writeString("");
+        }
+        rr.mParcel.writeString(data_imsi);
+        rr.mParcel.writeString(gid1);
+        rr.mParcel.writeString(gid2);
+
+        send(rr);
+    }
+
+    @Override
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                         String param2, Message response) {
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GENERAL_SIM_AUTH, response);
+
+        rr.mParcel.writeInt(sessionId);
+        rr.mParcel.writeInt(mode);
+
+        // Calcuate param1 length in byte length
+        if (param1 != null && param1.length() > 0) {
+            String length = Integer.toHexString(param1.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param1 : (length + param1)));
+        } else {
+            rr.mParcel.writeString(param1);
+        }
+
+        // Calcuate param2 length in byte length
+        if (param2 != null && param2.length() > 0) {
+            String length = Integer.toHexString(param2.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param2 : (length + param2)));
+        } else {
+            rr.mParcel.writeString(param2);
+        }
+
+        if (mode == 1) {
+            rr.mParcel.writeInt(tag);
+        }
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " +
+            "session = " + sessionId + ",mode = " + mode + ",tag = " + tag + ", "  + param1 + ", " + param2);
+
+        send(rr);
+    }
+
+    @Override
+    public void iccGetATR(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_GET_ATR, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW, result);
+
+        rr.mParcel.writeString(AID);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccOpenChannelWithSw: " + requestToString(rr.mRequest)
+                + " " + AID);
+
+        send(rr);
+    }
+
+    public void setTrm(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_TRM, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setResumeRegistration(int sessionId, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_REGISTRATION, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void queryModemType(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_MODEM_TYPE, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void storeModemType(int modemType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_STORE_MODEM_TYPE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(modemType);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    /*
+    public void
+    emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EMERGENCY_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+        rr.mParcel.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    */
+
+    public void setEccServiceCategory(int serviceCategory) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_SERVICE_CATEGORY, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(serviceCategory);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + serviceCategory);
+
+        send(rr);
+    }
+
+    private void setEccList() {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_LIST, null);
+        ArrayList<PhoneNumberUtils.EccEntry> eccList = PhoneNumberUtils.getEccList();
+
+        rr.mParcel.writeInt(eccList.size() * 3);
+        for (PhoneNumberUtils.EccEntry entry : eccList) {
+            rr.mParcel.writeString(entry.getEcc());
+            rr.mParcel.writeString(entry.getCategory());
+            String strCondition = entry.getCondition();
+            if (strCondition.equals(PhoneNumberUtils.EccEntry.ECC_FOR_MMI))
+                strCondition = PhoneNumberUtils.EccEntry.ECC_NO_SIM;
+            rr.mParcel.writeString(strCondition);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SCRI, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(forceRelease ? 1 : 0);
+
+        send(rr);
+    }
+
+    //[New R8 modem FD]
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FD_MODE, response);
+
+        //AT+EFD=<mode>[,<param1>[,<param2>]]
+        //mode=0:disable modem Fast Dormancy; mode=1:enable modem Fast Dormancy
+        //mode=3:inform modem the screen status; parameter1: screen on or off
+        //mode=2:Fast Dormancy inactivity timer; parameter1:timer_id; parameter2:timer_value
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        if (mode == 0 || mode == 1) {
+            rr.mParcel.writeInt(1);
+            rr.mParcel.writeInt(mode);
+        } else if (mode == 3) {
+            rr.mParcel.writeInt(2);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+        } else if (mode == 2) {
+            rr.mParcel.writeInt(3);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+            rr.mParcel.writeInt(parameter2);
+        }
+
+        send(rr);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index 179d4a1..7630879 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -189,6 +189,28 @@ public abstract class ServiceStateTracker extends Handler {
     protected static final int EVENT_IMS_STATE_CHANGED                 = 46;
     protected static final int EVENT_IMS_STATE_DONE                    = 47;
 
+    // MTK events
+    protected static final int EVENT_DATA_CONNECTION_DETACHED = 100;
+    protected static final int EVENT_INVALID_SIM_INFO = 101; //ALPS00248788
+    protected static final int EVENT_PS_NETWORK_STATE_CHANGED = 102;
+    protected static final int EVENT_IMEI_LOCK = 103; /* ALPS00296298 */
+    protected static final int EVENT_DISABLE_EMMRRS_STATUS = 104;
+    protected static final int EVENT_ENABLE_EMMRRS_STATUS = 105;
+    protected static final int EVENT_ICC_REFRESH = 106;
+    protected static final int EVENT_FEMTO_CELL_INFO = 107;
+    protected static final int EVENT_GET_CELL_INFO_LIST_BY_RATE = 108;
+    protected static final int EVENT_SET_IMS_ENABLED_DONE = 109;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE = 110;
+    protected static final int EVENT_IMS_DISABLED_URC = 111;
+    protected static final int EVENT_IMS_REGISTRATION_INFO = 112;
+
+    // MTK CDMA events
+    protected static final int EVENT_QUERY_NITZ_TIME        = 200;
+    protected static final int EVENT_GET_NITZ_TIME          = 201;
+    protected static final int EVENT_NETWORK_TYPE_CHANGED   = 202;
+    protected static final int EVENT_ETS_DEV_CHANGED        = 203;
+    protected static final int EVENT_SET_MDN_DONE           = 204;
+
     protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
 
     /**
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 95f805e..a806374 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -225,7 +225,7 @@ public class SubscriptionInfoUpdater extends Handler {
                         mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
                     }
                 } else {
-                    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
+                    mIccId[slotId] = mFh[slotId].needsFakeIccid() ? IccConstants.FAKE_ICCID : ICCID_STRING_FOR_NO_SIM;
                     logd("Query IccId fail: " + ar.exception);
                 }
                 logd("mIccId[" + slotId + "] = " + mIccId[slotId]);
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaSubscriptionSourceManager.java b/src/java/com/android/internal/telephony/cdma/CdmaSubscriptionSourceManager.java
index f7b8936..059d24d 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaSubscriptionSourceManager.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaSubscriptionSourceManager.java
@@ -44,7 +44,7 @@ public class CdmaSubscriptionSourceManager extends Handler {
     public static final int SUBSCRIPTION_SOURCE_UNKNOWN = -1;
     public static final int SUBSCRIPTION_FROM_RUIM      = 0; /* CDMA subscription from RUIM */
     public static final int SUBSCRIPTION_FROM_NV        = 1; /* CDMA subscription from NV */
-    public static final int PREFERRED_CDMA_SUBSCRIPTION = SUBSCRIPTION_FROM_NV;
+    public static final int PREFERRED_CDMA_SUBSCRIPTION = SUBSCRIPTION_FROM_RUIM;
 
     private static CdmaSubscriptionSourceManager sInstance;
     private static final Object sReferenceCountMonitor = new Object();
diff --git a/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java b/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
index cf2c57c..c9963c7 100755
--- a/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
+++ b/src/java/com/android/internal/telephony/dataconnection/ApnSetting.java
@@ -111,23 +111,23 @@ public class ApnSetting {
             int profileId, boolean modemCognitive, int maxConns, int waitTime, int maxConnsTime,
             int mtu, String mvnoType, String mvnoMatchData) {
         this.id = id;
-        this.numeric = numeric;
-        this.carrier = carrier;
-        this.apn = apn;
-        this.proxy = proxy;
-        this.port = port;
-        this.mmsc = mmsc;
-        this.mmsProxy = mmsProxy;
-        this.mmsPort = mmsPort;
-        this.user = user;
-        this.password = password;
+        this.numeric = numeric == null ? "" : numeric;
+        this.carrier = carrier == null ? "" : carrier;
+        this.apn = apn == null ? "" : apn;
+        this.proxy = proxy == null ? "" : proxy;
+        this.port = port == null ? "" : port;
+        this.mmsc = mmsc == null ? "" : mmsc;
+        this.mmsProxy = mmsProxy == null ? "" : mmsProxy;
+        this.mmsPort = mmsPort == null ? "" : mmsPort;
+        this.user = user == null ? "" : user;
+        this.password = password == null ? "" : password;
         this.authType = authType;
         this.types = new String[types.length];
         for (int i = 0; i < types.length; i++) {
-            this.types[i] = types[i].toLowerCase(Locale.ROOT);
+            this.types[i] = types[i] == null ? "" : types[i].toLowerCase(Locale.ROOT);
         }
-        this.protocol = protocol;
-        this.roamingProtocol = roamingProtocol;
+        this.protocol = protocol == null ? "" : protocol;
+        this.roamingProtocol = roamingProtocol == null ? "" : roamingProtocol;
         this.carrierEnabled = carrierEnabled;
         this.bearer = bearer;
         this.profileId = profileId;
@@ -136,8 +136,8 @@ public class ApnSetting {
         this.waitTime = waitTime;
         this.maxConnsTime = maxConnsTime;
         this.mtu = mtu;
-        this.mvnoType = mvnoType;
-        this.mvnoMatchData = mvnoMatchData;
+        this.mvnoType = mvnoType == null ? "" : mvnoType;
+        this.mvnoMatchData = mvnoMatchData == null ? "" : mvnoMatchData;
 
     }
 
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 91ac2c0..9e271f6 100755
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -88,6 +88,9 @@ import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
 
+// MTK
+import com.mediatek.internal.telephony.dataconnection.FdManager;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -185,6 +188,9 @@ public final class DcTracker extends DcTrackerBase {
     private boolean mDeregistrationAlarmState = false;
     private PendingIntent mImsDeregistrationDelayIntent = null;
 
+    // MTK
+    protected FdManager mFdMgr;
+
     /* IWLAN and WWAN co-exist flag */
     private boolean mWwanIwlanCoexistFlag = false;
 
@@ -254,6 +260,9 @@ public final class DcTracker extends DcTrackerBase {
             mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
         }
 
+        // MTK Fast Dormancy
+        mFdMgr = FdManager.getInstance(p);
+
         // Add Emergency APN to APN setting list by default to support EPDN in sim absent cases
         initEmergencyApnSetting();
         addEmergencyApnSetting();
@@ -869,6 +878,7 @@ public final class DcTracker extends DcTrackerBase {
         IccRecords r = mIccRecords.get();
         boolean recordsLoaded = false;
         if (r != null) {
+            log("isDataAllowed mIccRecords=IccRecords {" + r.toString() + "}");
             recordsLoaded = r.getRecordsLoaded();
             if (DBG) log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
         }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index c17a9ce..806c719 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -1806,7 +1806,7 @@ public abstract class DcTrackerBase extends Handler {
         ApnSetting firstApnSetting = null;
         String operator = (r != null) ? r.getOperatorNumeric(): "";
 
-        log("setInitialApn: E mPreferredApn=" + mPreferredApn);
+        log("setInitialApn: E operator=" + operator + " mPreferredApn=" + mPreferredApn);
 
         if (apnList != null && !apnList.isEmpty()) {
             firstApnSetting = apnList.get(0);
@@ -1858,7 +1858,9 @@ public abstract class DcTrackerBase extends Handler {
 
             mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn,
                     initialAttachApnSetting.protocol, initialAttachApnSetting.authType,
-                    initialAttachApnSetting.user, initialAttachApnSetting.password, null);
+                    initialAttachApnSetting.user, initialAttachApnSetting.password,
+                    operator, initialAttachApnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS),
+                    null);
         }
     }
 
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 1b8ef2d..723c223 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -147,6 +147,8 @@ public class GSMPhone extends PhoneBase {
         }
     }
 
+    public boolean mIsNetworkInitiatedUssd = false;
+
     // Constructors
 
     public
@@ -977,6 +979,9 @@ public class GSMPhone extends PhoneBase {
     @Override
     public void sendUssdResponse(String ussdMessge) {
         GsmMmiCode mmi = GsmMmiCode.newFromUssdUserInput(ussdMessge, this, mUiccApplication.get());
+        /* M: SS part */
+        Rlog.d(LOG_TAG, "[sendUssdResponse]mPendingMMIs.add(mmi) + " + mmi);
+        /* M: SS part end */
         mPendingMMIs.add(mmi);
         mMmiRegistrants.notifyRegistrants(new AsyncResult(null, mmi, null));
         mmi.sendUssd(ussdMessge);
@@ -1470,6 +1475,10 @@ public class GSMPhone extends PhoneBase {
          * The exception is cancellation of an incoming USSD-REQUEST, which is
          * not on the list.
          */
+
+        /* M: SS part */
+        Rlog.d(LOG_TAG, "mPendingMMIs.remove(mmi) - " + mmi);
+        /* M: SS part end */
         if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest() || mmi.isSsInfo()) {
             mMmiCompleteRegistrants.notifyRegistrants(
                 new AsyncResult(null, mmi, null));
@@ -1477,6 +1486,27 @@ public class GSMPhone extends PhoneBase {
     }
 
     /**
+     * Removes the given MMI from the pending list and notifies
+     * registrants that it is complete.
+     * @param mmi MMI that is done
+     * @param obj User object to deliver to application
+     */
+    public void onMMIDone(GsmMmiCode mmi, Object obj) {
+        /* Only notify complete if it's on the pending list.
+         * Otherwise, it's already been handled (eg, previously canceled).
+         * The exception is cancellation of an incoming USSD-REQUEST, which is
+         * not on the list.
+         */
+        /* M: SS part */
+        Rlog.d(LOG_TAG, "mPendingMMIs.remove(mmi) - " + mmi);
+        /* M: SS part end */
+        if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest() || mmi.isSsInfo()) {
+            mMmiCompleteRegistrants.notifyRegistrants(
+                    new AsyncResult(obj, mmi, null));
+        }
+    }
+
+    /**
      * Used to check if Call Forwarding status is present on sim card. If not, a message is
      * sent so we can check if the CF status is stored as a Shared Preference.
      */
@@ -1506,34 +1536,55 @@ public class GSMPhone extends PhoneBase {
         boolean isUssdError;
         boolean isUssdRequest;
         boolean isUssdRelease;
+        boolean isUssdhandleByStk;
+
+        Rlog.d(LOG_TAG, "onIncomingUSSD(): mIsNetworkInitiatedUssd = " + mIsNetworkInitiatedUssd);
 
         isUssdRequest
             = (ussdMode == CommandsInterface.USSD_MODE_REQUEST);
-
+        /* M: SS part */
+        //MTK-START [mtk04070][111118][ALPS00093395]MTK modified
         isUssdError
-            = (ussdMode != CommandsInterface.USSD_MODE_NOTIFY
-                && ussdMode != CommandsInterface.USSD_MODE_REQUEST);
+            = ((ussdMode == CommandsInterface.USSD_OPERATION_NOT_SUPPORTED)
+               || (ussdMode == CommandsInterface.USSD_NETWORK_TIMEOUT));
+        //MTK-END [mtk04070][111118][ALPS00093395]MTK modified
+
+        isUssdhandleByStk
+            = (ussdMode == CommandsInterface.USSD_HANDLED_BY_STK);
+        /* M: SS part end */
 
         isUssdRelease = (ussdMode == CommandsInterface.USSD_MODE_NW_RELEASE);
+        Rlog.d(LOG_TAG, "ussdMode= " + ussdMode);
+        Rlog.d(LOG_TAG, "isUssdRequest=" + isUssdRequest + " isUssdError= " + isUssdError);
 
         // See comments in GsmMmiCode.java
         // USSD requests aren't finished until one
         // of these two events happen
         GsmMmiCode found = null;
+        Rlog.d(LOG_TAG, "USSD:mPendingMMIs= " + mPendingMMIs + " size=" + mPendingMMIs.size());
         for (int i = 0, s = mPendingMMIs.size() ; i < s; i++) {
+            Rlog.d(LOG_TAG, "i= " + i + " isPending=" + mPendingMMIs.get(i).isPendingUSSD());
             if(mPendingMMIs.get(i).isPendingUSSD()) {
                 found = mPendingMMIs.get(i);
+                Rlog.d(LOG_TAG, "found = " + found);
                 break;
             }
         }
 
         if (found != null) {
             // Complete pending USSD
-
-            if (isUssdRelease) {
+            /* M: SS part */
+            //For ALPS01471897
+            Rlog.d(LOG_TAG, "setUserInitiatedMMI  TRUE");
+            found.setUserInitiatedMMI(true);
+            /* M: SS part end */
+            if (isUssdRelease && mIsNetworkInitiatedUssd) {
+                Rlog.d(LOG_TAG, "onIncomingUSSD(): USSD_MODE_NW_RELEASE.");
                 found.onUssdRelease();
             } else if (isUssdError) {
                 found.onUssdFinishedError();
+            } else if (isUssdhandleByStk) {
+                found.onUssdStkHandling(ussdMessage, isUssdRequest);
             } else {
                 found.onUssdFinished(ussdMessage, isUssdRequest);
             }
@@ -1542,6 +1593,13 @@ public class GSMPhone extends PhoneBase {
 
             // ignore everything that isnt a Notify or a Request
             // also, discard if there is no message to present
+
+            /* M: SS part */
+            //For ALPS01471897
+            Rlog.d(LOG_TAG, "The default value of UserInitiatedMMI is FALSE");
+            mIsNetworkInitiatedUssd = true;
+            Rlog.d(LOG_TAG, "onIncomingUSSD(): Network Initialized USSD");
+
             if (!isUssdError && ussdMessage != null) {
                 GsmMmiCode mmi;
                 mmi = GsmMmiCode.newNetworkInitiatedUssd(ussdMessage,
@@ -1549,8 +1607,25 @@ public class GSMPhone extends PhoneBase {
                                                    GSMPhone.this,
                                                    mUiccApplication.get());
                 onNetworkInitiatedUssd(mmi);
+
+            //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+            } else if (isUssdError) {
+                GsmMmiCode mmi;
+                mmi = GsmMmiCode.newNetworkInitiatedUssdError(ussdMessage,
+                                                   isUssdRequest,
+                                                   GSMPhone.this,
+                                                   mUiccApplication.get());
+                onNetworkInitiatedUssd(mmi);
+            //MTK-END [mtk04070][111118][ALPS00093395]MTK added
             }
+            /* M: SS part end */
+        }
+
+        /* M: SS part */
+        if (isUssdRelease || isUssdError) {
+            mIsNetworkInitiatedUssd = false;
         }
+        /* M: SS part end */
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
index c79c9f0..2db5c34 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
@@ -116,6 +116,12 @@ public final class GsmMmiCode extends Handler implements MmiCode {
     static final int EVENT_SET_CFF_COMPLETE     = 6;
     static final int EVENT_USSD_CANCEL_COMPLETE = 7;
 
+    /* M: SS part */
+    /// M: [mtk04070][111125][ALPS00093395]MTK added. @{
+    static final String USSD_HANDLED_BY_STK = "stk";
+    /// @}
+    /* M: SS part end */
+
     //***** Instance Variables
 
     GSMPhone mPhone;
@@ -140,6 +146,9 @@ public final class GsmMmiCode extends Handler implements MmiCode {
     CharSequence mMessage;
     private boolean mIsSsInfo = false;
 
+    //For ALPS01471897
+    private boolean mUserInitiatedMMI = false;
+    //end
 
     //***** Class Variables
 
@@ -573,10 +582,21 @@ public final class GsmMmiCode extends Handler implements MmiCode {
         return ((Phone) mPhone);
     }
 
+    //For ALPS01471897
+    public void setUserInitiatedMMI(boolean userinit)
+    {
+       mUserInitiatedMMI = userinit;
+    }
+
+    public boolean getUserInitiatedMMI() {
+       return mUserInitiatedMMI;
+    }
+
     // inherited javadoc suffices
     @Override
     public void
     cancel() {
+        mPhone.mIsNetworkInitiatedUssd = false;
         // Complete or failed cannot be cancelled
         if (mState == State.COMPLETE || mState == State.FAILED) {
             return;
@@ -779,6 +799,36 @@ public final class GsmMmiCode extends Handler implements MmiCode {
         return mIsSsInfo;
     }
 
+    public static boolean isUssdNumber(String dialString, GSMPhone dialPhone, UiccCardApplication iccApp) {
+        String newDialString = PhoneNumberUtils.stripSeparators(dialString);
+        String networkPortion = PhoneNumberUtils.extractNetworkPortionAlt(newDialString);
+
+        GsmMmiCode mmi = GsmMmiCode.newFromDialString(networkPortion, dialPhone, iccApp);
+        if (mmi == null || mmi.isTemporaryModeCLIR()) {
+            return false;
+        }
+        else {
+            if (mmi.isShortCode()) {
+                return true;
+            } else if (mmi.mDialingNumber != null) {
+                return true;
+            } else if (mmi.mSc != null
+                    && (mmi.mSc.equals(SC_CLIP)
+                    || mmi.mSc.equals(SC_CLIR)
+                    || isServiceCodeCallForwarding(mmi.mSc)
+                    || isServiceCodeCallBarring(mmi.mSc)
+                    || mmi.mSc.equals(SC_PWD)
+                    || mmi.mSc.equals(SC_WAIT)
+                    || mmi.isPinPukCommand()
+                    )) {
+                return false;
+            } else if (mmi.mPoundString != null) {
+                return true;
+            }
+            return false;
+        }
+    }
+
     /** Process a MMI code or short code...anything that isn't a dialing number */
     void
     processCode () {
@@ -789,7 +839,13 @@ public final class GsmMmiCode extends Handler implements MmiCode {
                 sendUssd(mDialingNumber);
             } else if (mDialingNumber != null) {
                 // We should have no dialing numbers here
-                throw new RuntimeException ("Invalid or Unsupported MMI Code");
+
+                /* M: SS part */
+                /// M: [mtk04070][111125][ALPS00093395]MTK modified. @{
+                Rlog.w(LOG_TAG, "Special USSD Support:" + mPoundString + mDialingNumber);
+                sendUssd(mPoundString + mDialingNumber);
+                //throw new RuntimeException ("Invalid or Unsupported MMI Code");
+                /// @}
             } else if (mSc != null && mSc.equals(SC_CLIP)) {
                 Rlog.d(LOG_TAG, "is CLIP");
                 if (isInterrogate()) {
@@ -1007,7 +1063,10 @@ public final class GsmMmiCode extends Handler implements MmiCode {
     void
     onUssdFinished(String ussdMessage, boolean isUssdRequest) {
         if (mState == State.PENDING) {
-            if (ussdMessage == null) {
+            /* M: SS part */
+            /// M: [mtk04070][111125][ALPS00093395]Check the length of ussdMessage.
+            if (ussdMessage == null || ussdMessage.length() == 0) {
+            /* M: SS part end */
                 mMessage = mContext.getText(com.android.internal.R.string.mmiComplete);
             } else {
                 mMessage = ussdMessage;
@@ -1017,11 +1076,28 @@ public final class GsmMmiCode extends Handler implements MmiCode {
             if (!isUssdRequest) {
                 mState = State.COMPLETE;
             }
-
             mPhone.onMMIDone(this);
         }
     }
 
+    void
+    onUssdStkHandling(String ussdMessage, boolean isUssdRequest) {
+        if (mState == State.PENDING) {
+            if (ussdMessage == null || ussdMessage.length() == 0) {
+                mMessage = mContext.getText(com.android.internal.R.string.mmiComplete);
+            } else {
+                mMessage = ussdMessage;
+            }
+            mIsUssdRequest = isUssdRequest;
+            // If it's a request, leave it PENDING so that it's cancelable.
+            if (!isUssdRequest) {
+                mState = State.COMPLETE;
+            }
+            String userObjStringStk = USSD_HANDLED_BY_STK;
+            mPhone.onMMIDone(this, (Object) userObjStringStk);
+        }
+    }
+
     /**
      * Called from GSMPhone
      *
@@ -1033,11 +1109,11 @@ public final class GsmMmiCode extends Handler implements MmiCode {
         if (mState == State.PENDING) {
             mState = State.FAILED;
             mMessage = mContext.getText(com.android.internal.R.string.mmiError);
-
             mPhone.onMMIDone(this);
         }
     }
 
+
     /**
      * Called from GSMPhone
      *
@@ -1057,6 +1133,7 @@ public final class GsmMmiCode extends Handler implements MmiCode {
         }
     }
 
+
     void sendUssd(String ussdMessage) {
         // Treat this as a USSD string
         mIsPendingUSSD = true;
@@ -1616,4 +1693,21 @@ public final class GsmMmiCode extends Handler implements MmiCode {
         sb.append("}");
         return sb.toString();
     }
+
+    /* M: SS part */
+    /// M: [mtk04070][111125][ALPS00093395]MTK proprietary methods. @{
+    static GsmMmiCode
+    newNetworkInitiatedUssdError(String ussdMessage,
+                                boolean isUssdRequest, GSMPhone phone, UiccCardApplication app) {
+        GsmMmiCode ret;
+
+        ret = new GsmMmiCode(phone, app);
+
+        ret.mMessage = ret.mContext.getText(com.android.internal.R.string.mmiError);
+        ret.mIsUssdRequest = isUssdRequest;
+
+        ret.mState = State.FAILED;
+
+        return ret;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 117d054..f2e3d18 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -224,6 +224,20 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         mCi.setOnNITZTime(this, EVENT_NITZ_TIME, null);
         mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
 
+        // MTK
+        mCi.registerForPsNetworkStateChanged(this, EVENT_PS_NETWORK_STATE_CHANGED, null);
+        // mCi.setInvalidSimInfo(this, EVENT_INVALID_SIM_INFO, null); //ALPS00248788
+
+        // mCi.registerForIccRefresh(this, EVENT_ICC_REFRESH, null);
+        /*
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1")) {
+            mCi.registerForImsDisable(this, EVENT_IMS_DISABLED_URC, null);
+            mCi.registerForImsRegistrationInfo(this, EVENT_IMS_REGISTRATION_INFO, null);
+        }
+        if (SystemProperties.get("ro.mtk_femto_cell_support").equals("1"))
+            mCi.registerForFemtoCellInfo(this, EVENT_FEMTO_CELL_INFO, null);
+        */
+
         // system setting property AIRPLANE_MODE_ON is set in Settings.
         int airplaneMode = Settings.Global.getInt(
                 phone.getContext().getContentResolver(),
@@ -267,6 +281,11 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         mCr.unregisterContentObserver(mAutoTimeObserver);
         mCr.unregisterContentObserver(mAutoTimeZoneObserver);
         mPhone.getContext().unregisterReceiver(mIntentReceiver);
+
+        // MTK
+        // mCi.unregisterForIccRefresh(this);
+        mCi.unregisterForPsNetworkStateChanged(this);
+
         super.dispose();
     }
 
@@ -327,6 +346,10 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                 pollState();
                 break;
 
+            case EVENT_PS_NETWORK_STATE_CHANGED:
+                pollState();
+                break;
+
             case EVENT_GET_SIGNAL_STRENGTH:
                 // This callback is called when signal strength is polled
                 // all by itself
@@ -720,6 +743,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                                     psc = Integer.parseInt(states[14], 16);
                                 }
                             }
+
+                            log("EVENT_POLL_STATE_REGISTRATION mSS getRilVoiceRadioTechnology:" + mSS.getRilVoiceRadioTechnology() +
+                                    ", regState:" + regState +
+                                    ", NewSS RilVoiceRadioTechnology:" + mNewSS.getRilVoiceRadioTechnology() +
+                                    ", lac:" + lac +
+                                    ", cid:" + cid);
                         } catch (NumberFormatException ex) {
                             loge("error parsing RegistrationState: " + ex);
                         }
@@ -783,12 +812,18 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             if (states.length >= 4 && states[3] != null) {
                                 type = Integer.parseInt(states[3]);
                             }
-                            if ((states.length >= 5 ) &&
+                            if (states.length >= 5 && states[4] != null) {
+                                log("<cell_data_speed_support> " + states[4]);
+                            }
+                            if (states.length >= 6 && states[5] != null) {
+                                log("<max_data_bearer_capability> " + states[5]);
+                            }
+                            if ((states.length >= 7) &&
                                     (regState == ServiceState.RIL_REG_STATE_DENIED)) {
-                                mNewReasonDataDenied = Integer.parseInt(states[4]);
+                                mNewReasonDataDenied = Integer.parseInt(states[6]);
                             }
-                            if (states.length >= 6) {
-                                mNewMaxDataCalls = Integer.parseInt(states[5]);
+                            if (states.length >= 8) {
+                                mNewMaxDataCalls = Integer.parseInt(states[7]);
                             }
                         } catch (NumberFormatException ex) {
                             loge("error parsing GprsRegistrationState: " + ex);
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index b4c70d9..ac63ebf 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -104,6 +104,14 @@ public class ImsPhone extends ImsPhoneBase {
 
     public static final String CS_FALLBACK = "cs_fallback";
 
+    /// M: @{
+    /**
+     * Used as the message in CallStateException.
+     * We don't support dialing a USSD number while there is an existing IMS call.
+     */
+    public static final String USSD_DURING_IMS_INCALL = "ussd_during_ims_incall";
+    /// @}
+
     static final int RESTART_ECM_TIMER = 0; // restart Ecm timer
     static final int CANCEL_ECM_TIMER = 1; // cancel Ecm timer
 
@@ -532,6 +540,16 @@ public class ImsPhone extends ImsPhoneBase {
         return result;
     }
 
+    /// M: for USSD over IMS workaround. @{
+    private boolean isUssdDuringInCall(ImsPhoneMmiCode mmi) {
+        if (mmi == null || !mmi.isUssdNumber()) {
+            return false;
+        }
+
+        return isInCall();
+    }
+    /// @}
+
     boolean isInCall() {
         ImsPhoneCall.State foregroundCallState = getForegroundCall().getState();
         ImsPhoneCall.State backgroundCallState = getBackgroundCall().getState();
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
index 755e87c..9226a8b 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
@@ -586,5 +586,52 @@ class ImsPhoneCommandInterface extends BaseCommands implements CommandsInterface
     public void requestShutdown(Message result) {
     }
 
+    // MTK
+
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result) {
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
index 18d94ad..2a9191c 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
@@ -1797,4 +1797,25 @@ public final class ImsPhoneMmiCode extends Handler implements MmiCode {
         sb.append("}");
         return sb.toString();
     }
+
+    /// M: for SS part. @{
+    /**
+     Utility function to check if it is USSD number.
+     @return boolean true if this an USSD number.
+    */
+    public boolean isUssdNumber() {
+        if (isTemporaryModeCLIR()) {
+            return false;
+        } else {
+            if (isShortCode()) {
+                return true;
+            } else if (mDialingNumber != null) {
+                return true;
+            } else if (mPoundString != null) {
+                return true;
+            }
+            return false;
+        }
+    }
+    /// @}
 }
diff --git a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 65c37ba..f14bf69 100644
--- a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -589,5 +589,52 @@ class SipCommandInterface extends BaseCommands implements CommandsInterface {
     public void requestShutdown(Message result) {
     }
 
+    // MTK
+
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result) {
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 0181430..afddcdc 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1776,5 +1776,38 @@ public final class SimulatedCommands extends BaseCommands
         setRadioState(RadioState.RADIO_UNAVAILABLE);
     }
 
+    // MTK additions
+
+    @Override
+    public void iccGetATR(Message response) {
+        unimplemented(response);
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message response) {
+        unimplemented(response);
+    }
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, String operatorNumeric, boolean canHandleIms, Message result) {
+    }
+
     public boolean needsOldRilFeature(String feature) { return false; }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index c4c55c6..ed7bab6 100755
--- a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -54,6 +54,8 @@ import com.android.internal.telephony.uicc.IccCardStatus.PinState;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.telephony.uicc.RuimRecords;
 
+import com.mediatek.internal.telephony.uicc.IccCardProxyEx;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
@@ -103,6 +105,21 @@ public class IccCardProxy extends Handler implements IccCard {
     private static final int EVENT_SUBSCRIPTION_DEACTIVATED = 502;
     private static final int EVENT_CARRIER_PRIVILIGES_LOADED = 503;
 
+    // MTK
+    private static final int EVENT_ICC_RECOVERY = 100;
+    private static final int EVENT_ICC_FDN_CHANGED = 101;
+    private static final int EVENT_NOT_AVAILABLE = 102;
+
+    private static final String ICCID_STRING_FOR_NO_SIM = "N/A";
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    private static final String COMMON_SLOT_PROPERTY = "";
+
     private Integer mPhoneId = null;
 
     private final Object mLock = new Object();
@@ -113,6 +130,10 @@ public class IccCardProxy extends Handler implements IccCard {
     private RegistrantList mPinLockedRegistrants = new RegistrantList();
     private RegistrantList mPersoLockedRegistrants = new RegistrantList();
 
+    // MTK
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
     private int mCurrentAppType = UiccController.APP_FAM_3GPP; //default to 3gpp?
     private UiccController mUiccController = null;
     private UiccCard mUiccCard = null;
@@ -127,6 +148,9 @@ public class IccCardProxy extends Handler implements IccCard {
     private boolean mIsCardStatusAvailable = false;
     private PersoSubState mPersoSubState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
 
+    // MTK
+    private IccCardProxyEx mIccCardProxyEx;
+
     // Sim State events may be broadcasted before the siminfo table update has been
     // completed. Due to this such events may be broadcasted with dummy subId for a
     // particular slotId. Therefore, setExternalState once the siminfo table has been updated.
@@ -145,6 +169,7 @@ public class IccCardProxy extends Handler implements IccCard {
         mContext = context;
         mCi = ci;
         mPhoneId = phoneId;
+        mIccCardProxyEx = new IccCardProxyEx(context, ci);
         mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(context,
                 ci, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
         mUiccController = UiccController.getInstance();
@@ -168,6 +193,7 @@ public class IccCardProxy extends Handler implements IccCard {
             mCi.unregisterForOn(this);
             mCi.unregisterForOffOrNotAvailable(this);
             mCdmaSSM.dispose(this);
+            mIccCardProxyEx.dispose();
         }
     }
 
@@ -288,6 +314,10 @@ public class IccCardProxy extends Handler implements IccCard {
                     setExternalState(State.NOT_READY);
                 }
                 break;
+            case EVENT_NOT_AVAILABLE:
+                log("handleMessage (EVENT_NOT_AVAILABLE)");
+                setExternalState(State.NOT_READY);
+                break;
             case EVENT_RADIO_ON:
                 mRadioOn = true;
                 if (!mInitialized) {
@@ -302,9 +332,29 @@ public class IccCardProxy extends Handler implements IccCard {
             case EVENT_ICC_CHANGED:
                 mIsCardStatusAvailable = true;
                 if (mInitialized) {
+                    AsyncResult ar = (AsyncResult) msg.obj;
+                    int index = mPhoneId;
+
+                    if (ar != null && ar.result instanceof Integer) {
+                        index = ((Integer) ar.result).intValue();
+                        log("handleMessage (EVENT_ICC_CHANGED), index=" + index + " mPhoneId=" + mPhoneId);
+                    } else {
+                        log("handleMessage (EVENT_ICC_CHANGED), come from myself, mPhoneId=" + mPhoneId);
+                    }
+
                     updateIccAvailability();
                 }
                 break;
+            case EVENT_ICC_RECOVERY: {
+                AsyncResult ar = (AsyncResult) msg.obj;
+                Integer index = (Integer) ar.result;
+                log("handleMessage (EVENT_ICC_RECOVERY) , index = " + index);
+                // if (index == mSlotId) {
+                if (DBG) log("mRecoveryRegistrants notify");
+                mRecoveryRegistrants.notifyRegistrants();
+                // }
+                break;
+            }
             case EVENT_ICC_ABSENT:
                 mAbsentRegistrants.notifyRegistrants();
                 setExternalState(State.ABSENT);
@@ -386,6 +436,10 @@ public class IccCardProxy extends Handler implements IccCard {
                 }
                 break;
 
+            case EVENT_ICC_FDN_CHANGED:
+                mFdnChangedRegistrants.notifyRegistrants();
+                break;
+
             case EVENT_CARRIER_PRIVILIGES_LOADED:
                 log("EVENT_CARRIER_PRIVILEGES_LOADED");
                 if (mUiccCard != null) {
@@ -490,12 +544,19 @@ public class IccCardProxy extends Handler implements IccCard {
                 setExternalState(State.PUK_REQUIRED);
                 break;
             case APPSTATE_SUBSCRIPTION_PERSO:
+                /*  [mtk02772][ALPS00437082]
+                    mediatek platform will set network locked for all of subState (5 type of network locked)
+                */
+                setExternalState(State.PERSO_LOCKED);
+
+                /*
                 if (mUiccApplication.isPersoLocked()) {
                     mPersoSubState = mUiccApplication.getPersoSubState();
                     setExternalState(State.PERSO_LOCKED);
                 } else {
                     setExternalState(State.UNKNOWN);
                 }
+                */
                 break;
             case APPSTATE_READY:
                 setExternalState(State.READY);
@@ -655,7 +716,15 @@ public class IccCardProxy extends Handler implements IccCard {
         switch (state) {
             case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
             case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
-            case PERSO_LOCKED: return IccCardConstants.INTENT_VALUE_LOCKED_PERSO;
+            case PERSO_LOCKED:  // return IccCardConstants.INTENT_VALUE_LOCKED_PERSO;
+                switch (mUiccApplication.getPersoSubState()) {
+                    case PERSOSUBSTATE_SIM_NETWORK: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                    case PERSOSUBSTATE_SIM_NETWORK_SUBSET: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                    case PERSOSUBSTATE_SIM_CORPORATE: return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                    case PERSOSUBSTATE_SIM_SERVICE_PROVIDER: return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                    case PERSOSUBSTATE_SIM_SIM: return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                    default: return null;
+                }
             case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
             case CARD_IO_ERROR: return IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR;
             default: return null;
@@ -990,4 +1059,142 @@ public class IccCardProxy extends Handler implements IccCard {
 
         pw.flush();
     }
+
+    // MTK additions
+
+    // Added by M begin
+    /**
+     * Query the SIM ME Lock type required to unlock.
+     *
+     * @return SIM ME Lock type
+     */
+    public PersoSubState getNetworkPersoType() {
+        if (mUiccApplication != null) {
+            return mUiccApplication.getPersoSubState();
+        }
+        return PersoSubState.PERSOSUBSTATE_UNKNOWN;
+    }
+
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    @Override
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  " + category);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.queryIccNetworkLock(category, onComplete);
+            } else if (onComplete != null) {
+                Exception e = new RuntimeException("ICC card is absent.");
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    @Override
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = " + category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.setIccNetworkLockEnabled(category, lockop, password, data_imsi, gid1, gid2, onComplete);
+            } else if (onComplete != null) {
+                Exception e = new RuntimeException("ICC card is absent.");
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Used by SIM ME lock related enhancement feature(Modem SML change feature).
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent) {
+        if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
+        synchronized (mLock) {
+            mUiccController.repollIccStateForModemSmlChangeFeatrue(mPhoneId, needIntent);
+        }
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                              int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+            mUiccCard.exchangeSimIo(fileID, command, p1, p2, p3, pathID, data, pin2, onComplete);
+        }
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+            mUiccCard.iccGetAtr(onComplete);
+        }
+    }
+
+    public void openLogicalChannelWithSw(String AID, Message onComplete) {
+        if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+            mUiccCard.iccOpenChannelWithSw(AID, onComplete);
+        }
+    }
+
+    // retrun usim property or use uicccardapplication app type
+    public String getIccCardType() {
+        if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+            return mUiccCard.getIccCardType();
+        }
+        return "";
+    }
+
+    public void registerForRecovery(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+
+            mRecoveryRegistrants.add(r);
+
+            if (getState() == State.READY) {
+                r.notifyRegistrant();
+            }
+        }
+    }
+
+    public void unregisterForRecovery(Handler h) {
+        synchronized (mLock) {
+            mRecoveryRegistrants.remove(h);
+        }
+    }
+
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    @Override
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            synchronized (mLock) {
+                Registrant r = new Registrant(h, what, obj);
+
+                mFdnChangedRegistrants.add(r);
+
+                if (getIccFdnEnabled()) {
+                    r.notifyRegistrant();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
+
+    // Added by M end
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccConstants.java b/src/java/com/android/internal/telephony/uicc/IccConstants.java
index facc918..4b5b48f 100644
--- a/src/java/com/android/internal/telephony/uicc/IccConstants.java
+++ b/src/java/com/android/internal/telephony/uicc/IccConstants.java
@@ -112,4 +112,34 @@ public interface IccConstants {
 
     //UICC access
     static final String DF_ADF = "7FFF";
+
+    //CM-Specific : Fake ICCID
+    static final String FAKE_ICCID = "00000000000001";
+
+    // MTK
+    static final int EF_ECC = 0x6FB7;
+
+    // USIM SIM file ids from TS 31.102
+    static final int EF_PSISMSC = 0x6FE5;
+    static final int EF_GBABP = 0x6fD6;
+    // [ALPS01206315] Support EF_SMSP (EF ids from 11.11/31.102)
+    static final int EF_SMSP = 0x6F42;
+    static final int EF_ELP = 0x2F05;
+    // ALPS00302702 RAT balancing
+    static public final int EF_RAT = 0x4F36; // ADF(USIM)/7F66/5F30/4F36
+    static final String DF_USIM = "7FFF";
+    static final int EF_GID2 = 0x6F3F;
+
+    // MTK-START [ALPS00092673] Orange feature merge back added by mtk80589 in 2011.11.15
+    /*
+      Detail description:
+      This feature provides a interface to get menu title string from EF_SUME
+    */
+    // SET UP MENU ELEMENTS
+    static final int EF_SUME = 0x6F54;
+    // MTK-END [ALPS00092673] Orange feature merge back added by mtk80589 in 2011.11.15
+
+    //ISIM access file ids from TS 31.103
+    static final int EF_ISIM_GBABP = 0x6fd5;
+    static final int EF_ISIM_GBANL = 0x6fd7;
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccFileHandler.java b/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
index 24d948c..e1f524b 100644
--- a/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
@@ -18,6 +18,7 @@ package com.android.internal.telephony.uicc;
 
 import android.os.*;
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.PhoneConstants;
 
 import java.util.ArrayList;
 
@@ -92,6 +93,9 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
     /** Finished retrieving size of record for EFimg now. */
     static protected final int EVENT_GET_RECORD_SIZE_IMG_DONE = 11;
 
+    // MTK
+    static protected final int EVENT_SELECT_EF_FILE = 100;
+
      // member variables
     protected final CommandsInterface mCi;
     protected final UiccCardApplication mParentApp;
@@ -104,6 +108,10 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
         boolean mLoadAll;
         String mPath;
 
+        // MTK
+        int mChannel;
+        int mMode;
+
         // Variables used to load part records
         boolean mLoadPart;
         ArrayList<Integer> mRecordNums;
@@ -120,6 +128,8 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
             mLoadAll = false;
             mLoadPart = false;
             mPath = null;
+            mChannel = 0;
+            mMode = -1;
         }
 
         LoadLinearFixedContext(int efid, int recordNum, String path, Message onLoaded) {
@@ -129,6 +139,8 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
             mLoadAll = false;
             mLoadPart = false;
             mPath = path;
+            mChannel = 0;
+            mMode = -1;
         }
 
         LoadLinearFixedContext(int efid, String path, Message onLoaded) {
@@ -138,6 +150,8 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
             mLoadPart = false;
             mOnLoaded = onLoaded;
             mPath = path;
+            mChannel = 0;
+            mMode = -1;
         }
 
         LoadLinearFixedContext(int efid, Message onLoaded) {
@@ -147,6 +161,8 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
             mLoadPart = false;
             mOnLoaded = onLoaded;
             mPath = null;
+            mChannel = 0;
+            mMode = -1;
         }
 
         LoadLinearFixedContext(int efid, ArrayList<Integer> recordNums, String path,
@@ -161,6 +177,31 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
             mCountLoadrecords = recordNums.size();
             mOnLoaded = onLoaded;
             mPath = path;
+            mChannel = 0;
+            mMode = -1;
+        }
+
+        // MTK
+        LoadLinearFixedContext(int efid, int recordNum, Message onLoaded, int channel) {
+            mEfid = efid;
+            mRecordNum = recordNum;
+            mOnLoaded = onLoaded;
+            mLoadAll = false;
+            mLoadPart = false;
+            mPath = null;
+            mChannel = channel;
+            mMode = -1;
+        }
+
+        LoadLinearFixedContext(int efid, Message onLoaded, int channel) {
+            mEfid = efid;
+            mRecordNum = 1;
+            mOnLoaded = onLoaded;
+            mLoadAll = true;
+            mLoadPart = false;
+            mPath = null;
+            mChannel = channel;
+            mMode = -1;
         }
 
         private void initLCResults(int size) {
@@ -496,6 +537,7 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
         int fileid;
         int recordSize[];
         String path = null;
+        int channel = 0;
 
         try {
             switch (msg.what) {
@@ -591,12 +633,22 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                  if (path == null) {
                      path = getEFPath(lc.mEfid);
                  }
-                 mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path,
-                         lc.mRecordNum,
-                         READ_RECORD_MODE_ABSOLUTE,
-                         lc.mRecordSize, null, null, mAid,
-                         obtainMessage(EVENT_READ_RECORD_DONE, lc));
-                 break;
+
+
+                 if (lc.mMode != -1) {
+                    mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid, getSmsEFPath(lc.mMode),
+                            lc.mRecordNum,
+                            READ_RECORD_MODE_ABSOLUTE,
+                            lc.mRecordSize, null, null, mAid, lc.mChannel,
+                            obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                } else {
+                    mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid, path,
+                            lc.mRecordNum,
+                            READ_RECORD_MODE_ABSOLUTE,
+                            lc.mRecordSize, null, null, mAid, lc.mChannel,
+                            obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                }
+                break;
             case EVENT_GET_BINARY_SIZE_DONE:
                 ar = (AsyncResult)msg.obj;
                 response = (Message) ar.userObj;
@@ -609,6 +661,7 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                 data = result.payload;
 
                 fileid = msg.arg1;
+                channel = msg.arg2;
 
                 if (UiccTlvData.isUiccTlvData(data)) {
 
@@ -634,8 +687,8 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                     throw new IccFileTypeMismatch();
                 }
 
-                mCi.iccIOForApp(COMMAND_READ_BINARY, fileid, getEFPath(fileid),
-                                0, 0, size, null, null, mAid,
+                mCi.iccIOForAppEx(COMMAND_READ_BINARY, fileid, getEFPath(fileid),
+                                0, 0, size, null, null, mAid, channel,
                                 obtainMessage(EVENT_READ_BINARY_DONE,
                                               fileid, 0, response));
             break;
@@ -665,11 +718,20 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                             path = getEFPath(lc.mEfid);
                         }
 
-                        mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path,
-                                    lc.mRecordNum,
-                                    READ_RECORD_MODE_ABSOLUTE,
-                                    lc.mRecordSize, null, null, mAid,
-                                    obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                        if (lc.mMode != -1) {
+                            mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid,
+                                        getSmsEFPath(lc.mMode),
+                                        lc.mRecordNum,
+                                        READ_RECORD_MODE_ABSOLUTE,
+                                        lc.mRecordSize, null, null, mAid, lc.mChannel,
+                                        obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                        } else {
+                            mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid, path,
+                                        lc.mRecordNum,
+                                        READ_RECORD_MODE_ABSOLUTE,
+                                        lc.mRecordSize, null, null, mAid, lc.mChannel,
+                                        obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                        }
                     }
                 } else if (lc.mLoadPart) {
                     lc.results.set(lc.mRecordNum - 1, result.payload);
@@ -680,9 +742,20 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                             if (path == null) {
                                 path = getEFPath(lc.mEfid);
                             }
-                            mCi.iccIOForApp(COMMAND_READ_RECORD, lc.mEfid, path, lc.mRecordNum,
-                                    READ_RECORD_MODE_ABSOLUTE, lc.mRecordSize, null, null, mAid,
-                                    obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                            if (lc.mMode != -1) {
+                                mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid,
+                                            getSmsEFPath(lc.mMode),
+                                            lc.mRecordNum,
+                                            READ_RECORD_MODE_ABSOLUTE,
+                                            lc.mRecordSize, null, null, mAid, lc.mChannel,
+                                            obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                            } else {
+                                mCi.iccIOForAppEx(COMMAND_READ_RECORD, lc.mEfid, path,
+                                            lc.mRecordNum,
+                                            READ_RECORD_MODE_ABSOLUTE,
+                                        lc.mRecordSize, null, null, mAid, lc.mChannel,
+                                            obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                            }
                         } else {
                             sendResult(response, lc.results, null);
                         }
@@ -752,9 +825,123 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
         return null;
     }
 
+    public boolean needsFakeIccid() {
+        return mCi.needsOldRilFeature("fakeiccid");
+    }
+
     protected abstract String getEFPath(int efid);
     protected abstract void logd(String s);
 
     protected abstract void loge(String s);
 
+    // MTK
+    public void loadEFLinearFixedAll(int fileid, Message onLoaded, boolean is7FFF) {
+        Message response = obtainMessage(EVENT_GET_RECORD_SIZE_DONE,
+                        new LoadLinearFixedContext(fileid, onLoaded));
+
+        mCi.iccIOForApp(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid, is7FFF),
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, response);
+    }
+
+    public void loadEFLinearFixedAll(int fileid, int mode , Message onLoaded) {
+        LoadLinearFixedContext lc = new LoadLinearFixedContext(fileid, onLoaded);
+        lc.mMode = mode;
+        Message response = obtainMessage(EVENT_GET_RECORD_SIZE_DONE, lc);
+
+        mCi.iccIOForApp(COMMAND_GET_RESPONSE, fileid, getSmsEFPath(mode),
+                    0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, response);
+    }
+
+    protected String getSmsEFPath(int mode)
+    {
+        String efpath = "";
+
+        if (mode == PhoneConstants.PHONE_TYPE_GSM)
+            efpath = IccConstants.MF_SIM + IccConstants.DF_TELECOM;
+        else if (mode == PhoneConstants.PHONE_TYPE_CDMA)
+            efpath = IccConstants.MF_SIM + IccConstants.DF_CDMA;
+
+        return efpath;
+    }
+
+
+    /**
+     * Load a SIM Transparent EF with path specified
+     *
+     * @param fileid EF id
+     * @param efPath EF path
+     * @param onLoaded
+     *
+     * ((AsyncResult)(onLoaded.obj)).result is the byte[]
+     *
+     */
+
+    public void loadEFTransparent(int fileid, String efPath, Message onLoaded) {
+        Message response = obtainMessage(EVENT_GET_BINARY_SIZE_DONE,
+                        fileid, 0, onLoaded);
+
+        mCi.iccIOForApp(COMMAND_GET_RESPONSE, fileid, efPath,
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, response);
+    }
+
+
+    /**
+     * select an EF file and get response
+     *
+     * @param fileid EF id
+     * @param onLoaded (EFResponseData)efData
+     *
+     */
+    public void selectEFFile(int fileid, Message onLoaded) {
+        Message response
+                = obtainMessage(EVENT_SELECT_EF_FILE,  fileid, 0, onLoaded);
+
+        mCi.iccIOForApp(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid),
+                    0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, response);
+    }
+    //MTK-START Support Multi-Application
+    /**
+     * Load a SIM Transparent EF
+     *
+     * @param fileid EF id
+     * @param channel application channel
+     * @param onLoaded
+     *
+     * ((AsyncResult)(onLoaded.obj)).result is the byte[]
+     *
+     */
+
+    public void loadEFTransparentEx(int fileid, int channel , Message onLoaded) {
+        Message response = obtainMessage(EVENT_GET_BINARY_SIZE_DONE,
+                        fileid, channel, onLoaded);
+
+        mCi.iccIOForAppEx(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid),
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, channel, response);
+    }
+
+    public void loadEFLinearFixedEx(int fileid, int recordNum, int channel, Message onLoaded) {
+        Message response
+            = obtainMessage(EVENT_GET_RECORD_SIZE_DONE,
+                        new LoadLinearFixedContext(fileid, recordNum, onLoaded, channel));
+
+        mCi.iccIOForAppEx(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid),
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, channel, response);
+    }
+    public void loadEFLinearFixedAllEx(int fileid, int channel, Message onLoaded) {
+        Message response = obtainMessage(EVENT_GET_RECORD_SIZE_DONE,
+                        new LoadLinearFixedContext(fileid, onLoaded, channel));
+
+        mCi.iccIOForAppEx(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid, false),
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, channel, response);
+    }
+
+    public void updateEFTransparentEx(int fileid, int channel, byte[ ] data, Message onComplete) {
+        mCi.iccIOForAppEx(COMMAND_UPDATE_BINARY, fileid, getEFPath(fileid),
+                        0, 0, data.length,
+                        IccUtils.bytesToHexString(data), null, mAid, channel, onComplete);
+    }
+
+    //MTK-END Support Multi-Application
+
+    protected String getEFPath(int efid, boolean is7FFF) { return null; };
 }
diff --git a/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index 4d16293..883642b 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -723,11 +723,15 @@ public final class RuimRecords extends IccRecords {
                 data = (byte[])ar.result;
 
                 if (ar.exception != null) {
-                    break;
+                    if(mFh.needsFakeIccid()) {
+                        mIccId = FAKE_ICCID;
+                    } else {
+                        break;
+                    }
+                } else {
+                    mIccId = IccUtils.bcdToString(data, 0, data.length);
                 }
 
-                mIccId = IccUtils.bcdToString(data, 0, data.length);
-
                 log("iccid: " + mIccId);
 
             break;
diff --git a/src/java/com/android/internal/telephony/uicc/SIMRecords.java b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
index cd65830..df24072 100644
--- a/src/java/com/android/internal/telephony/uicc/SIMRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
@@ -876,11 +876,15 @@ public class SIMRecords extends IccRecords {
                 data = (byte[])ar.result;
 
                 if (ar.exception != null) {
-                    break;
+                    if(mFh.needsFakeIccid()) {
+                        mIccId = FAKE_ICCID;
+                    } else {
+                        break;
+                    }
+                } else {
+                    mIccId = IccUtils.bcdToString(data, 0, data.length);
                 }
 
-                mIccId = IccUtils.bcdToString(data, 0, data.length);
-
                 log("iccid: " + mIccId);
 
             break;
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCard.java b/src/java/com/android/internal/telephony/uicc/UiccCard.java
index 1c27e44..2c6a474 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCard.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCard.java
@@ -98,8 +98,20 @@ public class UiccCard {
     private static final int EVENT_CARRIER_PRIVILIGES_LOADED = 20;
     private static final int EVENT_SIM_GET_ATR_DONE = 21;
 
+    // MTK
+    private static final int EVENT_GET_ATR_DONE = 100;
+    private static final int EVENT_OPEN_CHANNEL_WITH_SW_DONE = 101;
+
     private int mPhoneId;
 
+    // MTK
+    static final String[] UICCCARD_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+
     public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int phoneId) {
         mCardState = ics.mCardState;
         mPhoneId = phoneId;
@@ -371,6 +383,9 @@ public class UiccCard {
                 case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
                 case EVENT_SIM_IO_DONE:
                 case EVENT_SIM_GET_ATR_DONE:
+                // MTK
+                case EVENT_GET_ATR_DONE:
+                case EVENT_OPEN_CHANNEL_WITH_SW_DONE:
                     AsyncResult ar = (AsyncResult)msg.obj;
                     if (ar.exception != null) {
                        if (DBG)
@@ -706,4 +721,96 @@ public class UiccCard {
         }
         pw.flush();
     }
+
+    // MTK additions
+
+    public int getSlotId() {
+        return mPhoneId;
+    }
+
+    public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int slotId, boolean isUpdateSiminfo) {
+        if (DBG) log("Creating simId " + slotId + ",isUpdateSiminfo" + isUpdateSiminfo);
+        mCardState = ics.mCardState;
+        mPhoneId = slotId;
+        update(c, ci, ics, isUpdateSiminfo);
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        mCi.iccIO(command, fileID, pathID, p1, p2, p3, data, pin2,
+              mHandler.obtainMessage(EVENT_SIM_IO_DONE, onComplete));
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        mCi.iccGetATR(mHandler.obtainMessage(EVENT_GET_ATR_DONE, onComplete));
+    }
+
+    public String getIccCardType() {
+        final String mIccType = SystemProperties.get(UICCCARD_PROPERTY_RIL_UICC_TYPE[mPhoneId]);
+        if (DBG) log("getIccCardType(): iccType = " + mIccType);
+        return mIccType;
+    }
+
+    public void iccOpenChannelWithSw(String AID, Message onComplete) {
+        mCi.iccOpenChannelWithSw(AID,
+            mHandler.obtainMessage(EVENT_OPEN_CHANNEL_WITH_SW_DONE, onComplete));
+    }
+
+    public void update(Context c, CommandsInterface ci, IccCardStatus ics, boolean isUpdateSimInfo) {
+        synchronized (mLock) {
+            if (mDestroyed) {
+                loge("Updated after destroyed! Fix me!");
+                return;
+            }
+            CardState oldState = mCardState;
+            mCardState = ics.mCardState;
+            mUniversalPinState = ics.mUniversalPinState;
+            mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+            mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+            mImsSubscriptionAppIndex = ics.mImsSubscriptionAppIndex;
+            mContext = c;
+            mCi = ci;
+            //update applications
+            if (DBG) log(ics.mApplications.length + " applications");
+            for (int i = 0; i < mUiccApplications.length; i++) {
+                if (mUiccApplications[i] == null) {
+                    //Create newly added Applications
+                    if (i < ics.mApplications.length) {
+                        mUiccApplications[i] = new UiccCardApplication(this,
+                                ics.mApplications[i], mContext, mCi);
+                    }
+                } else if (i >= ics.mApplications.length) {
+                    //Delete removed applications
+                    mUiccApplications[i].dispose();
+                    mUiccApplications[i] = null;
+                } else {
+                    //Update the rest
+                    mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
+                }
+            }
+
+            createAndUpdateCatService();
+            sanitizeApplicationIndexes();
+
+            RadioState radioState = mCi.getRadioState();
+            if (DBG) log("update: radioState=" + radioState + " mLastRadioState="
+                    + mLastRadioState + "isUpdateSimInfo= " + isUpdateSimInfo);
+            // No notifications while radio is off or we just powering up
+            if (isUpdateSimInfo) {
+                if (radioState == RadioState.RADIO_ON && mLastRadioState == RadioState.RADIO_ON) {
+                    if (oldState != CardState.CARDSTATE_ABSENT &&
+                            mCardState == CardState.CARDSTATE_ABSENT) {
+                        if (DBG) log("update: notify card removed");
+                        mAbsentRegistrants.notifyRegistrants();
+                        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_REMOVED, null));
+                    } else if (oldState == CardState.CARDSTATE_ABSENT &&
+                            mCardState != CardState.CARDSTATE_ABSENT) {
+                        if (DBG) log("update: notify card added");
+                        mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED, null));
+                    }
+                }
+            }
+            mLastRadioState = radioState;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index cce75f1..c455256 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -22,6 +22,7 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 
 import com.android.internal.telephony.CommandsInterface;
@@ -88,6 +89,37 @@ public class UiccCardApplication {
     private RegistrantList mPinLockedRegistrants = new RegistrantList();
     private RegistrantList mPersoLockedRegistrants = new RegistrantList();
 
+    // MTK
+    private int mSlotId;
+
+    private static final int EVENT_QUERY_NETWORK_LOCK_DONE = 101;
+    private static final int EVENT_CHANGE_NETWORK_LOCK_DONE = 102;
+    private static final int EVENT_RADIO_NOTAVAILABLE = 103;
+
+    // [02772] start
+    static final String[] UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+    protected String mIccType = null; /* Add for USIM detect */
+    // [02772] end
+
+    private static final String PROPERTY_PIN1_RETRY[] = {
+        "gsm.sim.retry.pin1",
+        "gsm.sim.retry.pin1.2",
+        "gsm.sim.retry.pin1.3",
+        "gsm.sim.retry.pin1.4",
+    };
+
+    private static final String PROPERTY_PIN2_RETRY[] = {
+        "gsm.sim.retry.pin2",
+        "gsm.sim.retry.pin2.2",
+        "gsm.sim.retry.pin2.3",
+        "gsm.sim.retry.pin2.4",
+    };
+
     UiccCardApplication(UiccCard uiccCard,
                         IccCardApplicationStatus as,
                         Context c,
@@ -107,6 +139,8 @@ public class UiccCardApplication {
         mContext = c;
         mCi = ci;
 
+        mSlotId = mUiccCard.getSlotId();
+
         mIccFh = createIccFileHandler(as.app_type);
         mIccRecords = createIccRecords(as.app_type, mContext, mCi);
         if (mAppState == AppState.APPSTATE_READY) {
@@ -146,6 +180,8 @@ public class UiccCardApplication {
                 mIccRecords = createIccRecords(as.app_type, c, ci);
             }
 
+            // MTK log
+            if (DBG) log("mPersoSubState: " + mPersoSubState + " oldPersoSubState: " + oldPersoSubState);
             if (mPersoSubState != oldPersoSubState &&
                     isPersoLocked()) {
                 notifyPersoLockedRegistrantsIfNeeded(null);
@@ -409,6 +445,28 @@ public class UiccCardApplication {
                     ar = (AsyncResult)msg.obj;
                     onChangeFacilityLock(ar);
                     break;
+                case EVENT_QUERY_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_QUERY_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error query network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage((Message) ar.userObj, ar.result, ar.exception);
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
+                case EVENT_CHANGE_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_CHANGE_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error change network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                                        = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
                 case EVENT_RADIO_UNAVAILABLE:
                     if (DBG) log("handleMessage (EVENT_RADIO_UNAVAILABLE)");
                     mAppState = AppState.APPSTATE_UNKNOWN;
@@ -779,12 +837,34 @@ public class UiccCardApplication {
         }
     }
 
+    // MTK implementation of getIccFdnAvailable
+    public boolean getIccFdnAvailableMTK() {
+        if (mIccRecords == null) {
+            if (DBG) log("isFdnExist mIccRecords == null");
+            return false;
+        }
+
+        UsimServiceTable ust = mIccRecords.getUsimServiceTable();
+        if (ust != null && ust.isAvailable(UsimServiceTable.UsimService.FDN)) {
+            if (DBG) log("isFdnExist return true");
+            return true;
+        } else {
+            if (DBG) log("isFdnExist return false");
+            return false;
+        }
+    }
+
     /**
      * Check whether fdn (fixed dialing number) service is available.
      * @return true if ICC fdn service available
      *         false if ICC fdn service not available
      */
     public boolean getIccFdnAvailable() {
+        final boolean mtkResult = getIccFdnAvailableMTK();
+        if (mtkResult != mIccFdnAvailable) {
+            if (DBG) log("getIccFdnAvailable: WARNING: mIccFdnAvailable="
+                    + mIccFdnAvailable + " disagrees with mtkResult!");
+        }
         return mIccFdnAvailable;
     }
 
@@ -958,4 +1038,87 @@ public class UiccCardApplication {
         }
         pw.flush();
     }
+
+    // MTK
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mFdnChangedRegistrants.add(r);
+        }
+    }
+
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
+
+    public int getSlotId() {
+        return mSlotId;
+    }
+
+    private void notifyFdnChangedRegistrants() {
+        if (mDestroyed) {
+            return;
+        }
+
+        mFdnChangedRegistrants.notifyRegistrants();
+    }
+
+    public String getIccCardType() {
+         if (mIccType == null || mIccType.equals("")) {
+            mIccType = SystemProperties.get(UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE[mSlotId]);
+         }
+
+        log("getIccCardType(): mIccType = " + mIccType);
+        return mIccType;
+    }
+
+    //MTK-START [mtk80601][111215][ALPS00093395]
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  " + category);
+
+        switch(category) {
+            case CommandsInterface.CAT_NETWOEK:
+            case CommandsInterface.CAT_NETOWRK_SUBSET:
+            case CommandsInterface.CAT_CORPORATE:
+            case CommandsInterface.CAT_SERVICE_PROVIDER:
+            case CommandsInterface.CAT_SIM:
+                mCi.queryNetworkLock(category, mHandler.obtainMessage(EVENT_QUERY_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "queryIccNetworkLock unknown category = " + category);
+                break;
+        }
+   }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = " + category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+
+        switch(lockop) {
+            case CommandsInterface.OP_REMOVE:
+            case CommandsInterface.OP_ADD:
+            case CommandsInterface.OP_LOCK:
+            case CommandsInterface.OP_PERMANENT_UNLOCK:
+            case CommandsInterface.OP_UNLOCK:
+                mCi.setNetworkLock(category, lockop, password, data_imsi, gid1, gid2, mHandler.obtainMessage(EVENT_CHANGE_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "SetIccNetworkEnabled unknown operation" + lockop);
+                break;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 3e5d679..e3cc67c 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -18,14 +18,19 @@ package com.android.internal.telephony.uicc;
 
 import android.content.Context;
 import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.BroadcastReceiver;
+import android.content.IntentFilter;
 
 import android.os.AsyncResult;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
 import android.os.SystemProperties;
 import android.telephony.TelephonyManager;
+import android.telephony.SubscriptionManager;
 import android.telephony.Rlog;
 import android.text.format.Time;
 
@@ -34,7 +39,10 @@ import android.telephony.ServiceState;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -97,6 +105,36 @@ public class UiccController extends Handler {
     private static final int EVENT_REFRESH = 4;
     private static final int EVENT_REFRESH_OEM = 5;
 
+    // MTK
+    protected static final int EVENT_RADIO_AVAILABLE = 100;
+    protected static final int EVENT_VIRTUAL_SIM_ON = 101;
+    protected static final int EVENT_VIRTUAL_SIM_OFF = 102;
+    protected static final int EVENT_SIM_MISSING = 103;
+    protected static final int EVENT_QUERY_SIM_MISSING_STATUS = 104;
+    protected static final int EVENT_SIM_RECOVERY = 105;
+    protected static final int EVENT_GET_ICC_STATUS_DONE_FOR_SIM_MISSING = 106;
+    protected static final int EVENT_GET_ICC_STATUS_DONE_FOR_SIM_RECOVERY = 107;
+    protected static final int EVENT_QUERY_ICCID_DONE_FOR_HOT_SWAP = 108;
+    protected static final int EVENT_SIM_PLUG_OUT = 109;
+    protected static final int EVENT_SIM_PLUG_IN = 110;
+    protected static final int EVENT_HOTSWAP_GET_ICC_STATUS_DONE = 111;
+    protected static final int EVENT_QUERY_SIM_STATUS_FOR_PLUG_IN = 112;
+    protected static final int EVENT_QUERY_SIM_MISSING = 113;
+    protected static final int EVENT_INVALID_SIM_DETECTED = 114;
+    protected static final int EVENT_REPOLL_SML_STATE = 115;
+    protected static final int EVENT_COMMON_SLOT_NO_CHANGED = 116;
+
+    //Multi-application
+    protected static final int EVENT_TURN_ON_ISIM_APPLICATION_DONE = 200;
+    protected static final int EVENT_GET_ICC_APPLICATION_STATUS = 201;
+    protected static final int EVENT_APPLICATION_SESSION_CHANGED = 202;
+
+    private static final int SML_FEATURE_NO_NEED_BROADCAST_INTENT = 0;
+    private static final int SML_FEATURE_NEED_BROADCAST_INTENT = 1;
+    private static final String ACTION_RESET_MODEM = "android.intent.action.sim.ACTION_RESET_MODEM";
+    private static final String PROPERTY_3G_SWITCH = "gsm.3gswitch";
+    private static final String COMMON_SLOT_PROPERTY = "ro.mtk_sim_hot_swap_common_slot";
+
     private CommandsInterface[] mCis;
     private UiccCard[] mUiccCards = new UiccCard[TelephonyManager.getDefault().getPhoneCount()];
 
@@ -109,6 +147,15 @@ public class UiccController extends Handler {
 
     private boolean mOEMHookSimRefresh = false;
 
+    // MTK
+    private boolean mIsHotSwap = false;
+    private boolean mClearMsisdn = false;
+
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    //Multi-application
+    private int[] mImsSessionId = new int[TelephonyManager.getDefault().getPhoneCount()];
+    private RegistrantList mApplicationChangedRegistrants = new RegistrantList();
+
     // Logging for dumpsys. Useful in cases when the cards run into errors.
     private static final int MAX_PROACTIVE_COMMANDS_TO_LOG = 20;
     private LinkedList<String> mCardLogs = new LinkedList<String>();
@@ -131,9 +178,11 @@ public class UiccController extends Handler {
                 com.android.internal.R.bool.config_sim_refresh_for_dual_mode_card);
         for (int i = 0; i < mCis.length; i++) {
             Integer index = new Integer(i);
-            if (SystemProperties.getBoolean("persist.radio.apm_sim_not_pwdn", false)) {
+            if (SystemProperties.getBoolean("persist.radio.apm_sim_not_pwdn", false) ||
+                SystemProperties.get("gsm.version.ril-impl").startsWith("mtk")) {
                 // Reading ICC status in airplane mode is only supported in QCOM
                 // RILs when this property is set to true
+                // and MTK RILs
                 mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
             } else {
                 mCis[i].registerForOn(this, EVENT_ICC_STATUS_CHANGED, index);
@@ -142,12 +191,30 @@ public class UiccController extends Handler {
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
             mCis[i].registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, index);
+
+            mCis[i].registerForVirtualSimOn(this, EVENT_VIRTUAL_SIM_ON, index);
+            mCis[i].registerForVirtualSimOff(this, EVENT_VIRTUAL_SIM_OFF, index);
+            mCis[i].registerForSimMissing(this, EVENT_SIM_MISSING, index);
+            mCis[i].registerForSimRecovery(this, EVENT_SIM_RECOVERY, index);
+            mCis[i].registerForSimPlugOut(this, EVENT_SIM_PLUG_OUT, index);
+            mCis[i].registerForSimPlugIn(this, EVENT_SIM_PLUG_IN, index);
+            mCis[i].registerForCommonSlotNoChanged(this, EVENT_COMMON_SLOT_NO_CHANGED, index);
+            mCis[i].registerForSessionChanged(this, EVENT_APPLICATION_SESSION_CHANGED, index);
+
             if (mOEMHookSimRefresh) {
                 mCis[i].registerForSimRefreshEvent(this, EVENT_REFRESH_OEM, index);
             } else {
                 mCis[i].registerForIccRefresh(this, EVENT_REFRESH, index);
             }
         }
+
+        IntentFilter filter = new IntentFilter();
+        /* TODO: Wait for SIM Info migration done
+        filter.addAction(TelephonyIntents.ACTION_SIM_INFO_UPDATE);
+        */
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        filter.addAction(ACTION_RESET_MODEM);
+        mContext.registerReceiver(mIntentReceiver, filter);
     }
 
     public static UiccController getInstance() {
@@ -239,6 +306,23 @@ public class UiccController extends Handler {
         }
     }
 
+    //Notifies when card status changes
+    public void registerForIccRecovery(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mRecoveryRegistrants.add(r);
+            //Notify registrant right after registering, so that it will get the latest ICC status,
+            //otherwise which may not happen until there is an actual change in ICC status.
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForIccRecovery(Handler h) {
+        synchronized (mLock) {
+            mRecoveryRegistrants.remove(h);
+        }
+    }
+
     @Override
     public void handleMessage (Message msg) {
         synchronized (mLock) {
@@ -259,6 +343,38 @@ public class UiccController extends Handler {
                     AsyncResult ar = (AsyncResult)msg.obj;
                     onGetIccCardStatusDone(ar, index);
                     break;
+                case EVENT_REPOLL_SML_STATE:
+                    if (DBG) log("Received EVENT_REPOLL_SML_STATE");
+                    ar = (AsyncResult) msg.obj;
+                    boolean needIntent = msg.arg1 == SML_FEATURE_NEED_BROADCAST_INTENT ? true : false;
+
+                    //Update Uicc Card status.
+                    onGetIccCardStatusDone(ar, index, false);
+
+                    // If we still in Network lock, broadcast intent if caller need this intent.
+                    if (mUiccCards[index] != null && needIntent == true) {
+                        UiccCardApplication app = mUiccCards[index].getApplication(APP_FAM_3GPP);
+                        if (app == null) {
+                            if (DBG) log("UiccCardApplication = null");
+                            break;
+                        }
+                        if (app.getState() == AppState.APPSTATE_SUBSCRIPTION_PERSO) {
+                            Intent lockIntent = new Intent();
+                            if (null == lockIntent) {
+                                if (DBG) log("New intent failed");
+                                return;
+                            }
+                            if (DBG) log("Broadcast ACTION_UNLOCK_SIM_LOCK");
+                            lockIntent.setAction(TelephonyIntents.ACTION_UNLOCK_SIM_LOCK);
+                            lockIntent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE,
+                                    IccCardConstants.INTENT_VALUE_ICC_LOCKED);
+                            lockIntent.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON,
+                                    parsePersoType(app.getPersoSubState()));
+                            SubscriptionManager.putPhoneIdAndSubIdExtra(lockIntent, index);
+                            mContext.sendBroadcast(lockIntent);
+                        }
+                    }
+                    break;
                 case EVENT_RADIO_UNAVAILABLE:
                     if (DBG) log("EVENT_RADIO_UNAVAILABLE, dispose card");
                     if (mUiccCards[index] != null) {
@@ -267,6 +383,90 @@ public class UiccController extends Handler {
                     mUiccCards[index] = null;
                     mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
                     break;
+                case EVENT_TURN_ON_ISIM_APPLICATION_DONE:
+                    if (DBG) log("Received EVENT_TURN_ON_ISIM_APPLICATION_DONE");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "[SIM " + index + "] Error turn on ISIM. ", ar.exception);
+                        return;
+                    }
+
+                    //Response format: <Application ID>, <Session ID>
+                    int[] ints = (int[]) ar.result;
+                    if (DBG) log("Application ID = " + ints[0] + "Session ID = " + ints[1]);
+
+                    mImsSessionId[index] =  ints[1];
+                    mCis[index].getIccApplicationStatus(mImsSessionId[index],
+                            obtainMessage(EVENT_GET_ICC_APPLICATION_STATUS, index));
+                    break;
+
+                case EVENT_GET_ICC_APPLICATION_STATUS:
+                    if (DBG) log("Received EVENT_GET_ICC_APPLICATION_STATUS");
+                    ar = (AsyncResult) msg.obj;
+                    onGetIccApplicationStatusDone(ar, index);
+                    break;
+
+                case EVENT_APPLICATION_SESSION_CHANGED:
+                    if (DBG) log("Received EVENT_APPLICATION_SESSION_CHANGED");
+                    ar = (AsyncResult) msg.obj;
+
+                    //Response format: <Application ID>, <Session ID>
+                    int[] result = (int[]) ar.result;
+                    // FIXME: application id and array index? only support one application now.
+                    if (DBG) log("Application = " + result[0] + ", Session = " + result[1]);
+                    mImsSessionId[index] =  result[1];
+                    break;
+                case EVENT_VIRTUAL_SIM_ON:
+                    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
+                    // setNotificationVirtual(index, EVENT_VIRTUAL_SIM_ON);
+                    SharedPreferences shOn = mContext.getSharedPreferences("AutoAnswer", 1);
+                    SharedPreferences.Editor editorOn = shOn.edit();
+                    editorOn.putBoolean("flag", true);
+                    editorOn.commit();
+                    break;
+               case EVENT_VIRTUAL_SIM_OFF:
+                    if (DBG) log("handleMessage (EVENT_VIRTUAL_SIM_OFF)");
+                    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
+                    // removeNotificationVirtual(index, EVENT_VIRTUAL_SIM_ON);
+                    //setNotification(index, EVENT_SIM_MISSING);
+                    SharedPreferences shOff = mContext.getSharedPreferences("AutoAnswer", 1);
+                    SharedPreferences.Editor editorOff = shOff.edit();
+                    editorOff.putBoolean("flag", false);
+                    editorOff.commit();
+                    break;
+                case EVENT_SIM_RECOVERY:
+                    if (DBG) log("handleMessage (EVENT_SIM_RECOVERY)");
+                    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE_FOR_SIM_RECOVERY, index));
+                    mRecoveryRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
+                    //disableSimMissingNotification(index);
+
+                    //ALPS01209124
+                    Intent intent = new Intent();
+                    intent.setAction(TelephonyIntents.ACTION_SIM_RECOVERY_DONE);
+                    mContext.sendBroadcast(intent);
+                    break;
+                case EVENT_SIM_MISSING:
+                    if (DBG) log("handleMessage (EVENT_SIM_MISSING)");
+                    //setNotification(index, EVENT_SIM_MISSING);
+                    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE_FOR_SIM_MISSING, index));
+                    break;
+                case EVENT_GET_ICC_STATUS_DONE_FOR_SIM_MISSING:
+                    if (DBG) log("Received EVENT_GET_ICC_STATUS_DONE_FOR_SIM_MISSING");
+                    ar = (AsyncResult) msg.obj;
+                    onGetIccCardStatusDone(ar, index, false);
+                case EVENT_GET_ICC_STATUS_DONE_FOR_SIM_RECOVERY:
+                    if (DBG) log("Received EVENT_GET_ICC_STATUS_DONE_FOR_SIM_RECOVERY");
+                    ar = (AsyncResult) msg.obj;
+                    onGetIccCardStatusDone(ar, index, false);
+                    break;
+                case EVENT_COMMON_SLOT_NO_CHANGED:
+                    if (DBG) log("handleMessage (EVENT_COMMON_SLOT_NO_CHANGED)");
+                    Intent intentNoChanged = new Intent(TelephonyIntents.ACTION_COMMON_SLOT_NO_CHANGED);
+                    int slotId = index.intValue();
+                    SubscriptionManager.putPhoneIdAndSubIdExtra(intentNoChanged, slotId);
+                    log("Broadcasting intent ACTION_COMMON_SLOT_NO_CHANGED for mSlotId : " + slotId);
+                    mContext.sendBroadcast(intentNoChanged);
+                    break;
                 case EVENT_REFRESH:
                     ar = (AsyncResult)msg.obj;
                     if (DBG) log("Sim REFRESH received");
@@ -437,4 +637,223 @@ public class UiccController extends Handler {
             pw.println("  " + mCardLogs.get(i));
         }
     }
+
+    // MTK
+    private synchronized void onGetIccCardStatusDone(AsyncResult ar, Integer index, boolean isUpdate) {
+        if (ar.exception != null) {
+            Rlog.e(LOG_TAG, "Error getting ICC status. "
+                    + "RIL_REQUEST_GET_ICC_STATUS should "
+                    + "never return an error", ar.exception);
+            return;
+        }
+        if (!isValidCardIndex(index)) {
+            Rlog.e(LOG_TAG, "onGetIccCardStatusDone: invalid index : " + index);
+            return;
+        }
+        if (DBG) log("onGetIccCardStatusDone, index " + index + "isUpdateSiminfo " + isUpdate);
+
+        IccCardStatus status = (IccCardStatus) ar.result;
+
+        //if (status.mCardState == IccCardStatus.CardState.CARDSTATE_PRESENT) {
+        //    if (DBG) log("onGetIccCardStatusDone, disableSimMissingNotification because card is present");
+        //    disableSimMissingNotification(index);
+        //}
+
+        if (mUiccCards[index] == null) {
+            //Create new card
+            mUiccCards[index] = new UiccCard(mContext, mCis[index], status, index, isUpdate);
+
+/*
+            // Update the UiccCard in base class, so that if someone calls
+            // UiccManager.getUiccCard(), it will return the default card.
+            if (index == PhoneConstants.DEFAULT_CARD_INDEX) {
+                mUiccCard = mUiccCards[index];
+            }
+*/
+        } else {
+            //Update already existing card
+            mUiccCards[index].update(mContext, mCis[index] , status, isUpdate);
+        }
+
+        if (DBG) log("Notifying IccChangedRegistrants");
+        // TODO: Think if it is possible to pass isUpdate
+        if (!SystemProperties.get(COMMON_SLOT_PROPERTY).equals("1")) {
+            mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
+        } else {
+            Bundle result = new Bundle();
+            result.putInt("Index", index.intValue());
+            result.putBoolean("ForceUpdate", isUpdate);
+
+            mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, result, null));
+        }
+    }
+
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) return;
+            String action = intent.getAction();
+            log("mIntentReceiver Receive action " + action);
+
+            if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(intent.getAction())) {
+                log(intent.toString() + intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE));
+                String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                int slot = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                log("mIntentReceiver ACTION_SIM_STATE_CHANGED slot " + slot + " ,state " + stateExtra);
+
+                if (slot >= TelephonyManager.getDefault().getPhoneCount()) {
+                    Rlog.e(LOG_TAG, "BroadcastReceiver SIM State changed slot is invalid");
+                    return;
+                }
+
+                String iccType = ((getUiccCard(slot) != null) ? getUiccCard(slot).getIccCardType() : "");
+
+                if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)
+                        && "USIM".equals(iccType)) {
+                    mCis[slot].openIccApplication(0, obtainMessage(EVENT_TURN_ON_ISIM_APPLICATION_DONE, slot));
+                }
+            } else if (action.equals(ACTION_RESET_MODEM)) {
+                int simIdFor3G = SystemProperties.getInt(PROPERTY_3G_SWITCH, 1) - 1;
+                int slotId = intent.getIntExtra("SLOT_ID", 0);
+                if (slotId < 0 || slotId >= mCis.length) {
+                    log("Receive ACTION_RESET_MODEM: invalid slot id." + slotId);
+                    return;
+                }
+                log("mIntentReceiver Receive ACTION_RESET_MODEM: " + slotId);
+                if (simIdFor3G == slotId) {
+                    log("phone " + simIdFor3G + " will reset modem");
+                    mCis[slotId].resetRadio(null);
+                }
+            } /* else if (TelephonyIntents.ACTION_SIM_INFO_UPDATE.equals(action)) {
+                //ALPS00776430: Since EF_MSISDN can not be read/wrtie without verify PIN.
+                //We need to clear it or update it to avoid user to get the cached data before.
+                new Thread() {
+                    @Override
+                    public void run() {
+                        SIMInfo simInfo = SIMInfo.getSIMInfoBySlot(mContext, mSimId);
+                        if (simInfo!= null && mClearMsisdn == false) {
+                            mClearMsisdn = true;
+                            log("Initial sim info.");
+                            IccRecords iccRecord = getIccRecords(APP_FAM_3GPP);
+                            if(iccRecord != null) {
+                                SIMInfo.setNumber(mContext, iccRecord.getMsisdnNumber(), simInfo.mSimId);
+                            } else {
+                                SIMInfo.setNumber(mContext, "", simInfo.mSimId);
+                            }
+                            Intent intent = new Intent(TelephonyIntents.ACTION_SIM_INFO_UPDATE);
+                            ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+                        }
+                    }
+                }.start();
+            } */
+        }
+    };
+
+    private synchronized void onGetIccApplicationStatusDone(AsyncResult ar, Integer index) {
+        if (ar.exception != null) {
+            Rlog.e(LOG_TAG, "Error getting ICC status. "
+                    + "RIL_REQUEST_GET_ICC_APPLICATION_STATUS should "
+                    + "never return an error", ar.exception);
+            return;
+        }
+        if (!isValidCardIndex(index)) {
+            Rlog.e(LOG_TAG, "onGetIccApplicationStatusDone: invalid index : " + index);
+            return;
+        }
+        if (DBG) log("onGetIccApplicationStatusDone, index " + index);
+
+        IccCardStatus status = (IccCardStatus) ar.result;
+
+        if (mUiccCards[index] == null) {
+            //Create new card
+            mUiccCards[index] = new UiccCard(mContext, mCis[index], status, index);
+
+/*
+            // Update the UiccCard in base class, so that if someone calls
+            // UiccManager.getUiccCard(), it will return the default card.
+            if (index == PhoneConstants.DEFAULT_CARD_INDEX) {
+                mUiccCard = mUiccCards[index];
+            }
+*/
+        } else {
+            //Update already existing card
+            mUiccCards[index].update(mContext, mCis[index] , status);
+        }
+
+        if (DBG) log("Notifying mApplicationChangedRegistrants");
+        mApplicationChangedRegistrants.notifyRegistrants();
+    }
+
+    private int mBtSlotId = -1;
+
+    /**
+     * Get BT connected sim id.
+     *
+     * @internal
+     */
+    public int getBtConnectedSimId() {
+        if (DBG) log("getBtConnectedSimId, slot " + mBtSlotId);
+        return mBtSlotId;
+    }
+
+    /**
+     * Set BT connected sim id.
+     *
+     * @internal
+     */
+    public void setBtConnectedSimId(int simId) {
+        mBtSlotId = simId;
+        if (DBG) log("setBtConnectedSimId, slot " + mBtSlotId);
+    }
+
+    /**
+     * Parse network lock reason string.
+     *
+     * @param state network lock type
+     * @return network lock string
+     *
+     */
+    private String parsePersoType(PersoSubState state) {
+        if (DBG) log("parsePersoType, state = " + state);
+        switch (state) {
+            case PERSOSUBSTATE_SIM_NETWORK:
+                return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+            case PERSOSUBSTATE_SIM_NETWORK_SUBSET:
+                return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+            case PERSOSUBSTATE_SIM_CORPORATE:
+                return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+            case PERSOSUBSTATE_SIM_SERVICE_PROVIDER:
+                return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+            case PERSOSUBSTATE_SIM_SIM:
+                return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+            default:
+                break;
+        }
+        return IccCardConstants.INTENT_VALUE_ICC_UNKNOWN;
+    }
+
+    //Modem SML change feature.
+    public void repollIccStateForModemSmlChangeFeatrue(int slotId, boolean needIntent) {
+        if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
+        int arg1 = needIntent == true ? SML_FEATURE_NEED_BROADCAST_INTENT : SML_FEATURE_NO_NEED_BROADCAST_INTENT;
+        //Use arg1 to determine the intent is needed or not
+        //Use object to indicated slotId
+        mCis[slotId].getIccCardStatus(obtainMessage(EVENT_REPOLL_SML_STATE, arg1, 0, slotId));
+    }
+
+    //Notifies when application status changes
+    public void registerForApplicationChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mApplicationChangedRegistrants.add(r);
+            //Notify registrant right after registering, so that it will get the latest application status,
+            //otherwise which may not happen until there is an actual change in application status.
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForApplicationChanged(Handler h) {
+        synchronized (mLock) {
+            mApplicationChangedRegistrants.remove(h);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UsimFileHandler.java b/src/java/com/android/internal/telephony/uicc/UsimFileHandler.java
index 612d55e..426814d 100644
--- a/src/java/com/android/internal/telephony/uicc/UsimFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/UsimFileHandler.java
@@ -35,7 +35,10 @@ public final class UsimFileHandler extends IccFileHandler implements IccConstant
     @Override
     protected String getEFPath(int efid) {
         switch(efid) {
+        case EF_ICCID:
+            return null;
         case EF_SMS:
+        case EF_SMSP:   // [ALPS01206315] Support EF_SMSP
         case EF_EXT6:
         case EF_EXT5:
         case EF_MWIS:
@@ -60,9 +63,13 @@ public final class UsimFileHandler extends IccFileHandler implements IccConstant
         case EF_CSP_CPHS:
         case EF_GID1:
         case EF_LI:
+        case EF_ECC:
         case EF_PLMNWACT:
             return MF_SIM + DF_ADF;
 
+        case EF_PSISMSC:
+            return /*MF_SIM +*/ DF_TELECOM;
+
         case EF_PBR:
             // we only support global phonebook.
             return MF_SIM + DF_TELECOM + DF_PHONEBOOK;
diff --git a/src/java/com/mediatek/internal/telephony/EtwsNotification.java b/src/java/com/mediatek/internal/telephony/EtwsNotification.java
new file mode 100644
index 0000000..064f7eb
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/EtwsNotification.java
@@ -0,0 +1,42 @@
+package com.mediatek.internal.telephony;
+
+import com.android.internal.telephony.IccUtils;
+
+public class EtwsNotification {
+    public int warningType;
+    public int messageId;
+    public int serialNumber;
+    public String plmnId;
+    public String securityInfo;
+
+    public String toString() {
+        return "EtwsNotification: " + warningType + ", " + messageId + ", " + serialNumber
+                + ", " + plmnId + ", " + securityInfo;
+    }
+
+    public boolean isDuplicatedEtws(EtwsNotification other) {
+        if (this.warningType == other.warningType
+                && this.messageId == other.messageId
+                && this.serialNumber == other.serialNumber
+                && this.plmnId.equals(other.plmnId)) {
+            return true;
+        }
+
+        return false;
+    }
+
+    public byte[] getEtwsPdu() {
+        byte[] etwsPdu = new byte[56];
+        byte[] serialNumberBytes = EtwsUtils.intToBytes(serialNumber);
+        System.arraycopy(serialNumberBytes, 2, etwsPdu, 0, 2);
+        byte[] messageIdBytes = EtwsUtils.intToBytes(messageId);
+        System.arraycopy(messageIdBytes, 2, etwsPdu, 2, 2);
+        byte[] warningTypeBytes = EtwsUtils.intToBytes(warningType);
+        System.arraycopy(warningTypeBytes, 2, etwsPdu, 4, 2);
+        if (securityInfo != null) {
+            System.arraycopy(IccUtils.hexStringToBytes(securityInfo), 0, etwsPdu, 6, 50);
+        }
+
+        return etwsPdu;
+    }
+}
\ No newline at end of file
diff --git a/src/java/com/mediatek/internal/telephony/EtwsUtils.java b/src/java/com/mediatek/internal/telephony/EtwsUtils.java
new file mode 100644
index 0000000..bed25a0
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/EtwsUtils.java
@@ -0,0 +1,31 @@
+package com.mediatek.internal.telephony;
+
+public class EtwsUtils {
+    public static final int ETWS_PDU_LENGTH = 56;
+
+    public static byte[] intToBytes(int value) {
+        byte[] ret = new byte[4];
+        for (int i = 0; i < 4; ++i) {
+            ret[3 - i] = (byte) (value & 0xff);
+            value >>= 8;
+        }
+
+        return ret;
+    }
+
+    public static int bytesToInt(byte[] values) {
+        if (values == null || values.length == 0 || values.length > 4) {
+            throw new RuntimeException("valid byte array");
+        }
+
+        int ret = 0;
+        int len = values.length - 1;
+        for (int i = 0; i < len; ++i) {
+            ret |= (values[i] & 0xff);
+            ret <<= 8;
+        }
+        ret |= (values[len] & 0xff);
+
+        return ret;
+    }
+}
\ No newline at end of file
diff --git a/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
new file mode 100755
index 0000000..2ee8f03
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.aidl
@@ -0,0 +1,19 @@
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable FemtoCellInfo;
diff --git a/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
new file mode 100755
index 0000000..173f1f2
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/FemtoCellInfo.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * {@hide}
+ */
+public class FemtoCellInfo implements Parcelable {
+    /* This CSG is Not in EFACSGL nor in EFOCSGL */
+    public static final int CSG_ICON_TYPE_NOT_ALLOWED = 0;
+
+    /* This CSG is in Allowed CSG List (EFACSGL) */
+    public static final int CSG_ICON_TYPE_ALLOWED = 1;
+
+    /* This CSG is in Operator CSG List (EFOCSGL) */
+    public static final int CSG_ICON_TYPE_OPERATOR = 2;
+
+    /* This CSG is in Operator CSGs. However, it is unauthorized, meaning that UE's registration has been rejected by cause #25.*/
+    public static final int CSG_ICON_TYPE_OPERATOR_UNAUTHORIZED = 3;
+
+    private int csgId;
+    private int csgIconType; /* FemtoCellInfo.CSG_ICON_TYPE_xxx */
+    private String homeNodeBName;
+    private String operatorNumeric; /* ex: "46000" */
+    private String operatorAlphaLong; /* ex: "China Mobile" */
+    private int rat = 0; /* ServiceState.RIL_RADIO_TECHNOLOGY_xxx */
+
+/**
+ * Get registered CSG Id
+ * @internal
+ */
+    public int getCsgId() {
+        return csgId;
+    }
+
+/**
+ * Get registered CSG Icon Type
+ * @internal
+ */
+    public int getCsgIconType() {
+        return csgIconType;
+    }
+
+/**
+ * Get Home NodeB Name(if exist)
+ * @internal
+ */
+    public String getHomeNodeBName() {
+        return homeNodeBName;
+    }
+
+/**
+ * Get registered CSG Rat information
+ */
+    public int getCsgRat() {
+        return rat;
+    }
+
+/**
+ * Get registered operator numeric code
+ */
+    public String getOperatorNumeric() {
+        return operatorNumeric;
+    }
+
+/**
+ * Get registered operator alphanumeric long name
+ * @internal
+ */
+    public String getOperatorAlphaLong() {
+        return operatorAlphaLong;
+    }
+
+    public FemtoCellInfo(int csgId, int csgIconType, String homeNodeBName, String operatorNumeric, String operatorAlphaLong, int rat) {
+        this.csgId = csgId;
+        this.csgIconType = csgIconType;
+        this.homeNodeBName = homeNodeBName;
+        this.operatorNumeric = operatorNumeric;
+        this.operatorAlphaLong = operatorAlphaLong;
+        this.rat = rat;
+    }
+
+    public String toString() {
+        return "FemtoCellInfo " + csgId
+                + "/" + csgIconType
+                + "/" + homeNodeBName
+                + "/" + operatorNumeric
+                + "/" + operatorAlphaLong
+                + "/" + rat;
+    }
+
+    /**
+     * Parcelable interface implemented below.
+     * This is a simple effort to make FemtoCellInfo parcelable rather than
+     * trying to make the conventional containing object (AsyncResult),
+     * implement parcelable.
+     */
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * Method to serialize a FemtoCellInfo object.
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(csgId);
+        dest.writeInt(csgIconType);
+        dest.writeString(homeNodeBName);
+        dest.writeString(operatorNumeric);
+        dest.writeString(operatorAlphaLong);
+        dest.writeInt(rat);
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * Method to deserialize a FemtoCellInfo object, or an array thereof.
+     */
+    public static final Creator<FemtoCellInfo> CREATOR =
+        new Creator<FemtoCellInfo>() {
+            public FemtoCellInfo createFromParcel(Parcel in) {
+                FemtoCellInfo femtoCellInfo = new FemtoCellInfo(
+                        in.readInt(), /*csgId*/
+                        in.readInt(), /*csgIconType*/
+                        in.readString(), /*homeNodeBName*/
+                        in.readString(), /*operatorNumeric*/
+                        in.readString(), /*operatorAlphaLong*/
+                        in.readInt()); /*rat*/
+                return femtoCellInfo;
+            }
+
+            public FemtoCellInfo[] newArray(int size) {
+                return new FemtoCellInfo[size];
+            }
+        };
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
new file mode 100755
index 0000000..0f0638d
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
@@ -0,0 +1,244 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+
+public class ModemSwitchHandler {
+    private static final String LOG_TAG = "PHONE";
+
+    /** @internal */
+    public static final int MD_TYPE_UNKNOWN = 0;
+    /** @internal */
+    public static final int MD_TYPE_WG      = 3;
+    /** @internal */
+    public static final int MD_TYPE_TG      = 4;
+    /** @internal */
+    public static final int MD_TYPE_LWG     = 5;
+    /** @internal */
+    public static final int MD_TYPE_LTG     = 6;
+    /** @internal */
+    public static final int MD_TYPE_FDD     = 100;
+    /** @internal */
+    public static final int MD_TYPE_TDD     = 101;
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+
+    private static int sCurrentModemType = getActiveModemType();
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static Context sContext = null;
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    public ModemSwitchHandler() {
+        logd("Constructor invoked");
+        logd("Init modem type: " + sCurrentModemType);
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+        }
+        if (PhoneFactory.getDefaultPhone() != null) {
+            sContext = PhoneFactory.getDefaultPhone().getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(int modemType) {
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        logd("protocolSim: " + protocolSim);
+        if (protocolSim >= PhoneConstants.SIM_ID_1 && protocolSim <= PhoneConstants.SIM_ID_4) {
+            switchModem(sCi[protocolSim], modemType);
+        } else {
+            switchModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type with desinated RIL instance
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(CommandsInterface ci, int modemType) {
+        logd("[switchModem]");
+        if (modemType == sCurrentModemType) {
+            if (modemType == MD_TYPE_WG) {
+                logd("Already in WG modem");
+            } else if (modemType == MD_TYPE_TG) {
+                logd("Already in TG modem");
+            } else if (modemType == MD_TYPE_LWG) {
+                logd("Already in FDD CSFB modem");
+            } else if (modemType == MD_TYPE_LTG) {
+                logd("Already in TDD CSFB modem");
+            }
+            return;
+        }
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not switch modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(9, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(10, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(11, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(12, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+            return;
+        }
+        // Update sCurrentModemType variable & set ril.active.md system property
+        setActiveModemType(modemType);
+
+        // Broadcast modem switch notification
+        logd("Broadcast intent ACTION_MD_TYPE_CHANGE");
+        Intent intent = new Intent(TelephonyIntents.ACTION_MD_TYPE_CHANGE);
+        intent.putExtra(TelephonyIntents.EXTRA_MD_TYPE, modemType);
+        sContext.sendBroadcast(intent);
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(int modemType) {
+        int majorSim = WorldPhoneUtil.getMajorSim();
+        if (majorSim >= PhoneConstants.SIM_ID_1 && majorSim <= PhoneConstants.SIM_ID_4) {
+            reloadModem(sCi[majorSim], modemType);
+        } else {
+            reloadModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+        }
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin with desinated RIL instance
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(CommandsInterface ci, int modemType) {
+        logd("[reloadModem]");
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not reload modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(14, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(15, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(16, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(17, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+        }
+    }
+
+    /**
+     * Returns current modem type
+     * @internal
+     * @return 0 : modem type is unknown
+     *         3 : switch to WG(MD_TYPE_WG)
+     *         4 : switch to TG(MD_TYPE_TG)
+     *         5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *         6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static int getActiveModemType() {
+        sCurrentModemType = Integer.valueOf(
+                SystemProperties.get(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(MD_TYPE_UNKNOWN)));
+
+        return sCurrentModemType;
+    }
+
+    public static void setActiveModemType(int modemType) {
+        SystemProperties.set(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(modemType));
+        sCurrentModemType = modemType;
+        logd("[setActiveModemType] " + modemToString(sCurrentModemType));
+    }
+
+    public static String modemToString(int modemType) {
+        String modemString;
+        if (modemType == MD_TYPE_WG) {
+            modemString = "WG";
+        } else if (modemType == MD_TYPE_TG) {
+            modemString = "TG";
+        } else if (modemType == MD_TYPE_LWG) {
+            modemString = "FDD CSFB";
+        } else if (modemType == MD_TYPE_LTG) {
+            modemString = "TDD CSFB";
+        } else if (modemType == MD_TYPE_UNKNOWN) {
+            modemString = "UNKNOWN";
+        } else {
+            modemString = "Invalid modem type";
+        }
+
+        return modemString;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[MSH]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
new file mode 100755
index 0000000..b604df8
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.aidl
@@ -0,0 +1,57 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+/**
+ * Used to indicate that the NetworkInfo object is parcelable to aidl.
+ * This is a simple effort to make NetworkInfo parcelable rather than
+ * trying to make the conventional containing object (AsyncResult),
+ * implement parcelable.  This functionality is needed for the
+ * NetworkQueryService to fix 1128695
+ */
+parcelable NetworkInfoWithAcT;
diff --git a/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
new file mode 100755
index 0000000..12d848e
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkInfoWithAcT.java
@@ -0,0 +1,201 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Entry of preferred network list in UICC card. ex: EF_PLMNSEL
+ * {@hide}
+ * @internal
+ */
+public class NetworkInfoWithAcT implements Parcelable {
+
+    String operatorAlphaName;
+    String operatorNumeric;
+
+    int nAct;
+    int nPriority; // priority is the index of the plmn in the list.
+
+
+/**
+ * Get Operator alpha name ex: Vodafone
+ * @internal
+ */
+    public String
+    getOperatorAlphaName() {
+        return operatorAlphaName;
+    }
+
+/**
+ * Get member Operator PLMN ID ex: 53001
+ * @internal
+ */
+    public String
+    getOperatorNumeric() {
+        return operatorNumeric;
+    }
+
+/**
+ * Get access techonolgy of the PLMN. It's a bitmap value.  <bit3, bit2,bit1,bit0>  =>  < E-UTRAN_Act ,UTRAN_Act,GSM_Compact_Act ,Gsm_Act >
+ * @internal
+ */
+    public int
+    getAccessTechnology() {
+        return nAct;
+    }
+
+/**
+ * Get priority, index of the PLMN in the list
+ * @internal
+ */
+    public int
+    getPriority() {
+        return nPriority;
+    }
+
+/**
+ * Set Operator alpha name ex: Vodafone
+ *
+ * @internal
+ */
+    public void
+    setOperatorAlphaName(String operatorAlphaName) {
+        this.operatorAlphaName = operatorAlphaName;
+    }
+
+/**
+ * Set member Operator PLMN ID ex: 53001
+ * @internal
+ */
+    public void
+    setOperatorNumeric(String operatorNumeric) {
+        this.operatorNumeric = operatorNumeric;
+    }
+
+/**
+ * Set access techonolgy of the PLMN. It's a bitmap value.  <bit3, bit2,bit1,bit0>  =>  < E-UTRAN_Act ,UTRAN_Act,GSM_Compact_Act ,Gsm_Act >
+ *
+ * @internal
+ */
+    public void
+    setAccessTechnology(int nAct) {
+        this.nAct = nAct;
+    }
+
+/**
+ * Set priority, index of the PLMN in the list
+ * @internal
+ */
+    public void
+    setPriority(int nIndex) {
+        this.nPriority = nIndex;
+    }
+
+    public NetworkInfoWithAcT(String operatorAlphaLong,
+                String operatorNumeric,
+                int nAct,
+                int nPriority) {
+
+        this.operatorAlphaName = operatorAlphaLong;
+        this.operatorNumeric = operatorNumeric;
+        this.nAct = nAct;
+        this.nPriority = nPriority;
+    }
+
+    public String toString() {
+        return "NetworkInfoWithAcT " + operatorAlphaName
+                + "/" + operatorNumeric
+                + "/" + nAct
+                + "/" + nPriority;
+    }
+
+    /**
+     * Parcelable interface implemented below.
+     * This is a simple effort to make NetworkInfo parcelable rather than
+     * trying to make the conventional containing object (AsyncResult),
+     * implement parcelable.  This functionality is needed for the
+     * NetworkQueryService to fix 1128695.
+     */
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * Method to serialize a NetworkInfo object.
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(operatorAlphaName);
+        dest.writeString(operatorNumeric);
+        dest.writeInt(nAct);
+        dest.writeInt(nPriority);
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * Method to deserialize a NetworkInfo object, or an array thereof.
+     */
+    public static final Creator<NetworkInfoWithAcT> CREATOR =
+        new Creator<NetworkInfoWithAcT>() {
+            public NetworkInfoWithAcT createFromParcel(Parcel in) {
+                NetworkInfoWithAcT netInfoWithAct = new NetworkInfoWithAcT(
+                        in.readString(), /*operatorAlphaLong*/
+                        in.readString(), /*operatorNumeric*/
+                        in.readInt(), /*operatorNumeric*/
+                        in.readInt()); /*state*/
+                return netInfoWithAct;
+            }
+
+            public NetworkInfoWithAcT[] newArray(int size) {
+                return new NetworkInfoWithAcT[size];
+            }
+        };
+}
diff --git a/src/java/com/mediatek/internal/telephony/NetworkManager.java b/src/java/com/mediatek/internal/telephony/NetworkManager.java
new file mode 100755
index 0000000..3b7c313
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/NetworkManager.java
@@ -0,0 +1,101 @@
+
+package com.mediatek.internal.telephony;
+
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+import android.content.Context;
+
+import com.android.internal.telephony.CommandsInterface;
+
+public class NetworkManager extends Handler  {
+    static final String LOG_TAG = "GSM";
+    private static NetworkManager sNetworkManager;
+    private Context mContext;
+    private CommandsInterface[] mCi;
+    private int mPhoneCount;
+
+    protected static final int EVENT_GET_AVAILABLE_NW = 1;
+
+    public static NetworkManager init(Context context, int phoneCount, CommandsInterface[] ci) {
+        synchronized (NetworkManager.class) {
+            if (sNetworkManager == null) {
+                sNetworkManager = new NetworkManager(context, phoneCount, ci);
+            }
+            return sNetworkManager;
+        }
+    }
+
+    public static NetworkManager getInstance() {
+        return sNetworkManager;
+    }
+
+    private NetworkManager(Context context , int phoneCount, CommandsInterface[] ci) {
+
+        log("Initialize NetworkManager under airplane mode phoneCount= " + phoneCount);
+
+        mContext = context;
+        mCi = ci;
+        mPhoneCount = phoneCount;
+    }
+
+    /**
+       * To scan all available networks. i.e. PLMN list
+       * @param Message for on complete
+       * @param simId Indicate which sim(slot) to query
+       * @internal
+       */
+    public void getAvailableNetworks(int subId, Message response) {
+    /*
+        int activeSim = -1;
+        for (int i=0; i<PhoneConstants.GEMINI_SIM_NUM;++i) {
+            if (!mGeminiDataMgr.isGprsDetached(i)) {
+                activeSim = i;
+                break;
+            }
+        }
+
+        Rlog.d(LOG_TAG, "getAvailableNetworksGemini activeSIM="+activeSim);
+
+        if (activeSim == -1 || activeSim == simId ||
+                PhoneFactory.isDualTalkMode()) {
+            getPhonebyId(simId).getAvailableNetworks(response);
+        } else {
+            PhoneBase phoneBase = getPhoneBase(activeSim);
+            if (phoneBase instanceof GSMPhone) {
+                Rlog.d(LOG_TAG, "activeSim: "  + activeSim + ", simId: " + simId);
+                mActiveApnTypes = getActiveApnTypesGemini(activeSim);
+                mGeminiDataMgr.cleanupAllConnection(activeSim);
+            }
+            mGettingAvailableNetwork = true;
+            Message msg = obtainMessage(EVENT_GET_AVAILABLE_NW);
+            msg.arg1 = activeSim;
+            msg.arg2 = simId;
+            msg.obj = response;
+            mGeminiDataMgr.registerForDetached(activeSim, this, EVENT_GPRS_DETACHED, msg);
+        }
+        */
+        return;
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        switch (msg.what) {
+            case EVENT_GET_AVAILABLE_NW:
+                synchronized (this) {
+
+                }
+                break;
+
+            default:
+                log("Unhandled message with number: " + msg.what);
+                break;
+        }
+    }
+
+    private static void log(String s) {
+        Log.d(LOG_TAG, "[NetworkManager] " + s);
+    }
+}
+
+
diff --git a/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java b/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
new file mode 100755
index 0000000..28c9bd0
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/RadioCapabilitySwitchUtil.java
@@ -0,0 +1,310 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.SystemProperties;
+
+import android.telephony.PhoneRatFamily;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+
+import java.util.Arrays;
+
+/**
+ * Utility for capability switch.
+ *
+ */
+public class RadioCapabilitySwitchUtil {
+    private static final String LOG_TAG = "GSM";
+
+    public static final int SIM_OP_INFO_OVERSEA = 0;
+    public static final int SIM_OP_INFO_OP01 = 1;
+    public static final int SIM_OP_INFO_OP02 = 2;
+
+    public static final int SIM_TYPE_SIM = 0;
+    public static final int SIM_TYPE_USIM = 1;
+    public static final int SIM_TYPE_OTHER = 2;
+
+    public static final String MAIN_SIM_PROP = "persist.radio.simswitch.iccid";
+    private static final String PROPERTY_ICCID = "ril.iccid.sim";
+    // OP01 SIMs
+    private static final String[] PLMN_TABLE_TYPE1 = {
+        "46000", "46002", "46007", "46008", "46011",
+        // Lab test IMSI
+        "00101", "00211", "00321", "00431", "00541", "00651",
+        "00761", "00871", "00902", "01012", "01122", "01232",
+        "46004", "46602", "50270", "46003"
+    };
+
+    // non-OP01 SIMs
+    private static final String[] PLMN_TABLE_TYPE3 = {
+        "46001", "46006", "46009", "45407",
+        "46005", "45502"
+    };
+
+    /**
+     * Update current main protocol ICCID.
+     *
+     * @param mProxyPhones Phone array for all phones
+     */
+    public static void updateIccid(Phone[] mProxyPhones) {
+        for (int i = 0; i < mProxyPhones.length; i++) {
+            if ((mProxyPhones[i].getPhoneRatFamily() & PhoneRatFamily.PHONE_RAT_FAMILY_3G)
+                    == PhoneRatFamily.PHONE_RAT_FAMILY_3G) {
+                String currIccId = SystemProperties.get(PROPERTY_ICCID + (i + 1));
+                SystemProperties.set(MAIN_SIM_PROP, currIccId);
+                logd("updateIccid " + currIccId);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Get all SIMs operator and type.
+     *
+     * @param simOpInfo SIM operator info
+     * @param simType SIM type
+     */
+    public static void getSimInfo(int[] simOpInfo, int[] simType) {
+        String[] strMnc = new String[simOpInfo.length];
+        String[] strSimType = new String[simOpInfo.length];
+        String propStr;
+
+        for (int i = 0; i < simOpInfo.length; i++) {
+            if (i == 0) {
+                propStr = "gsm.ril.uicctype";
+            } else {
+                propStr = "gsm.ril.uicctype." + (i + 1);
+            }
+            strSimType[i] = SystemProperties.get(propStr, "");
+            if (strSimType[i].equals("SIM")) {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_SIM;
+            } else if (strSimType[i].equals("USIM")) {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_USIM;
+            } else {
+                simType[i] = RadioCapabilitySwitchUtil.SIM_TYPE_OTHER;
+            }
+            logd("SimType[" + i + "]= " + strSimType[i] + ", simType[" + i + "]=" + simType[i]);
+            final int tmpMnc = TelephonyManager.getTelephonyProperty("gsm.sim.operator.numeric",
+                    SubscriptionManager.getSubId(i)[0], -1);  // getSubIdUsingPhoneId not implemented
+			strMnc[i] = tmpMnc < 0 ? "" : Integer.toString(tmpMnc);
+            logd("strMnc[" + i + "] from operator.numeric:" + strMnc[i]);
+            if (strMnc[i].equals("")) {
+                if (i == 0) {
+                    propStr = "gsm.sim.ril.mcc.mnc";
+                } else {
+                    propStr = "gsm.sim.ril.mcc.mnc." + (i + 1);
+                }
+                strMnc[i] = SystemProperties.get(propStr, "");
+                logd("strMnc[" + i + "] from ril.mcc.mnc:" + strMnc[i]);
+            }
+            for (String mccmnc : PLMN_TABLE_TYPE1) {
+                if (strMnc[i].equals(mccmnc)) {
+                    simOpInfo[i] = SIM_OP_INFO_OP01;
+					// MTK, just why didn't you break
+					break;
+                }
+            }
+            for (String mccmnc : PLMN_TABLE_TYPE3) {
+                if (strMnc[i].equals(mccmnc)) {
+                    simOpInfo[i] = SIM_OP_INFO_OP02;
+					break;
+                }
+            }
+            logd("strMnc[" + i + "]= " + strMnc[i] + ", simOpInfo[" + i + "]=" + simOpInfo[i]);
+        }
+        logd("getSimInfo(simOpInfo): " + Arrays.toString(simOpInfo));
+        logd("getSimInfo(simType): " + Arrays.toString(simType));
+    }
+
+    /**
+     * Check if need to switch capability.
+     *
+     * @param mProxyPhones Phone array for all phones
+     * @param rats new capability for phones
+     * @return ture or false
+     */
+    public static boolean isNeedSwitchInOpPackage(Phone[] mProxyPhones, PhoneRatFamily[] rats) {
+        String operatorSpec = SystemProperties.get("ro.operator.optr", "");
+        int[] simOpInfo = new int[mProxyPhones.length];
+        int[] simType = new int[mProxyPhones.length];
+
+        logd("Operator Spec:" + operatorSpec);
+		// TODO: fix OP01 and OP02
+		return true;
+
+		/*
+        if (operatorSpec.equals("OP02")) {
+            // disable capability switch in op02 package
+            return false;
+        } else if (operatorSpec.equals("OP01")) {
+            // handle later
+        } else {
+            // OM package, default enable
+            return true;
+        }
+        getSimInfo(simOpInfo, simType);
+        // find target phone ID
+        int targetPhoneId;
+        for (targetPhoneId = 0; targetPhoneId < rats.length; targetPhoneId++) {
+            if ((rats[targetPhoneId].getRatFamily() & PhoneRatFamily.PHONE_RAT_FAMILY_3G)
+                == PhoneRatFamily.PHONE_RAT_FAMILY_3G) {
+                break;
+            }
+        }
+        if (operatorSpec.equals("OP01")) {
+            return checkOp01(targetPhoneId, simOpInfo, simType);
+        } else {
+            return true;
+        }
+		*/
+    }
+
+    /**
+     * Check if any higher priority SIM exists.
+     *
+     * @param curId current phone ID uses main capability
+     * @param op01Usim array to indicate if op01 USIM
+     * @param op01Sim array to indicate if op01 SIM
+     * @param overseaUsim array to indicate if oversea USIM
+     * @param overseaSim array to indicate if oversea SIM
+     * @return higher priority SIM ID
+     */
+	/*
+    public static int getHigherPrioritySimForOp01(int curId, boolean[] op01Usim, boolean[] op01Sim
+            , boolean[] overseaUsim, boolean[] overseaSim) {
+        int targetSim = -1;
+        int phoneNum = op01Usim.length;
+
+        if (op01Usim[curId] == true) {
+            return curId;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (op01Usim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || op01Sim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (op01Sim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || overseaUsim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (overseaUsim[i] == true) {
+                targetSim = i;
+            }
+        }
+        if (targetSim != -1 || overseaSim[curId] == true) {
+            return targetSim;
+        }
+        for (int i = 0; i < phoneNum; i++) {
+            if (overseaSim[i] == true) {
+                targetSim = i;
+            }
+        }
+        return targetSim;
+    }
+
+    private static boolean checkOp01(int targetPhoneId, int[] simOpInfo, int[] simType) {
+        int curPhoneId = Integer.valueOf(
+                SystemProperties.get(PhoneConstants.CAPABILITY_SWITCH_PROP, "1")) - 1;
+
+        logd("checkOp01 : curPhoneId: " + curPhoneId);
+        if (simOpInfo[targetPhoneId] == SIM_OP_INFO_OP01) {
+            if (simType[targetPhoneId] == SIM_TYPE_SIM) {
+                if ((simOpInfo[curPhoneId] == SIM_OP_INFO_OP01)
+                    && simType[curPhoneId] != SIM_TYPE_SIM) {
+                    logd("checkOp01 : case 1,2; stay in current phone");
+                    return false;
+                } else {
+                    // case 3: op01-SIM + op01-SIM
+                    // case 4: op01-SIM + others
+                    logd("checkOp01 : case 3,4");
+                    return true;
+                }
+            } else { // USIM, ISIM...
+                // case 1: op01-USIM + op01-USIM
+                // case 2: op01-USIM + others
+                logd("checkOp01 : case 1,2");
+                return true;
+            }
+        } else if (simOpInfo[targetPhoneId] == SIM_OP_INFO_OVERSEA) {
+            if (simOpInfo[curPhoneId] == SIM_OP_INFO_OP01) {
+                logd("checkOp01 : case 1,2,3,4; stay in current phone");
+                return false;
+            } else if (simType[targetPhoneId] == SIM_TYPE_SIM) {
+                if ((simOpInfo[curPhoneId] == SIM_OP_INFO_OVERSEA)
+                    && simType[curPhoneId] != SIM_TYPE_SIM) {
+                    logd("checkOp01 : case 5,6; stay in current phone");
+                    return false;
+                } else {
+                    // case 7: non-China SIM + non-China SIM
+                    // case 8: non-China SIM + others
+                    logd("checkOp01 : case 7,8");
+                    return true;
+                }
+            } else { // USIM, ISIM...
+                // case 5: non-China USIM + non-China USIM
+                // case 6: non-China USIM + others
+                logd("checkOp01 : case 5,6");
+                return true;
+            }
+        } else {
+            // case 9: non-op01 USIM/SIM + non-op01 USIM/SIM
+            logd("checkOp01 : case 9");
+            return false;
+        }
+    }
+	*/
+
+    private static void logd(String s) {
+        Log.d(LOG_TAG, "[RadioCapSwitchUtil] " + s);
+    }
+}
+
+
diff --git a/src/java/com/mediatek/internal/telephony/dataconnection/FdManager.java b/src/java/com/mediatek/internal/telephony/dataconnection/FdManager.java
new file mode 100755
index 0000000..4063293
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/dataconnection/FdManager.java
@@ -0,0 +1,421 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.internal.telephony.dataconnection;
+
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.os.AsyncResult;
+import android.os.BatteryManager;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.gsm.GSMPhone;
+
+//import com.mediatek.settings.FeatureOption;
+//import com.mediatek.common.featureoption.FeatureOption;
+
+import java.util.ArrayList;
+
+public class FdManager extends Handler {
+    // M:Fast Dormancy Manager
+    protected static final boolean DBG = true;
+    protected static final String LOG_TAG = "FdManager";
+    protected static final String PROPERTY_3G_SWITCH = "gsm.3gswitch";
+    protected static final String PROPERTY_MTK_FD_SUPPORT = "ro.mtk_fd_support";
+    protected static final String PROPERTY_RIL_FD_MODE = "ril.fd.mode";
+    protected static final String PROPERTY_FD_ON_CHARGE = "fd.on.charge";
+    protected static final String PROPERTY_FD_SCREEN_OFF_ONLY = "fd.screen.off.only";
+    private static final String STR_PROPERTY_FD_SCREEN_ON_TIMER = "persist.radio.fd.counter";
+    private static final String STR_PROPERTY_FD_SCREEN_ON_R8_TIMER = "persist.radio.fd.r8.counter";
+    private static final String STR_PROPERTY_FD_SCREEN_OFF_TIMER = "persist.radio.fd.off.counter";
+    private static final String
+            STR_PROPERTY_FD_SCREEN_OFF_R8_TIMER = "persist.radio.fd.off.r8.counter";
+
+    private static final int BASE = 0;
+    private static final int EVENT_FD_MODE_SET = BASE + 0;
+
+    public enum FdModeType {
+        DISABLE_MD_FD,
+        ENABLE_MD_FD,
+        SET_FD_INACTIVITY_TIMER,
+        INFO_MD_SCREEN_STATUS
+    }
+
+    public enum FdTimerType {
+        ScreenOffLegacyFd,
+        ScreenOnLegacyFd,
+        ScreenOffR8Fd,
+        ScreenOnR8Fd,
+        SupportedTimerTypes
+    }
+
+    private static final SparseArray<FdManager> sFdManagers = new SparseArray<FdManager>();
+
+    private PhoneBase mPhone;
+    private boolean mChargingMode = false;
+    private boolean mIsTetheredMode = false;
+    private int mEnableFdOnCharging = 0;
+    private boolean mIsScreenOn = true;
+    private static int numberOfSupportedTypes;
+    private static String timerValue[] = {"50", "150", "50", "150"};
+    //Time Unit:0.1 sec => {5sec, 15sec, 5sec, 15sec}
+
+    protected BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (DBG) logd("onReceive: action=" + action);
+            int fdMdEnableMode = Integer.parseInt(SystemProperties.get(PROPERTY_RIL_FD_MODE, "0"));
+            int fdSimId = SystemProperties.getInt(PROPERTY_3G_SWITCH, 1) - 1;
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                mIsScreenOn = true;
+                if (isFdSupport()) {
+                    if (DBG) logd("fdMdEnableMode=" + fdMdEnableMode + ", 3gSimID="
+                            + fdSimId + ", when switching to SCREEN ON");
+                    mIsScreenOn = true;
+                    if (fdMdEnableMode == 1) {
+                        //fdMdEnableMode == 1: It means that the Fast Dormancy polling
+                        //                                  & decision mechanism is implemented by modem side
+                        if (mPhone.getPhoneId() == fdSimId) {
+                            mPhone.mCi.setFDMode(FdModeType.INFO_MD_SCREEN_STATUS.ordinal(), 1, -1,
+                                    obtainMessage(EVENT_FD_MODE_SET));
+
+                            if (isFdScreenOffOnly()) {
+                                if (DBG) {
+                                    logd("Because FD_SCREEN_OFF_ONLY, disable fd when screen on.");
+                                }
+                                updateFdMdEnableStatus(false);
+                            }
+                        }
+                    } else {
+                        logd("Not Support AP-trigger FD now");
+                    }
+                }
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                mIsScreenOn = false;
+                if (isFdSupport()) {
+                    if (fdMdEnableMode == 1) {
+                        if (DBG) logd("fdMdEnableMode=" + fdMdEnableMode + ", 3gSimID="
+                                + fdSimId + ", when switching to SCREEN OFF");
+                        if (mPhone.getPhoneId() == fdSimId) {
+                            mPhone.mCi.setFDMode(FdModeType.INFO_MD_SCREEN_STATUS.ordinal(), 0, -1,
+                                    obtainMessage(EVENT_FD_MODE_SET));
+
+                            if (isFdScreenOffOnly() && checkNeedTurnOn()) {
+                                if (DBG) {
+                                    logd("Because FD_SCREEN_OFF_ONLY, turn on fd when screen off.");
+                                }
+                                updateFdMdEnableStatus(true);
+                            }
+                        }
+                    } else {
+                        logd("Not Support AP-trigger FD now");
+                    }
+                }
+            } else if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
+                if (isFdSupport()){
+                    int status = intent.getIntExtra("status", 0);
+                    int plugged = intent.getIntExtra("plugged", 0);
+                    boolean previousChargingMode = mChargingMode;
+
+                    String sChargingModeStr = "", sPluggedStr = "";
+                    mChargingMode = status == BatteryManager.BATTERY_STATUS_CHARGING;
+                    sChargingModeStr = mChargingMode ? "Charging" : "Non-Charging";
+
+                    if (plugged == BatteryManager.BATTERY_PLUGGED_AC) {
+                        sPluggedStr="Plugged in AC";
+                    } else if (plugged == BatteryManager.BATTERY_PLUGGED_USB) {
+                        sPluggedStr="Plugged in USB";
+                    }
+
+                    if ((plugged == BatteryManager.BATTERY_PLUGGED_AC)
+                            || (plugged == BatteryManager.BATTERY_PLUGGED_USB)) {
+                        mChargingMode = true;
+                    }
+
+                    int previousEnableFDOnCharging = mEnableFdOnCharging;
+                    mEnableFdOnCharging =
+                            Integer.parseInt(SystemProperties.get(PROPERTY_FD_ON_CHARGE, "0"));
+
+                    if ((previousChargingMode != mChargingMode)
+                            || (previousEnableFDOnCharging != mEnableFdOnCharging)) {
+                        if (DBG) logd("fdMdEnableMode=" + fdMdEnableMode + ", 3gSimID="
+                                + fdSimId + ", when charging state is changed");
+                        if (DBG) logd("previousEnableFdOnCharging=" + previousEnableFDOnCharging
+                                + ", mEnableFdOnCharging=" + mEnableFdOnCharging
+                                + ", when charging state is changed");
+                        if (DBG) logd("previousChargingMode=" + previousChargingMode
+                                + ", mChargingMode=" + mChargingMode + ", status=" + status
+                                + "(" + sPluggedStr + ")");
+                    }
+
+
+                    if (fdMdEnableMode == 1) {
+                        if (mPhone.getPhoneId() == fdSimId) {
+                            if ((previousChargingMode != mChargingMode)
+                                    || (previousEnableFDOnCharging != mEnableFdOnCharging)) {
+                                updateFdMdEnableStatus(checkNeedTurnOn());
+                            }
+                        }
+                    }
+                }
+            } else if (action.equals(ConnectivityManager.ACTION_TETHER_STATE_CHANGED)) {
+                if (isFdSupport()){
+                    logd("Received ConnectivityManager.ACTION_TETHER_STATE_CHANGED");
+                    ArrayList<String> active =
+                            intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
+                    mIsTetheredMode = ((active != null) && (active.size() > 0));
+                    logd("[TETHER_STATE_CHANGED]mIsTetheredMode = " + mIsTetheredMode
+                            + "mChargingMode=" + mChargingMode);
+                    updateFdMdEnableStatus(checkNeedTurnOn());
+                }
+            }
+        }
+    };
+
+
+    public static FdManager getInstance(PhoneBase phone) {
+        if (isFdSupport()) {
+            if (phone.getPhoneId() < 0) {
+                Rlog.e(LOG_TAG, "phoneId " + phone.getPhoneId() + " is invalid!");
+                return null;
+            }
+            FdManager fdMgr = sFdManagers.get(phone.getPhoneId());
+            if (fdMgr == null) {
+                //PhoneBase phone = (PhoneBase) PhoneFactory.getPhone(phone.getPhoneId());
+                if (phone != null) {
+                    Rlog.d(LOG_TAG, "FDManager for phoneId:" + phone.getPhoneId()
+                            + " doesn't exist, create it");
+                    fdMgr = new FdManager(phone);
+                    sFdManagers.put(phone.getPhoneId(), fdMgr);
+                } else {
+                    Rlog.e(LOG_TAG, "FDManager for phoneId:" + phone.getPhoneId()
+                            + " can't get phone to init!");
+                }
+            }
+            return fdMgr;
+        }
+        return null;
+    }
+
+    private FdManager(PhoneBase p) {
+        mPhone = p;
+        logd("FastDormancyManager init");
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_BATTERY_CHANGED);
+        filter.addAction(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
+        mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
+
+        initFdTimer();
+
+    }
+
+    public void dispose() {
+        if (DBG) logd("FD.dispose");
+        if (isFdSupport()) {
+            mPhone.getContext().unregisterReceiver(this.mIntentReceiver);
+            sFdManagers.remove(mPhone.getPhoneId());
+        }
+    }
+
+    private void initFdTimer() {
+        String timerStr[] = new String[4];
+        timerStr[0] = SystemProperties.get(STR_PROPERTY_FD_SCREEN_OFF_TIMER, "5");
+        timerValue[FdTimerType.ScreenOffLegacyFd.ordinal()] =
+                Integer.toString((int)(Double.parseDouble(timerStr[0])*10));
+        timerStr[1] = SystemProperties.get(STR_PROPERTY_FD_SCREEN_ON_TIMER, "15");
+        timerValue[FdTimerType.ScreenOnLegacyFd.ordinal()] =
+                Integer.toString((int)(Double.parseDouble(timerStr[1])*10));
+        timerStr[2] = SystemProperties.get(STR_PROPERTY_FD_SCREEN_OFF_R8_TIMER, "5");
+        timerValue[FdTimerType.ScreenOffR8Fd.ordinal()] =
+                Integer.toString((int)(Double.parseDouble(timerStr[2])*10));
+        timerStr[3] = SystemProperties.get(STR_PROPERTY_FD_SCREEN_ON_R8_TIMER, "15");
+        timerValue[FdTimerType.ScreenOnR8Fd.ordinal()] =
+                Integer.toString((int)(Double.parseDouble(timerStr[3])*10));
+        logd("Default FD timers=" + timerValue[0] + "," + timerValue[1] + ","
+                + timerValue[2] + "," + timerValue[3]);
+
+    }
+
+    public int getNumberOfSupportedTypes() {
+        return FdTimerType.SupportedTimerTypes.ordinal();
+    }
+
+    /**
+       * setFdTimerValue
+       * @param String array for new Timer Value
+       * @param Message for on complete
+       */
+    public int setFdTimerValue(String newTimerValue[], Message onComplete) {
+        int fdMdEnableMode = Integer.parseInt(SystemProperties.get(PROPERTY_RIL_FD_MODE, "0"));
+        int fdSimId = SystemProperties.getInt(PROPERTY_3G_SWITCH, 1) - 1;
+        if (isFdSupport() && fdMdEnableMode == 1 && mPhone.getPhoneId() == fdSimId) {
+            // TODO: remove FeatureOption
+            for (int i=0; i < newTimerValue.length; i++) {
+                timerValue[i] = newTimerValue[i];
+            }
+            mPhone.mCi.setFDMode(FdModeType.SET_FD_INACTIVITY_TIMER.ordinal(),
+                    FdTimerType.ScreenOffLegacyFd.ordinal(),
+                    Integer.parseInt(timerValue[FdTimerType.ScreenOffLegacyFd.ordinal()]), null);
+            mPhone.mCi.setFDMode(FdModeType.SET_FD_INACTIVITY_TIMER.ordinal(),
+                    FdTimerType.ScreenOnLegacyFd.ordinal(),
+                    Integer.parseInt(timerValue[FdTimerType.ScreenOnLegacyFd.ordinal()]), null);
+            mPhone.mCi.setFDMode(FdModeType.SET_FD_INACTIVITY_TIMER.ordinal(),
+                    FdTimerType.ScreenOffR8Fd.ordinal(),
+                    Integer.parseInt(timerValue[FdTimerType.ScreenOffR8Fd.ordinal()]), null);
+            mPhone.mCi.setFDMode(FdModeType.SET_FD_INACTIVITY_TIMER.ordinal(),
+                    FdTimerType.ScreenOnR8Fd.ordinal(),
+                    Integer.parseInt(timerValue[FdTimerType.ScreenOnR8Fd.ordinal()]), onComplete);
+            logd("Set Default FD timers=" + timerValue[0] + "," + timerValue[1] + ","
+                    + timerValue[2] + "," + timerValue[3]);
+        }
+        return 0;
+    }
+
+    /**
+       * setFdTimerValue
+       * @param String array for new Timer Value
+       * @param Message for on complete
+       * @param PhoneBase for input context
+       */
+    public int setFdTimerValue(String newTimerValue[], Message onComplete, PhoneBase phone) {
+        FdManager fdMgr = getInstance(phone);
+        if (fdMgr != null) {
+            fdMgr.setFdTimerValue(newTimerValue, onComplete);
+        } else {
+            logd("setFDTimerValue fail!");
+        }
+        return 0;
+    }
+
+    /**
+       * getFdTimerValue
+       * @return FD Timer String array
+       */
+    public static String[] getFdTimerValue() {
+        return timerValue;
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        switch (msg.what) {
+            case EVENT_FD_MODE_SET:
+                ar = (AsyncResult) msg.obj;
+                if (ar.exception != null) {
+                    if (DBG) logd("SET_FD_MODE ERROR");
+                }
+                break;
+            default:
+                Rlog.e("FdManager", "Unidentified event msg=" + msg);
+                break;
+        }
+    }
+
+    private void updateFdMdEnableStatus(boolean enabled) {
+        int fdMdEnableMode = Integer.parseInt(SystemProperties.get(PROPERTY_RIL_FD_MODE, "0"));
+        int fdSimId = SystemProperties.getInt(PROPERTY_3G_SWITCH, 1) - 1;
+        if (DBG) logd("updateFdMdEnableStatus(): enabled=" + enabled + ",fdMdEnableMode="
+                + fdMdEnableMode + ", 3gSimID=" + fdSimId);
+        if (fdMdEnableMode == 1 && mPhone.getPhoneId() == fdSimId) {
+            if (enabled) {
+                mPhone.mCi.setFDMode(FdModeType.ENABLE_MD_FD.ordinal(), -1, -1,
+                        obtainMessage(EVENT_FD_MODE_SET));
+            } else {
+                mPhone.mCi.setFDMode(FdModeType.DISABLE_MD_FD.ordinal(), -1, -1,
+                        obtainMessage(EVENT_FD_MODE_SET));
+            }
+        }
+    }
+
+    // TODO: check onRecordsLoaded
+    public void disableFdWhenTethering() {
+        if (isFdSupport()) {
+            ConnectivityManager connMgr = (ConnectivityManager) mPhone.getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+            if ((connMgr != null) && (connMgr.getTetheredIfaces() != null)) {
+               mIsTetheredMode = (connMgr.getTetheredIfaces().length > 0);
+            }
+
+           logd("mIsTetheredMode = " + mIsTetheredMode + "mChargingMode=" + mChargingMode);
+           updateFdMdEnableStatus(checkNeedTurnOn());
+        }
+    }
+
+    /**
+     * checkNeedTurnOn.
+     * when Fd Screen Off only mode, check screen state to make sure the turn on or not
+     * @return boolean need or not
+     */
+    private boolean checkNeedTurnOn() {
+        return (!(isFdScreenOffOnly() && mIsScreenOn) &&
+            !(mChargingMode && (mEnableFdOnCharging == 0)) &&
+            !mIsTetheredMode);
+    }
+
+    public static boolean isFdScreenOffOnly() {
+        return SystemProperties.getInt(PROPERTY_FD_SCREEN_OFF_ONLY, 0) == 1;
+    }
+
+    public static boolean isFdSupport() {
+        return SystemProperties.getInt(PROPERTY_MTK_FD_SUPPORT, 1) == 1;
+    }
+
+    protected void logd(String s) {
+        Rlog.d(LOG_TAG, "[GDCT][phoneId" + mPhone.getPhoneId() + "]"+ s);
+    }
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java b/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java
new file mode 100755
index 0000000..4ba67ac
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony.uicc;
+
+
+import static android.Manifest.permission.READ_PHONE_STATE;
+import android.app.ActivityManagerNative;
+import android.content.Context;
+import android.content.Intent;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.UserHandle;
+
+import android.telephony.TelephonyManager;
+import android.telephony.SubscriptionManager;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.IccCardConstants.State;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccFileHandler;
+import com.android.internal.telephony.uicc.IccCardStatus;
+import com.android.internal.telephony.uicc.IccCardStatus.CardState;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
+import com.android.internal.telephony.PhoneConstants;
+
+/**
+ * @Deprecated use {@link UiccController}.getUiccCard instead.
+ *
+ * The Phone App assumes that there is only one icc card, and one icc application
+ * available at a time. Moreover, it assumes such object (represented with IccCard)
+ * is available all the time (whether {@link RILConstants.RIL_REQUEST_GET_SIM_STATUS} returned
+ * or not, whether card has desired application or not, whether there really is a card in the
+ * slot or not).
+ *
+ * UiccController, however, can handle multiple instances of icc objects (multiple
+ * {@link UiccCardApplication}, multiple {@link IccFileHandler}, multiple {@link IccRecords})
+ * created and destroyed dynamically during phone operation.
+ *
+ * This class implements the IccCard interface that is always available (right after default
+ * phone object is constructed) to expose the current (based on voice radio technology)
+ * application on the uicc card, so that external apps won't break.
+ */
+
+public class IccCardProxyEx extends Handler {
+    private static final boolean DBG = true;
+    private static final String LOG_TAG = "IccCardProxyEx";
+
+    private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 1;
+    private static final int EVENT_ICC_CHANGED = 2;
+    private static final int EVENT_APP_READY = 3;
+    private static final int EVENT_RECORDS_LOADED = 4;
+
+    private final Object mLock = new Object();
+    private Context mContext;
+    private CommandsInterface mCi;
+
+    private static final int APPLICATION_ID_ISIM = 0;
+    private static final int APPLICATION_ID_MAX = 1;
+
+    private int mCurrentAppType = UiccController.APP_FAM_IMS;
+    private UiccController mUiccController = null;
+
+    private UiccCard mUiccCard = null;
+    private UiccCardApplication[] mUiccApplication =
+        new UiccCardApplication[IccCardStatus.CARD_MAX_APPS];
+    private IccRecords[] mIccRecords =
+        new IccRecords[IccCardStatus.CARD_MAX_APPS];
+
+    private State[] mExternalState = new State[]{State.UNKNOWN};
+    private int mSlotId;
+
+    public IccCardProxyEx(Context context, CommandsInterface ci) {
+        this(context, ci, PhoneConstants.SIM_ID_1);
+    }
+
+    public IccCardProxyEx(Context context, CommandsInterface ci, int slotId) {
+        this.mContext = context;
+        this.mCi = ci;
+        // FIXME: slotId or phoneId?
+        mSlotId = slotId;
+
+        Integer index = new Integer(mSlotId);
+        mUiccController = UiccController.getInstance();
+        ci.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_UNAVAILABLE, index);
+        mUiccController.registerForApplicationChanged(this, EVENT_ICC_CHANGED, index);
+
+        setExternalState(State.NOT_READY, 0);
+        log("Creating");
+    }
+
+    public void dispose() {
+        synchronized (mLock) {
+            log("Disposing");
+            //Cleanup icc references
+            mCi.unregisterForOffOrNotAvailable(this);
+            mUiccController.unregisterForApplicationChanged(this);
+            mUiccController = null;
+        }
+    }
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        int appId;
+        log("receive message " + msg.what);
+
+        Integer index = getIndex(msg);
+
+        if (index < 0 || index >= TelephonyManager.getDefault().getPhoneCount() || index != mSlotId) {
+            loge("Invalid index : " + index + " received with event " + msg.what);
+            return;
+        }
+
+        switch (msg.what) {
+            case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                for (int i = 0; i < APPLICATION_ID_MAX; i++) {
+                    setExternalState(State.NOT_READY, i);
+                }
+                break;
+
+            case EVENT_ICC_CHANGED:
+                updateIccAvailability(0);
+                break;
+
+            case EVENT_APP_READY:
+                ar = (AsyncResult) (msg.obj);
+                appId = ((Integer) ar.userObj).intValue();
+                setExternalState(State.READY, appId);
+                break;
+
+            case EVENT_RECORDS_LOADED:
+                ar = (AsyncResult) (msg.obj);
+                appId = ((Integer) ar.userObj).intValue();
+                broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_LOADED, null, appId);
+
+                break;
+            default:
+                loge("Unhandled message with number: " + msg.what);
+                break;
+        }
+    }
+
+    private void updateIccAvailability(int appId) {
+        synchronized (mLock) {
+            UiccCard newCard = mUiccController.getUiccCard();
+            CardState state = CardState.CARDSTATE_ABSENT;
+            UiccCardApplication newApp = null;
+            IccRecords newRecords = null;
+            int appType = 0;
+
+            switch(appId) {
+                case 0:
+                    appType = UiccController.APP_FAM_IMS;
+                    break;
+                default:
+                    break;
+            }
+
+            if (newCard != null) {
+                state = newCard.getCardState();
+                newApp = newCard.getApplication(appType);
+                if (newApp != null) {
+                    newRecords = newApp.getIccRecords();
+                }
+            }
+
+            if (mIccRecords[appId] != newRecords || mUiccApplication[appId] != newApp || mUiccCard != newCard) {
+                if (DBG) log("Icc changed. Reregestering.");
+                unregisterUiccCardEvents(appId);
+                mUiccCard = newCard;
+                mUiccApplication[appId] = newApp;
+                mIccRecords[appId] = newRecords;
+                registerUiccCardEvents(appId);
+            }
+
+            updateExternalState(appId);
+        }
+    }
+
+    private void updateExternalState(int appId) {
+
+        if (mUiccCard == null) {
+            setExternalState(State.NOT_READY, appId);
+            return;
+        } else if (mUiccCard.getCardState() == CardState.CARDSTATE_ABSENT) {
+            setExternalState(State.ABSENT, appId);
+            return;
+        }
+
+        if (DBG) log("CardState = " + mUiccCard.getCardState());
+
+        if (mUiccCard.getCardState() == CardState.CARDSTATE_ERROR ||
+                mUiccApplication[appId] == null) {
+            setExternalState(State.UNKNOWN, appId);
+            return;
+        }
+
+        if (DBG) log("application state = " + mUiccApplication[appId].getState());
+        if (DBG) log("mUiccApplication[appId] = " + mUiccApplication[appId]);
+
+        switch (mUiccApplication[appId].getState()) {
+            case APPSTATE_UNKNOWN:
+            case APPSTATE_DETECTED:
+                setExternalState(State.UNKNOWN, appId);
+                break;
+            case APPSTATE_READY:
+                setExternalState(State.READY, appId);
+                break;
+        }
+    }
+
+    private void registerUiccCardEvents(int appId) {
+        Integer aid = new Integer(appId);
+        if (mUiccApplication[appId] != null) {
+            mUiccApplication[appId].registerForReady(this, EVENT_APP_READY, (Object) aid);
+        }
+        if (mIccRecords[appId] != null) {
+            mIccRecords[appId].registerForRecordsLoaded(this, EVENT_RECORDS_LOADED, (Object) aid);
+        }
+    }
+
+    private void unregisterUiccCardEvents(int appId) {
+        if (mUiccApplication[appId] != null) mUiccApplication[appId].unregisterForReady(this);
+        if (mIccRecords[appId] != null) mIccRecords[appId].unregisterForRecordsLoaded(this);
+    }
+
+    private void broadcastIccStateChangedIntent(String value, String reason, int appId) {
+        synchronized (mLock) {
+
+            Intent intent = new Intent(TelephonyIntents.ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION);
+            intent.putExtra(PhoneConstants.PHONE_NAME_KEY, "Phone");
+            intent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, value);
+            intent.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
+            // FIXME: putPhoneIdAndSubIdExtra is phone based API, slot id might not equal to phone id.
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mSlotId);
+            intent.putExtra("appId", appId);
+            if (DBG) log("Broadcasting intent ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION " +  value
+                    + " reason " + reason + " slotd id " + mSlotId + " app id " + appId);
+            ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE,
+                    UserHandle.USER_ALL);
+        }
+    }
+
+    private void setExternalState(State newState, boolean override, int appId) {
+        synchronized (mLock) {
+            if (DBG) log("setExternalState(): mExternalState = " + mExternalState[appId] +
+                " newState =  " + newState + " override = " + override);
+
+            if (!override && newState == mExternalState[appId]) {
+                return;
+            }
+
+            mExternalState[appId] = newState;
+
+            broadcastIccStateChangedIntent(getIccStateIntentString(mExternalState[appId]),
+                    getIccStateReason(mExternalState[appId], appId), appId);
+        }
+    }
+
+    private void setExternalState(State newState, int appId) {
+        if (DBG) log("setExternalState(): newState =  " + newState + "appId = " + appId);
+        setExternalState(newState, false, appId);
+    }
+
+    private String getIccStateIntentString(State state) {
+        switch (state) {
+            case ABSENT: return IccCardConstants.INTENT_VALUE_ICC_ABSENT;
+            case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case PERSO_LOCKED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case READY: return IccCardConstants.INTENT_VALUE_ICC_READY;
+            case NOT_READY: return IccCardConstants.INTENT_VALUE_ICC_NOT_READY;
+            case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            default: return IccCardConstants.INTENT_VALUE_ICC_UNKNOWN;
+        }
+    }
+
+    /**
+     * Locked state have a reason (PIN, PUK, NETWORK, PERM_DISABLED)
+     * @return reason
+     */
+    private String getIccStateReason(State state, int appId) {
+        switch (state) {
+            case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
+            case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
+            case PERSO_LOCKED:
+                switch (mUiccApplication[appId].getPersoSubState()) {
+                    case PERSOSUBSTATE_SIM_NETWORK: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                    case PERSOSUBSTATE_SIM_NETWORK_SUBSET: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                    case PERSOSUBSTATE_SIM_CORPORATE: return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                    case PERSOSUBSTATE_SIM_SERVICE_PROVIDER: return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                    case PERSOSUBSTATE_SIM_SIM: return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                    default: return null;
+                }
+            case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
+            default: return null;
+       }
+    }
+
+    /* IccCard interface implementation */
+    // TODO: MTK use ICS solution, there is only three state, radio.on, radio.off, radio.not.available
+
+    public State getState(int appId) {
+        synchronized (mLock) {
+            return mExternalState[appId];
+        }
+    }
+
+
+    public IccRecords getIccRecords(int family) {
+        int appId = -1;
+        synchronized (mLock) {
+            switch (family) {
+                case UiccController.APP_FAM_IMS:
+                    appId = 0;
+                    break;
+                default:
+                    if (DBG) log("Not Support");
+                    break;
+            }
+
+            if (appId != -1) {
+                return mIccRecords[appId];
+            } else {
+                return null;
+            }
+        }
+    }
+
+    public IccFileHandler getIccFileHandler(int appId) {
+        synchronized (mLock) {
+            if (mUiccApplication[appId] != null) {
+                return mUiccApplication[appId].getIccFileHandler();
+            }
+            return null;
+        }
+    }
+
+    private Integer getIndex(Message msg) {
+        AsyncResult ar;
+        // FIXME: PhoneConstants.DEFAULT_CARD_INDEX will be changed?
+        Integer index = new Integer(PhoneConstants.DEFAULT_CARD_INDEX);
+
+        /*
+         * The events can be come in two ways. By explicitly sending it using
+         * sendMessage, in this case the user object passed is msg.obj and from
+         * the CommandsInterface, in this case the user object is msg.obj.userObj
+         */
+        if (msg != null) {
+            if (msg.obj != null && msg.obj instanceof Integer) {
+                index = (Integer) msg.obj;
+            } else if (msg.obj != null && msg.obj instanceof AsyncResult) {
+                ar = (AsyncResult) msg.obj;
+                if (ar.userObj != null && ar.userObj instanceof Integer) {
+                    index = (Integer) ar.userObj;
+                }
+            }
+        }
+        return index;
+    }
+
+
+    private void log(String msg) {
+        Rlog.d(LOG_TAG, "[SIM" + (mSlotId == 0 ? "1" : "2") + "] " + msg);
+    }
+
+    private void loge(String msg) {
+        Rlog.e(LOG_TAG, "[SIM" + (mSlotId == 0 ? "1" : "2") + "] " + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
new file mode 100755
index 0000000..94b065e
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
@@ -0,0 +1,86 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+public interface IWorldPhone {
+    public static final String LOG_TAG = "PHONE";
+
+    public static final int POLICY_OM       = 0;
+    public static final int POLICY_OP01     = 1;
+
+    static final int SELECTION_MODE_MANUAL = 0;
+    static final int SELECTION_MODE_AUTO   = 1;
+
+    static final int UNKNOWN_USER = 0;
+    static final int TYPE1_USER   = 1;
+    static final int TYPE2_USER   = 2;
+    static final int TYPE3_USER   = 3;
+
+    static final int REGION_UNKNOWN  = 0;
+    static final int REGION_DOMESTIC = 1;
+    static final int REGION_FOREIGN  = 2;
+
+    static final int EVENT_RADIO_ON_1 = 0;
+    static final int EVENT_RADIO_ON_2 = 1;
+    static final int EVENT_REG_PLMN_CHANGED_1 = 10;
+    static final int EVENT_REG_PLMN_CHANGED_2 = 11;
+    static final int EVENT_REG_SUSPENDED_1    = 30;
+    static final int EVENT_REG_SUSPENDED_2    = 31;
+    static final int EVENT_STORE_MODEM_TYPE   = 40;
+    static final int EVENT_QUERY_MODEM_TYPE   = 50;
+    static final int EVENT_INVALID_SIM_NOTIFY_1 = 60;
+    static final int EVENT_INVALID_SIM_NOTIFY_2 = 61;
+
+    static final int DEFAULT_MAJOR_SIM    = 0;
+    static final int MAJOR_CAPABILITY_OFF = -1;
+    static final int AUTO_SWITCH_OFF      = -98;
+    static final int MAJOR_SIM_UNKNOWN    = -99;
+
+    static final int CAMP_ON_NOT_DENIED                     = 0;
+    static final int CAMP_ON_DENY_REASON_UNKNOWN            = 1;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD = 2;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD = 3;
+    static final int CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD    = 4;
+
+    static final int ICC_CARD_TYPE_UNKNOWN = 0;
+    static final int ICC_CARD_TYPE_SIM     = 1;
+    static final int ICC_CARD_TYPE_USIM    = 2;
+
+    static final String NO_OP = "OM";
+    static final String ACTION_SHUTDOWN_IPO = "android.intent.action.ACTION_SHUTDOWN_IPO";
+    static final String ACTION_ADB_SWITCH_MODEM = "android.intent.action.ACTION_ADB_SWITCH_MODEM";
+
+    public void setModemSelectionMode(int mode, int modemType);
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
new file mode 100755
index 0000000..c517ad8
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneOm.java
@@ -0,0 +1,912 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.ModemSwitchHandler;
+
+/**
+ *@hide
+ */
+public class WorldPhoneOm extends Handler implements IWorldPhone {
+    private static Object sLock = new Object();
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+    private static final int[] FDD_STANDBY_TIMER = {
+        60
+    };
+    private static final int[] TDD_STANDBY_TIMER = {
+        40
+    };
+    private static final String[] PLMN_TABLE_TYPE1 = {
+        "46000", "46002", "46007", "46008", "46011"
+    };
+    private static final String[] PLMN_TABLE_TYPE3 = {
+        "46001", "46006", "46009", "45407",
+        "46003", "46005", "45502"
+    };
+    private static final String[] MCC_TABLE_DOMESTIC = {
+        "460"
+    };
+
+    private static Context sContext = null;
+    private static Phone sDefultPhone = null;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+    private static String sOperatorSpec;
+    private static String sPlmnSs;
+    private static String sLastPlmn;
+    private static String[] sImsi = new String[PROJECT_SIM_NUM];
+    private static String[] sNwPlmnStrings;
+    private static int sVoiceRegState;
+    private static int sDataRegState;
+    // private static int sRilVoiceRegState;
+    // private static int sRilDataRegState;
+    private static int sRilVoiceRadioTechnology;
+    private static int sRilDataRadioTechnology;
+    private static int sUserType;
+    private static int sRegion;
+    private static int sDenyReason;
+    private static int sSuspendId;
+    private static int sMajorSim;
+    private static int sDefaultBootUpModem = ModemSwitchHandler.MD_TYPE_UNKNOWN;
+    private static int[] sIccCardType = new int[PROJECT_SIM_NUM];
+    private static boolean sVoiceCapable;
+    private static boolean[] sIsInvalidSim = new boolean[PROJECT_SIM_NUM];
+    private static boolean[] sSuspendWaitImsi = new boolean[PROJECT_SIM_NUM];
+    private static boolean[] sFirstSelect = new boolean[PROJECT_SIM_NUM];
+    private static UiccController sUiccController = null;
+    private static IccRecords[] sIccRecordsInstance = new IccRecords[PROJECT_SIM_NUM];
+    private static ServiceState sServiceState;
+    private static ModemSwitchHandler sModemSwitchHandler = null;
+    private static int sTddStandByCounter;
+    private static int sFddStandByCounter;
+    private static boolean sWaitInTdd;
+    private static boolean sWaitInFdd;
+
+    public WorldPhoneOm() {
+        logd("Constructor invoked");
+        sOperatorSpec = SystemProperties.get("ro.operator.optr", NO_OP);
+        logd("Operator Spec:" + sOperatorSpec);
+        sDefultPhone = PhoneFactory.getDefaultPhone();
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+        }
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sCi[i].setOnPlmnChangeNotification(this, EVENT_REG_PLMN_CHANGED_1 + i, null);
+            sCi[i].setOnRegistrationSuspended(this, EVENT_REG_SUSPENDED_1 + i, null);
+            sCi[i].registerForOn(this, EVENT_RADIO_ON_1 + i, null);
+            // sCi[i].setInvalidSimInfo(this, EVENT_INVALID_SIM_NOTIFY_1 + i, null);
+        }
+
+        sModemSwitchHandler = new ModemSwitchHandler();
+        logd(ModemSwitchHandler.modemToString(ModemSwitchHandler.getActiveModemType()));
+
+        IntentFilter intentFilter = new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        intentFilter.addAction(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
+        intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        intentFilter.addAction(ACTION_SHUTDOWN_IPO);
+        intentFilter.addAction(ACTION_ADB_SWITCH_MODEM);
+        intentFilter.addAction(TelephonyIntents.ACTION_SET_PHONE_RAT_FAMILY_DONE);
+        if (sDefultPhone != null) {
+            sContext = sDefultPhone.getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+        sVoiceCapable = sContext.getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
+        sContext.registerReceiver(mWorldPhoneReceiver, intentFilter);
+
+        sTddStandByCounter = 0;
+        sFddStandByCounter = 0;
+        sWaitInTdd = false;
+        sWaitInFdd = false;
+        sRegion = REGION_UNKNOWN;
+        sLastPlmn = null;
+        resetAllProperties();
+        if (WorldPhoneUtil.getModemSelectionMode() == SELECTION_MODE_MANUAL) {
+            logd("Auto select disable");
+            sMajorSim = AUTO_SWITCH_OFF;
+            // Settings.Global.putInt(sContext.getContentResolver(),
+            //         Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_MANUAL);
+        } else {
+            logd("Auto select enable");
+            // Settings.Global.putInt(sContext.getContentResolver(),
+            //         Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_AUTO);
+        }
+        // FDD_STANDBY_TIMER[sFddStandByCounter] = Settings.Global.getInt(
+        //         sContext.getContentResolver(), Settings.Global.WORLD_PHONE_FDD_MODEM_TIMER, FDD_STANDBY_TIMER[sFddStandByCounter]);
+        // Settings.Global.putInt(sContext.getContentResolver(),
+        //         Settings.Global.WORLD_PHONE_FDD_MODEM_TIMER, FDD_STANDBY_TIMER[sFddStandByCounter]);
+        logd("FDD_STANDBY_TIMER = " + FDD_STANDBY_TIMER[sFddStandByCounter] + "s");
+        logd("sDefaultBootUpModem = " + sDefaultBootUpModem);
+    }
+
+    private final BroadcastReceiver mWorldPhoneReceiver = new  BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            logd("[Receiver]+");
+            String action = intent.getAction();
+            logd("Action: " + action);
+            int slotId;
+            if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                slotId = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                logd("slotId: " + slotId + " simStatus: " + simStatus);
+                if (simStatus.equals(IccCardConstants.INTENT_VALUE_ICC_IMSI)) {
+                    if (sMajorSim == MAJOR_SIM_UNKNOWN) {
+                        sMajorSim = WorldPhoneUtil.getMajorSim();
+                    }
+                    sUiccController = UiccController.getInstance();
+                    if (sUiccController != null) {
+                        sIccRecordsInstance[slotId] = sUiccController.getIccRecords(slotId, UiccController.APP_FAM_3GPP);
+                    } else {
+                        logd("Null sUiccController");
+                        return;
+                    }
+                    if (sIccRecordsInstance[slotId] != null) {
+                        sImsi[slotId] = sIccRecordsInstance[slotId].getIMSI();
+                    } else {
+                        logd("Null sIccRecordsInstance");
+                        return;
+                    }
+                    sIccCardType[slotId] = getIccCardType(slotId);
+                    logd("sImsi[" + slotId + "]:" + sImsi[slotId]);
+                    if (slotId == sMajorSim) {
+                        logd("Major SIM");
+                        sUserType = getUserType(sImsi[slotId]);
+                        if (sFirstSelect[slotId]) {
+                            sFirstSelect[slotId] = false;
+                            if (sUserType == TYPE1_USER) {
+                                if (sRegion == REGION_DOMESTIC) {
+                                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                                } else if (sRegion == REGION_FOREIGN) {
+                                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                                } else {
+                                    logd("Region unknown");
+                                }
+                            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                            }
+                        }
+                        if (sSuspendWaitImsi[slotId]) {
+                            sSuspendWaitImsi[slotId] = false;
+                            logd("IMSI fot slot" + slotId + " now ready, resuming PLMN:"
+                                    + sNwPlmnStrings[0] + " with ID:" + sSuspendId);
+                            resumeCampingProcedure(slotId);
+                        }
+                    } else {
+                        logd("Not major SIM");
+                        getUserType(sImsi[slotId]);
+                    }
+                } else if (simStatus.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT)) {
+                    sLastPlmn = null;
+                    sImsi[slotId] = "";
+                    sFirstSelect[slotId] = true;
+                    sIsInvalidSim[slotId] = false;
+                    sSuspendWaitImsi[slotId] = false;
+                    sIccCardType[slotId] = ICC_CARD_TYPE_UNKNOWN;
+                    if (slotId == sMajorSim) {
+                        logd("Major SIM removed, no world phone service");
+                        removeModemStandByTimer();
+                        sUserType = UNKNOWN_USER;
+                        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+                        sMajorSim = MAJOR_SIM_UNKNOWN;
+                    } else {
+                        logd("SIM" + slotId + " is not major SIM");
+                    }
+                }
+            } else if (action.equals(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED)) {
+                sServiceState = ServiceState.newFromBundle(intent.getExtras());
+                if (sServiceState != null) {
+                    slotId = intent.getIntExtra(PhoneConstants.SLOT_KEY, PhoneConstants.SIM_ID_1);
+                    sPlmnSs = sServiceState.getOperatorNumeric();
+                    sVoiceRegState = sServiceState.getVoiceRegState();
+                    // sRilVoiceRegState = sServiceState.getRilVoiceRegState();
+                    sRilVoiceRadioTechnology = sServiceState.getRilVoiceRadioTechnology();
+                    sDataRegState = sServiceState.getDataRegState();
+                    // sRilDataRegState = sServiceState.getRilDataRegState();
+                    sRilDataRadioTechnology = sServiceState.getRilDataRadioTechnology();
+                    logd("slotId: " + slotId + ", " + WorldPhoneUtil.iccCardTypeToString(sIccCardType[slotId]));
+                    logd("sMajorSim: " + sMajorSim);
+                    logd(ModemSwitchHandler.modemToString(ModemSwitchHandler.getActiveModemType()));
+                    logd("sPlmnSs: " + sPlmnSs);
+                    logd("sVoiceRegState: " + WorldPhoneUtil.stateToString(sVoiceRegState));
+                    // logd("sRilVoiceRegState: " + WorldPhoneUtil.regStateToString(sRilVoiceRegState));
+                    logd("sRilVoiceRadioTech: " + sServiceState.rilRadioTechnologyToString(sRilVoiceRadioTechnology));
+                    logd("sDataRegState: " + WorldPhoneUtil.stateToString(sDataRegState));
+                    // logd("sRilDataRegState: " + WorldPhoneUtil.regStateToString(sRilDataRegState));
+                    logd("sRilDataRadioTech: " + sServiceState.rilRadioTechnologyToString(sRilDataRadioTechnology));
+                    if (slotId == sMajorSim) {
+                        if (isNoService()) {
+                            handleNoService();
+                        } else if (isInService()) {
+                            sLastPlmn = sPlmnSs;
+                            removeModemStandByTimer();
+                        }
+                    }
+                } else {
+                    logd("Null sServiceState");
+                }
+            } else if (action.equals(ACTION_SHUTDOWN_IPO)) {
+                if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                    if (WorldPhoneUtil.isLteSupport()) {
+                        ModemSwitchHandler.reloadModem(sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_LWG);
+                        logd("Reload to FDD CSFB modem");
+                    } else {
+                        ModemSwitchHandler.reloadModem(sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_WG);
+                        logd("Reload to WG modem");
+                    }
+                } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                    if (WorldPhoneUtil.isLteSupport()) {
+                        ModemSwitchHandler.reloadModem(sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_LTG);
+                        logd("Reload to TDD CSFB modem");
+                    } else {
+                        ModemSwitchHandler.reloadModem(sCi[PhoneConstants.SIM_ID_1], ModemSwitchHandler.MD_TYPE_TG);
+                        logd("Reload to TG modem");
+                    }
+                }
+            } else if (action.equals(ACTION_ADB_SWITCH_MODEM)) {
+                int toModem = intent.getIntExtra(TelephonyIntents.EXTRA_MD_TYPE, ModemSwitchHandler.MD_TYPE_UNKNOWN);
+                logd("toModem: " + toModem);
+                if (toModem == ModemSwitchHandler.MD_TYPE_WG
+                        || toModem == ModemSwitchHandler.MD_TYPE_TG
+                        || toModem == ModemSwitchHandler.MD_TYPE_LWG
+                        || toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                    setModemSelectionMode(IWorldPhone.SELECTION_MODE_MANUAL, toModem);
+                } else {
+                    setModemSelectionMode(IWorldPhone.SELECTION_MODE_AUTO, toModem);
+                }
+            } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                if (intent.getBooleanExtra("state", false) == false) {
+                    logd("Leave flight mode");
+                    sLastPlmn = null;
+                    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                        sIsInvalidSim[i] = false;
+                    }
+                } else {
+                    logd("Enter flight mode");
+                    for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                        sFirstSelect[i] = true;
+                    }
+                }
+            } else if (action.equals(TelephonyIntents.ACTION_SET_PHONE_RAT_FAMILY_DONE)) {
+                if (sMajorSim != AUTO_SWITCH_OFF) {
+                    sMajorSim = WorldPhoneUtil.getMajorSim();
+                }
+                handleSimSwitched();
+            }
+            logd("[Receiver]-");
+        }
+    };
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar = (AsyncResult) msg.obj;
+        switch (msg.what) {
+            case EVENT_RADIO_ON_1:
+                logd("handleMessage : <EVENT_RADIO_ON>");
+                handleRadioOn(PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_PLMN_CHANGED_1:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_REG_SUSPENDED_1:
+                logd("handleMessage : <EVENT_REG_SUSPENDED>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_1);
+                break;
+            case EVENT_RADIO_ON_2:
+                logd("handleMessage : <EVENT_RADIO_ON>");
+                handleRadioOn(PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_PLMN_CHANGED_2:
+                logd("handleMessage : <EVENT_REG_PLMN_CHANGED>");
+                handlePlmnChange(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_REG_SUSPENDED_2:
+                logd("handleMessage : <EVENT_REG_SUSPENDED>");
+                handleRegistrationSuspend(ar, PhoneConstants.SIM_ID_2);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_1:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_1, ar);
+                break;
+            case EVENT_INVALID_SIM_NOTIFY_2:
+                logd("handleMessage : <EVENT_INVALID_SIM_NOTIFY>");
+                handleInvalidSimNotify(PhoneConstants.SIM_ID_2, ar);
+                break;
+            default:
+                logd("Unknown msg:" + msg.what);
+        }
+    }
+
+    private void handleRadioOn(int slotId) {
+        logd("Slot" + slotId);
+        if (sMajorSim == MAJOR_SIM_UNKNOWN) {
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+        }
+    }
+
+    private void handlePlmnChange(AsyncResult ar, int slotId) {
+        logd("Slot" + slotId);
+        if (sMajorSim == MAJOR_SIM_UNKNOWN) {
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+        }
+        if (ar.exception == null && ar.result != null) {
+            String[] plmnString = (String[]) ar.result;
+            if (slotId == sMajorSim) {
+                sNwPlmnStrings = plmnString;
+            }
+            for (int i = 0; i < plmnString.length; i++) {
+                logd("plmnString[" + i + "]=" + plmnString[i]);
+            }
+            if (sMajorSim == slotId && sUserType == TYPE1_USER
+                    && sDenyReason != CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD) {
+                searchForDesignateService(plmnString[0]);
+            }
+            // To speed up performance in foreign countries, once get PLMN(no matter which slot)
+            // determine region right away and switch modem type if needed
+            sRegion = getRegion(plmnString[0]);
+            if (sUserType != TYPE3_USER && sRegion == REGION_FOREIGN
+                    && sMajorSim != AUTO_SWITCH_OFF && sMajorSim != MAJOR_CAPABILITY_OFF) {
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleRegistrationSuspend(AsyncResult ar, int slotId) {
+        logd("Slot" + slotId);
+        if (ar.exception == null && ar.result != null) {
+            sSuspendId = ((int[]) ar.result)[0];
+            logd("Suspending with Id=" + sSuspendId);
+            if (sMajorSim == slotId) {
+                if (sUserType != UNKNOWN_USER) {
+                    resumeCampingProcedure(slotId);
+                } else {
+                    sSuspendWaitImsi[slotId] = true;
+                    logd("User type unknown, wait for IMSI");
+                }
+            } else {
+                logd("Not major slot, camp on OK");
+                sCi[slotId].setResumeRegistration(sSuspendId, null);
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleInvalidSimNotify(int slotId, AsyncResult ar) {
+        logd("Slot" + slotId);
+        if (ar.exception == null && ar.result != null) {
+            String[] invalidSimInfo = (String[]) ar.result;
+            String plmn = invalidSimInfo[0];
+            int cs_invalid = Integer.parseInt(invalidSimInfo[1]);
+            int ps_invalid = Integer.parseInt(invalidSimInfo[2]);
+            int cause = Integer.parseInt(invalidSimInfo[3]);
+            int testMode = -1;
+            testMode = SystemProperties.getInt("gsm.gcf.testmode", 0);
+            if (testMode != 0) {
+                logd("Invalid SIM notified during test mode: " + testMode);
+                return;
+            }
+            logd("testMode:" + testMode + ", cause: " + cause + ", cs_invalid: " + cs_invalid + ", ps_invalid: " + ps_invalid + ", plmn: " + plmn);
+            if (sVoiceCapable && cs_invalid == 1) {
+                if (sLastPlmn == null) {
+                    logd("CS reject, invalid SIM");
+                    sIsInvalidSim[slotId] = true;
+                    return;
+                }
+            }
+            if (ps_invalid == 1) {
+                if (sLastPlmn == null) {
+                    logd("PS reject, invalid SIM");
+                    sIsInvalidSim[slotId] = true;
+                    return;
+                }
+            }
+        } else {
+            logd("AsyncResult is wrong " + ar.exception);
+        }
+    }
+
+    private void handleSwitchModem(int toModem) {
+        if (sIsInvalidSim[WorldPhoneUtil.getMajorSim()]
+                && WorldPhoneUtil.getModemSelectionMode() == SELECTION_MODE_AUTO) {
+            logd("Invalid SIM, switch not executed!");
+            return;
+        }
+        if (toModem == ModemSwitchHandler.MD_TYPE_TDD) {
+            if (WorldPhoneUtil.isLteSupport()) {
+                toModem = ModemSwitchHandler.MD_TYPE_LTG;
+            } else {
+                toModem = ModemSwitchHandler.MD_TYPE_TG;
+            }
+        } else if (toModem == ModemSwitchHandler.MD_TYPE_FDD) {
+            if (WorldPhoneUtil.isLteSupport()) {
+                toModem = ModemSwitchHandler.MD_TYPE_LWG;
+            } else {
+                toModem = ModemSwitchHandler.MD_TYPE_WG;
+            }
+        }
+        if (sMajorSim == AUTO_SWITCH_OFF) {
+            logd("Storing modem type: " + toModem);
+            sCi[PhoneConstants.SIM_ID_1].storeModemType(toModem, null);
+        } else {
+            if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_UNKNOWN) {
+                logd("Storing modem type: " + toModem);
+                sCi[PhoneConstants.SIM_ID_1].storeModemType(toModem, null);
+            } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_FDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    logd("Storing modem type: " + ModemSwitchHandler.MD_TYPE_WG);
+                    sCi[PhoneConstants.SIM_ID_1].storeModemType(ModemSwitchHandler.MD_TYPE_LWG, null);
+                } else {
+                    logd("Storing modem type: " + ModemSwitchHandler.MD_TYPE_LWG);
+                    sCi[PhoneConstants.SIM_ID_1].storeModemType(ModemSwitchHandler.MD_TYPE_WG, null);
+                }
+            } else if (sDefaultBootUpModem == ModemSwitchHandler.MD_TYPE_TDD) {
+                if (WorldPhoneUtil.isLteSupport()) {
+                    logd("Storing modem type: " + ModemSwitchHandler.MD_TYPE_WG);
+                    sCi[PhoneConstants.SIM_ID_1].storeModemType(ModemSwitchHandler.MD_TYPE_LTG, null);
+                } else {
+                    logd("Storing modem type: " + ModemSwitchHandler.MD_TYPE_LWG);
+                    sCi[PhoneConstants.SIM_ID_1].storeModemType(ModemSwitchHandler.MD_TYPE_TG, null);
+                }
+            }
+        }
+        if (toModem == ModemSwitchHandler.getActiveModemType()) {
+            if (toModem == ModemSwitchHandler.MD_TYPE_WG) {
+                logd("Already in WG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_TG) {
+                logd("Already in TG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LWG) {
+                logd("Already in FDD CSFB modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                logd("Already in TDD CSFB modem");
+            }
+            return;
+        } else {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                if (sActivePhones[i].getState() != PhoneConstants.State.IDLE) {
+                    logd("Phone" + i + " is not idle, modem switch not allowed");
+                    return;
+                }
+            }
+            removeModemStandByTimer();
+            if (toModem == ModemSwitchHandler.MD_TYPE_WG) {
+                logd("Switching to WG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_TG) {
+                logd("Switching to TG modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LWG) {
+                logd("Switching to FDD CSFB modem");
+            } else if (toModem == ModemSwitchHandler.MD_TYPE_LTG) {
+                logd("Switching to TDD CSFB modem");
+            }
+            ModemSwitchHandler.switchModem(toModem);
+            resetNetworkProperties();
+        }
+    }
+
+    private void handleSimSwitched() {
+        if (sMajorSim == MAJOR_CAPABILITY_OFF) {
+            logd("Major capability turned off");
+            removeModemStandByTimer();
+            sUserType = UNKNOWN_USER;
+        } else if (sMajorSim == AUTO_SWITCH_OFF) {
+            logd("Auto modem selection disabled");
+            removeModemStandByTimer();
+        } else if (sMajorSim == MAJOR_SIM_UNKNOWN) {
+            logd("Major SIM unknown");
+        } else {
+            logd("Auto modem selection enabled");
+            logd("Major capability in slot" + sMajorSim);
+            if (sImsi[sMajorSim] == null || sImsi[sMajorSim].equals("")) {
+                // may caused by receive 3g switched intent when boot up
+                logd("Major slot IMSI not ready");
+                sUserType = UNKNOWN_USER;
+                return;
+            }
+            sUserType = getUserType(sImsi[sMajorSim]);
+            if (sUserType == TYPE1_USER) {
+                if (sNwPlmnStrings != null) {
+                    sRegion = getRegion(sNwPlmnStrings[0]);
+                }
+                if (sRegion == REGION_DOMESTIC) {
+                    sFirstSelect[sMajorSim] = false;
+                    sIccCardType[sMajorSim] = getIccCardType(sMajorSim);
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                } else if (sRegion == REGION_FOREIGN) {
+                    sFirstSelect[sMajorSim] = false;
+                    handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+                } else {
+                    logd("Unknown region");
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                sFirstSelect[sMajorSim] = false;
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+            } else {
+                logd("Unknown user type");
+            }
+        }
+    }
+
+    private void handleNoService() {
+        logd("[handleNoService]+ Can not find service");
+        logd("Type" + sUserType + " user");
+        logd(WorldPhoneUtil.regionToString(sRegion));
+        int mdType = ModemSwitchHandler.getActiveModemType();
+        logd(ModemSwitchHandler.modemToString(mdType));
+        IccCardConstants.State iccState = ((PhoneProxy) sProxyPhones[sMajorSim]).getIccCard().getState();
+        if (iccState == IccCardConstants.State.READY) {
+            if (sUserType == TYPE1_USER) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    if (TDD_STANDBY_TIMER[sTddStandByCounter] >= 0) {
+                        if (!sWaitInTdd) {
+                            sWaitInTdd = true;
+                            logd("Wait " + TDD_STANDBY_TIMER[sTddStandByCounter] + "s. Timer index = " + sTddStandByCounter);
+                            postDelayed(mTddStandByTimerRunnable, TDD_STANDBY_TIMER[sTddStandByCounter] * 1000);
+                        } else {
+                            logd("Timer already set:" + TDD_STANDBY_TIMER[sTddStandByCounter] + "s");
+                        }
+                    } else {
+                        logd("Standby in TDD modem");
+                    }
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    if (FDD_STANDBY_TIMER[sFddStandByCounter] >= 0) {
+                        if (!sWaitInFdd) {
+                            sWaitInFdd = true;
+                            logd("Wait " + FDD_STANDBY_TIMER[sFddStandByCounter] + "s. Timer index = " + sFddStandByCounter);
+                            postDelayed(mFddStandByTimerRunnable, FDD_STANDBY_TIMER[sFddStandByCounter] * 1000);
+                        } else {
+                            logd("Timer already set:" + FDD_STANDBY_TIMER[sFddStandByCounter] + "s");
+                        }
+                    } else {
+                        logd("Standby in FDD modem");
+                    }
+                }
+            } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    logd("Standby in FDD modem");
+                } else {
+                    logd("Should not enter this state");
+                }
+            } else {
+                logd("Unknow user type");
+            }
+        } else {
+            logd("IccState not ready");
+        }
+        logd("[handleNoService]-");
+
+        return;
+    }
+
+    private boolean isAllowCampOn(String plmnString, int slotId) {
+        logd("[isAllowCampOn]+ " + plmnString);
+        logd("User type: " + sUserType);
+        logd(WorldPhoneUtil.iccCardTypeToString(sIccCardType[slotId]));
+        sRegion = getRegion(plmnString);
+        int mdType = ModemSwitchHandler.getActiveModemType();
+        logd(ModemSwitchHandler.modemToString(mdType));
+        if (sUserType == TYPE1_USER) {
+            if (sRegion == REGION_DOMESTIC) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    sDenyReason = CAMP_ON_NOT_DENIED;
+                    logd("Camp on OK");
+                    logd("[isAllowCampOn]-");
+                    return true;
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD;
+                    logd("Camp on REJECT");
+                    logd("[isAllowCampOn]-");
+                    return false;
+                }
+            } else if (sRegion == REGION_FOREIGN) {
+                if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                        || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                    sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD;
+                    logd("Camp on REJECT");
+                    logd("[isAllowCampOn]-");
+                    return false;
+                } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                        || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                    sDenyReason = CAMP_ON_NOT_DENIED;
+                    logd("Camp on OK");
+                    logd("[isAllowCampOn]-");
+                    return true;
+                }
+            } else {
+                logd("Unknow region");
+            }
+        } else if (sUserType == TYPE2_USER || sUserType == TYPE3_USER) {
+            if (mdType == ModemSwitchHandler.MD_TYPE_LTG
+                    || mdType == ModemSwitchHandler.MD_TYPE_TG) {
+                sDenyReason = CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD;
+                logd("Camp on REJECT");
+                logd("[isAllowCampOn]-");
+                return false;
+            } else if (mdType == ModemSwitchHandler.MD_TYPE_LWG
+                    || mdType == ModemSwitchHandler.MD_TYPE_WG) {
+                sDenyReason = CAMP_ON_NOT_DENIED;
+                logd("Camp on OK");
+                logd("[isAllowCampOn]-");
+                return true;
+            }
+        } else {
+            logd("Unknown user type");
+        }
+        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+        logd("Camp on REJECT");
+        logd("[isAllowCampOn]-");
+
+        return false;
+    }
+
+    private boolean isInService() {
+        boolean inService = false;
+
+        if (sVoiceRegState == ServiceState.STATE_IN_SERVICE
+                || sDataRegState == ServiceState.STATE_IN_SERVICE) {
+            inService = true;
+        }
+        logd("inService: " + inService);
+
+        return inService;
+    }
+
+    private boolean isNoService() {
+        boolean noService = false;
+
+        if (sVoiceRegState == ServiceState.STATE_OUT_OF_SERVICE
+                // && sRilVoiceRegState == ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING
+                && sDataRegState == ServiceState.STATE_OUT_OF_SERVICE
+                // && sRilDataRegState == ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING) {
+			) {
+            noService = true;
+        } else {
+            noService = false;
+        }
+        logd("noService: " + noService);
+
+        return noService;
+    }
+
+    private int getIccCardType(int slotId) {
+        int simType;
+        String simString = "Unknown";
+
+        simString = ((PhoneProxy) sProxyPhones[slotId]).getIccCard().getIccCardType();
+        if (simString.equals("SIM")) {
+            logd("IccCard type: SIM");
+            simType = ICC_CARD_TYPE_SIM;
+        } else if (simString.equals("USIM")) {
+            logd("IccCard type: USIM");
+            simType = ICC_CARD_TYPE_USIM;
+        } else {
+            logd("IccCard type: Unknown");
+            simType = ICC_CARD_TYPE_UNKNOWN;
+        }
+
+        return simType;
+    }
+
+    private int getRegion(String plmn) {
+        String currentMcc;
+        if (plmn == null) {
+            logd("[getRegion] null PLMN");
+            return REGION_UNKNOWN;
+        }
+        currentMcc = plmn.substring(0, 3);
+        for (String mcc : MCC_TABLE_DOMESTIC) {
+            if (currentMcc.equals(mcc)) {
+                logd("[getRegion] REGION_DOMESTIC");
+                return REGION_DOMESTIC;
+            }
+        }
+        logd("[getRegion] REGION_FOREIGN");
+        return REGION_FOREIGN;
+    }
+
+    private int getUserType(String imsi) {
+        if (imsi != null && !imsi.equals("")) {
+            imsi = imsi.substring(0, 5);
+            for (String mccmnc : PLMN_TABLE_TYPE1) {
+                if (imsi.equals(mccmnc)) {
+                    logd("[getUserType] Type1 user");
+                    return TYPE1_USER;
+                }
+            }
+            for (String mccmnc : PLMN_TABLE_TYPE3) {
+                if (imsi.equals(mccmnc)) {
+                    logd("[getUserType] Type3 user");
+                    return TYPE3_USER;
+                }
+            }
+            logd("[getUserType] Type2 user");
+            return TYPE2_USER;
+        } else {
+            logd("[getUserType] null IMSI");
+            return UNKNOWN_USER;
+        }
+    }
+
+    private void resumeCampingProcedure(int slotId) {
+        logd("Resume camping slot" + slotId);
+        String plmnString = sNwPlmnStrings[0];
+        if (isAllowCampOn(plmnString, slotId)) {
+            removeModemStandByTimer();
+            sCi[slotId].setResumeRegistration(sSuspendId, null);
+        } else {
+            logd("Because: " + WorldPhoneUtil.denyReasonToString(sDenyReason));
+            if (sDenyReason == CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD) {
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+            } else if (sDenyReason == CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD) {
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+            }
+        }
+    }
+
+    private Runnable mTddStandByTimerRunnable = new Runnable() {
+        public void run() {
+            sTddStandByCounter++;
+            if (sTddStandByCounter >= TDD_STANDBY_TIMER.length) {
+                sTddStandByCounter = TDD_STANDBY_TIMER.length - 1;
+            }
+            logd("TDD time out!");
+            handleSwitchModem(ModemSwitchHandler.MD_TYPE_FDD);
+        }
+    };
+
+    private Runnable mFddStandByTimerRunnable = new Runnable() {
+        public void run() {
+            sFddStandByCounter++;
+            if (sFddStandByCounter >= FDD_STANDBY_TIMER.length) {
+                sFddStandByCounter = FDD_STANDBY_TIMER.length - 1;
+            }
+            logd("FDD time out!");
+            handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+        }
+    };
+
+    private void removeModemStandByTimer() {
+        if (sWaitInTdd) {
+            logd("Remove TDD wait timer. Set sWaitInTdd = false");
+            sWaitInTdd = false;
+            removeCallbacks(mTddStandByTimerRunnable);
+        }
+        if (sWaitInFdd) {
+            logd("Remove FDD wait timer. Set sWaitInFdd = false");
+            sWaitInFdd = false;
+            removeCallbacks(mFddStandByTimerRunnable);
+        }
+    }
+
+    private void resetAllProperties() {
+        logd("[resetAllProperties]");
+        sNwPlmnStrings = null;
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sFirstSelect[i] = true;
+        }
+        sDenyReason = CAMP_ON_DENY_REASON_UNKNOWN;
+        resetSimProperties();
+        resetNetworkProperties();
+    }
+
+    private void resetNetworkProperties() {
+        logd("[resetNetworkProperties]");
+        synchronized (sLock) {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                sSuspendWaitImsi[i] = false;
+            }
+        }
+    }
+
+    private void resetSimProperties() {
+        logd("[resetSimProperties]");
+        synchronized (sLock) {
+            for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+                sImsi[i] = "";
+                sIccCardType[i] = ICC_CARD_TYPE_UNKNOWN;
+            }
+            sUserType = UNKNOWN_USER;
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+        }
+    }
+
+    private void searchForDesignateService(String strPlmn) {
+        if (strPlmn == null) {
+            logd("[searchForDesignateService]- null source");
+            return;
+        }
+        strPlmn = strPlmn.substring(0, 5);
+        for (String mccmnc : PLMN_TABLE_TYPE1) {
+            if (strPlmn.equals(mccmnc)) {
+                logd("Find TD service");
+                logd("sUserType: " + sUserType + " sRegion: " + sRegion);
+                logd(ModemSwitchHandler.modemToString(ModemSwitchHandler.getActiveModemType()));
+                handleSwitchModem(ModemSwitchHandler.MD_TYPE_TDD);
+                break;
+            }
+        }
+
+        return;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+        // Settings.Global.putInt(sContext.getContentResolver(),
+        //         Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, mode);
+        if (mode == SELECTION_MODE_AUTO) {
+            logd("Modem Selection <AUTO>");
+            sMajorSim = WorldPhoneUtil.getMajorSim();
+            handleSimSwitched();
+        } else {
+            logd("Modem Selection <MANUAL>");
+            sMajorSim = AUTO_SWITCH_OFF;
+            handleSwitchModem(modemType);
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPOM]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
new file mode 100755
index 0000000..f2c5b41
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
@@ -0,0 +1,246 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.Context;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.PhoneRatFamily;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyProperties;
+
+
+/**
+ *@hide
+ */
+public class WorldPhoneUtil implements IWorldPhone {
+    private static final int PROJECT_SIM_NUM = TelephonyManager.getDefault().getSimCount();
+    private static final boolean IS_WORLD_PHONE_SUPPORT = true;  // (SystemProperties.getInt(TelephonyProperties.PROPERTY_WORLD_PHONE, 0) == 1);
+    private static final boolean IS_LTE_SUPPORT = (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1);
+    private static Context sContext = null;
+    private static Phone sDefultPhone = null;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+
+    public WorldPhoneUtil() {
+        logd("Constructor invoked");
+        sDefultPhone = PhoneFactory.getDefaultPhone();
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+        }
+        if (sDefultPhone != null) {
+            sContext = sDefultPhone.getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    public static int getProjectSimNum() {
+        return PROJECT_SIM_NUM;
+    }
+
+    public static int getMajorSim() {
+        if (sProxyPhones == null) {
+            logd("[getMajorSim] sProxyPhones = null");
+            return DEFAULT_MAJOR_SIM;
+        }
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            if ((((PhoneBase) sActivePhones[i]).getPhoneRatFamily()
+                    & PhoneRatFamily.PHONE_RAT_FAMILY_3G) == PhoneRatFamily.PHONE_RAT_FAMILY_3G) {
+                logd("[getMajorSim]: " + i);
+                return i;
+            }
+        }
+        logd("[getMajorSim]: fail to get major SIM");
+
+        return DEFAULT_MAJOR_SIM;
+    }
+
+    public static int getModemSelectionMode() {
+        if (sContext == null) {
+            logd("sContext = null");
+            return SELECTION_MODE_AUTO;
+        }
+
+		logd("getModemSelectionMode: always auto!");
+		return SELECTION_MODE_AUTO;
+		/*
+        return Settings.Global.getInt(sContext.getContentResolver(),
+                    Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_AUTO);
+		*/
+    }
+
+    public static boolean isWorldPhoneSupport() {
+        return IS_WORLD_PHONE_SUPPORT;
+    }
+
+    public static boolean isLteSupport() {
+        return IS_LTE_SUPPORT;
+    }
+
+    public static String regionToString(int region) {
+        String regionString;
+        switch (region) {
+            case REGION_UNKNOWN:
+                regionString = "REGION_UNKNOWN";
+                break;
+            case REGION_DOMESTIC:
+                regionString = "REGION_DOMESTIC";
+                break;
+            case REGION_FOREIGN:
+                regionString = "REGION_FOREIGN";
+                break;
+            default:
+                regionString = "Invalid Region";
+                break;
+        }
+
+        return regionString;
+    }
+
+    public static String stateToString(int state) {
+        String stateString;
+        switch (state) {
+            case ServiceState.STATE_POWER_OFF:
+                stateString = "STATE_POWER_OFF";
+                break;
+            case ServiceState.STATE_IN_SERVICE:
+                stateString = "STATE_IN_SERVICE";
+                break;
+            case ServiceState.STATE_OUT_OF_SERVICE:
+                stateString = "STATE_OUT_OF_SERVICE";
+                break;
+            case ServiceState.STATE_EMERGENCY_ONLY:
+                stateString = "STATE_EMERGENCY_ONLY";
+                break;
+            default:
+                stateString = "Invalid State";
+                break;
+        }
+
+        return stateString;
+    }
+
+    public static String regStateToString(int regState) {
+        String rsString;
+        switch (regState) {
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_HOME_NETWORK:
+                rsString = "REGISTRATION_STATE_HOME_NETWORK";
+                break;
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED:
+                rsString = "REGISTRATION_STATE_REGISTRATION_DENIED";
+                break;
+            case ServiceState.REGISTRATION_STATE_UNKNOWN:
+                rsString = "REGISTRATION_STATE_UNKNOWN";
+                break;
+            case ServiceState.REGISTRATION_STATE_ROAMING:
+                rsString = "REGISTRATION_STATE_ROAMING";
+                break;
+            default:
+                rsString = "Invalid RegState";
+                break;
+        }
+
+        return rsString;
+    }
+
+    public static String denyReasonToString(int reason) {
+        String drString;
+        switch (reason) {
+            case CAMP_ON_NOT_DENIED:
+                drString = "CAMP_ON_NOT_DENIED";
+                break;
+            case CAMP_ON_DENY_REASON_UNKNOWN:
+                drString = "CAMP_ON_DENY_REASON_UNKNOWN";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD";
+                break;
+            case CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD:
+                drString = "CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD";
+                break;
+            default:
+                drString = "Invalid Reason";
+                break;
+        }
+
+        return drString;
+    }
+
+    public static String iccCardTypeToString(int iccCardType) {
+        String iccTypeString;
+        switch (iccCardType) {
+            case ICC_CARD_TYPE_SIM:
+                iccTypeString = "SIM";
+                break;
+            case ICC_CARD_TYPE_USIM:
+                iccTypeString = "USIM";
+                break;
+            case ICC_CARD_TYPE_UNKNOWN:
+                iccTypeString = "Icc Card Type Unknown";
+                break;
+            default:
+                iccTypeString = "Invalid Icc Card Type";
+                break;
+        }
+
+        return iccTypeString;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPP_UTIL]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java
new file mode 100755
index 0000000..6f7c85f
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneWrapper.java
@@ -0,0 +1,86 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+
+
+
+/**
+ *@hide
+ */
+public class WorldPhoneWrapper implements IWorldPhone {
+    private static int sOperatorSpec = -1;
+    private static IWorldPhone sWorldPhoneInstance = null;
+    private static WorldPhoneUtil sWorldPhoneUtil = null;
+
+    public WorldPhoneWrapper() {
+    }
+
+    public static IWorldPhone getWorldPhoneInstance() {
+        if (sWorldPhoneInstance == null) {
+            String optr = SystemProperties.get("ro.operator.optr");
+            if (optr != null && optr.equals("OP01")) {
+                // sOperatorSpec = POLICY_OP01;
+				logd("getWorldPhoneInstance: POLICY_OP01 not implemented!");
+				sOperatorSpec = POLICY_OM;
+            } else {
+                sOperatorSpec = POLICY_OM;
+            }
+            sWorldPhoneUtil = new WorldPhoneUtil();
+            if (sOperatorSpec == POLICY_OP01) {
+                // sWorldPhoneInstance = new WorldPhoneOp01();
+            } else if (sOperatorSpec == POLICY_OM) {
+                sWorldPhoneInstance = new WorldPhoneOm();
+            }
+        }
+        logd("sOperatorSpec: " + sOperatorSpec + ", isLteSupport: " + WorldPhoneUtil.isLteSupport());
+
+        return sWorldPhoneInstance;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+        if (sOperatorSpec == POLICY_OP01 || sOperatorSpec == POLICY_OM) {
+            sWorldPhoneInstance.setModemSelectionMode(mode, modemType);
+        } else {
+            logd("Unknown World Phone Spec");
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPO_WRAPPER]" + msg);
+    }
+}
-- 
1.9.1

