From 054622dd9e90c000e9c2b9599c0a81994536fe59 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E7=A7=8B=E5=8F=B6=E9=9A=8F=E9=A3=8Eivan?=
 <yanziily@gmail.com>
Date: Sun, 27 Dec 2015 11:26:39 +0800
Subject: [PATCH 2/2] camera
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: Ib653b62b465dbed3c70937b3b48c13178b96fde6
Signed-off-by: 秋叶随风ivan <yanziily@gmail.com>
---
 camera/Android.mk                                  |   5 +
 camera/Camera.cpp                                  |  31 ++
 camera/CameraParameters.cpp                        |  15 +
 camera/ICameraService.cpp                          |  56 +++
 camera/libcamera_client_mtk/Android.mk             |  95 ++++
 camera/libcamera_client_mtk/MtkCamera.cpp          | 212 +++++++++
 .../libcamera_client_mtk/MtkCameraParameters.cpp   | 456 ++++++++++++++++++
 camera/libcamera_client_mtk/NOTICE                 |   1 +
 camera/libcamera_client_mtk/README                 |  14 +
 include/camera/Camera.h                            |   9 +
 include/camera/CameraParameters.h                  |   8 +
 include/camera/ICameraService.h                    |  18 +
 include/camera/MtkCamera.h                         | 297 ++++++++++++
 include/camera/MtkCameraParameters.h               | 507 +++++++++++++++++++++
 services/camera/libcameraservice/Android.mk        |  19 +
 services/camera/libcameraservice/CameraService.cpp |  67 +++
 services/camera/libcameraservice/CameraService.h   |  15 +-
 .../camera/libcameraservice/api1/CameraClient.cpp  | 151 ++++--
 .../camera/libcameraservice/api1/CameraClient.h    |  25 +
 .../device1/CameraHardwareInterface.h              |  13 +
 .../libcameraservice/device2/Camera2Device.cpp     |  25 +-
 .../libcameraservice/mediatek/CameraService.cpp    | 100 ++++
 .../mediatek/api1/CameraClient.cpp                 | 421 +++++++++++++++++
 23 files changed, 2519 insertions(+), 41 deletions(-)
 create mode 100755 camera/libcamera_client_mtk/Android.mk
 create mode 100644 camera/libcamera_client_mtk/MtkCamera.cpp
 create mode 100644 camera/libcamera_client_mtk/MtkCameraParameters.cpp
 create mode 100755 camera/libcamera_client_mtk/NOTICE
 create mode 100755 camera/libcamera_client_mtk/README
 create mode 100644 include/camera/MtkCamera.h
 create mode 100644 include/camera/MtkCameraParameters.h
 create mode 100644 services/camera/libcameraservice/mediatek/CameraService.cpp
 create mode 100644 services/camera/libcameraservice/mediatek/api1/CameraClient.cpp

diff --git a/camera/Android.mk b/camera/Android.mk
index 431f733..3927bcc 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -53,6 +53,11 @@ LOCAL_C_INCLUDES += \
 	system/media/camera/include \
 	system/media/private/camera/include \
 
+# Enable MTK stuff
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+endif
+
 ifneq ($(TARGET_SPECIFIC_CAMERA_PARAMETER_LIBRARY),)
 LOCAL_WHOLE_STATIC_LIBRARIES += $(TARGET_SPECIFIC_CAMERA_PARAMETER_LIBRARY)
 else
diff --git a/camera/Camera.cpp b/camera/Camera.cpp
index 85f44f0..650d1a6 100644
--- a/camera/Camera.cpp
+++ b/camera/Camera.cpp
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
 **
 ** Copyright (C) 2008, The Android Open Source Project
 **
@@ -187,7 +192,11 @@ void Camera::stopRecording()
 // release a recording frame
 void Camera::releaseRecordingFrame(const sp<IMemory>& mem)
 {
+#ifdef MTK_HARDWARE
+    ALOGD("RRF");
+#else
     ALOGV("releaseRecordingFrame");
+#endif
     sp <ICamera> c = mCamera;
     if (c == 0) return;
     c->releaseRecordingFrame(mem);
@@ -338,7 +347,9 @@ void Camera::dataCallbackTimestamp(nsecs_t timestamp, int32_t msgType, const sp<
         listener->postDataTimestamp(timestamp, msgType, dataPtr);
     } else {
         ALOGW("No listener was set. Drop a recording frame.");
+#ifndef MTK_HARDWARE
         releaseRecordingFrame(dataPtr);
+#endif
     }
 }
 
@@ -372,4 +383,24 @@ Camera::RecordingProxy::RecordingProxy(const sp<Camera>& camera)
     mCamera = camera;
 }
 
+#ifdef MTK_HARDWARE
+status_t
+Camera::
+getProperty(String8 const& key, String8& value)
+{
+    const sp<ICameraService>& cs = getCameraService();
+    if (cs == 0) return UNKNOWN_ERROR;
+    return cs->getProperty(key, value);
+}
+
+
+status_t
+Camera::
+setProperty(String8 const& key, String8 const& value)
+{
+    const sp<ICameraService>& cs = getCameraService();
+    if (cs == 0) return UNKNOWN_ERROR;
+    return cs->setProperty(key, value);
+}
+#endif
 }; // namespace android
diff --git a/camera/CameraParameters.cpp b/camera/CameraParameters.cpp
index 7ac60f2..c236fd7 100644
--- a/camera/CameraParameters.cpp
+++ b/camera/CameraParameters.cpp
@@ -37,6 +37,9 @@ const char CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE[] = "preview-fps-ra
 const char CameraParameters::KEY_PICTURE_SIZE[] = "picture-size";
 const char CameraParameters::KEY_SUPPORTED_PICTURE_SIZES[] = "picture-size-values";
 const char CameraParameters::KEY_PICTURE_FORMAT[] = "picture-format";
+#ifdef MTK_HARDWARE
+const char CameraParameters::SNAPSHOT_PICTURE_FLIP[] = "snapshot-picture-flip";//add by xueweifeng
+#endif
 const char CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS[] = "picture-format-values";
 const char CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH[] = "jpeg-thumbnail-width";
 const char CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT[] = "jpeg-thumbnail-height";
@@ -473,6 +476,18 @@ const char *CameraParameters::getPictureFormat() const
     return get(KEY_PICTURE_FORMAT);
 }
 
+#ifdef MTK_HARDWARE
+void CameraParameters::setCameraPictureFlip(const int format)
+{
+    set(SNAPSHOT_PICTURE_FLIP, format);
+}
+
+const int CameraParameters::getCameraPictureFlip() const
+{
+    return getInt(SNAPSHOT_PICTURE_FLIP);
+}
+#endif
+
 void CameraParameters::dump() const
 {
     ALOGD("dump: mMap.size = %zu", mMap.size());
diff --git a/camera/ICameraService.cpp b/camera/ICameraService.cpp
index 5485205..4f6dbb4 100644
--- a/camera/ICameraService.cpp
+++ b/camera/ICameraService.cpp
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
 **
 ** Copyright 2008, The Android Open Source Project
 **
@@ -278,6 +283,32 @@ public:
         return reply.readInt32();
     }
 
+//!++
+#ifdef MTK_HARDWARE
+
+    virtual status_t getProperty(String8 const& key, String8& value) const
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICameraService::getInterfaceDescriptor());
+        data.writeString8(key);
+        remote()->transact(BnCameraService::GET_PROPERTY, data, &reply);
+        value = reply.readString8();
+        return reply.readInt32();
+    }
+
+    virtual status_t setProperty(String8 const& key, String8 const& value)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICameraService::getInterfaceDescriptor());
+        data.writeString8(key);
+        data.writeString8(value);
+        remote()->transact(BnCameraService::SET_PROPERTY, data, &reply);
+        return reply.readInt32();
+    }
+
+#endif
+//!--
+
     virtual status_t getLegacyParameters(int cameraId, String16* parameters) {
         if (parameters == NULL) {
             ALOGE("%s: parameters must not be null", __FUNCTION__);
@@ -446,6 +477,31 @@ status_t BnCameraService::onTransact(
             reply->writeInt32(removeListener(listener));
             return NO_ERROR;
         } break;
+
+//!++
+#ifdef MTK_HARDWARE
+        case GET_PROPERTY: {
+            CHECK_INTERFACE(ICameraService, data, reply);
+            String8 const key = data.readString8();
+            String8 value;
+            status_t const status = getProperty(key, value);
+            reply->writeString8(value);
+            reply->writeInt32(status);
+            ALOGD("[GET_PROPERTY] - pid=%d, uid=%d (%s)=(%s) \n", IPCThreadState::self()->getCallingPid(), IPCThreadState::self()->getCallingUid(), key.string(), value.string());
+            return OK;
+        } break;
+        case SET_PROPERTY: {
+            CHECK_INTERFACE(ICameraService, data, reply);
+            String8 const key = data.readString8();
+            String8 const value = data.readString8();
+            status_t const status = setProperty(key, value);
+            reply->writeInt32(status);
+            ALOGD("[SET_PROPERTY] - pid=%d, uid=%d (%s)=(%s) \n", IPCThreadState::self()->getCallingPid(), IPCThreadState::self()->getCallingUid(), key.string(), value.string());
+            return OK;
+        } break;
+#endif
+//!--
+
         case GET_LEGACY_PARAMETERS: {
             CHECK_INTERFACE(ICameraService, data, reply);
             int cameraId = data.readInt32();
diff --git a/camera/libcamera_client_mtk/Android.mk b/camera/libcamera_client_mtk/Android.mk
new file mode 100755
index 0000000..f40f95c
--- /dev/null
+++ b/camera/libcamera_client_mtk/Android.mk
@@ -0,0 +1,95 @@
+# Copyright Statement:
+#
+# This software/firmware and related documentation ("MediaTek Software") are
+# protected under relevant copyright laws. The information contained herein
+# is confidential and proprietary to MediaTek Inc. and/or its licensors.
+# Without the prior written permission of MediaTek inc. and/or its licensors,
+# any reproduction, modification, use or disclosure of MediaTek Software,
+# and information contained herein, in whole or in part, shall be strictly prohibited.
+
+# MediaTek Inc. (C) 2010. All rights reserved.
+#
+# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+# THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+# RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+# AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+# SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+# CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+#
+# The following software/firmware and/or related documentation ("MediaTek Software")
+# have been modified by MediaTek Inc. All revisions are subject to any receiver's
+# applicable license agreements with MediaTek Inc.
+
+################################################################################
+#
+################################################################################
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+LOCAL_PATH := $(call my-dir)
+
+################################################################################
+#
+################################################################################
+include $(CLEAR_VARS)
+
+#-----------------------------------------------------------
+LOCAL_SRC_FILES += MtkCameraParameters.cpp
+LOCAL_SRC_FILES += MtkCamera.cpp
+
+#-----------------------------------------------------------
+LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av/include
+#
+
+#-----------------------------------------------------------
+LOCAL_WHOLE_STATIC_LIBRARIES += 
+#
+LOCAL_STATIC_LIBRARIES += 
+
+#-----------------------------------------------------------
+LOCAL_MODULE := libcamera_client_mtk
+
+#-----------------------------------------------------------
+include $(BUILD_STATIC_LIBRARY)
+
+################################################################################
+#
+################################################################################
+include $(CLEAR_VARS)
+
+#-----------------------------------------------------------
+LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_client_mtk
+#
+LOCAL_STATIC_LIBRARIES += 
+
+#-----------------------------------------------------------
+LOCAL_SHARED_LIBRARIES += liblog
+LOCAL_SHARED_LIBRARIES += libcutils
+LOCAL_SHARED_LIBRARIES += libutils
+LOCAL_SHARED_LIBRARIES += libbinder
+LOCAL_SHARED_LIBRARIES += libcamera_client
+#
+
+#-----------------------------------------------------------
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := libcamera_client_mtk
+
+#-----------------------------------------------------------
+include $(BUILD_SHARED_LIBRARY)
+
+################################################################################
+#
+################################################################################
+include $(CLEAR_VARS)
+include $(call all-makefiles-under,$(LOCAL_PATH))
+endif
diff --git a/camera/libcamera_client_mtk/MtkCamera.cpp b/camera/libcamera_client_mtk/MtkCamera.cpp
new file mode 100644
index 0000000..e11b0c9
--- /dev/null
+++ b/camera/libcamera_client_mtk/MtkCamera.cpp
@@ -0,0 +1,212 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "MtkCamera"
+#include <utils/Log.h>
+
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/MtkCamera.h>
+
+namespace android {
+
+
+MtkCamMsgExtDataHelper::
+MtkCamMsgExtDataHelper()
+    : mIsValid(false)
+    , mspData(0)
+    , mspHeap(0)
+    , mDataOffset(0)
+    , mDataSize(0)
+{
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+}
+
+
+MtkCamMsgExtDataHelper::
+~MtkCamMsgExtDataHelper()
+{
+    uninit();
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+init(const sp<IMemory>& dataPtr)
+{
+    bool ret = false;
+    //
+    sp<IMemoryHeap> heap = 0;
+    ssize_t         offset = 0;
+    size_t          size = 0;
+    //
+    if  ( NULL == dataPtr.get() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] dataPtr is NULL \r\n");
+        goto lbExit;
+    }
+    //
+    heap = dataPtr->getMemory(&offset, &size);
+    if  ( NULL == heap.get() || NULL == heap->base() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] heap or heap->base() is NULL - (heap,offset,size)=(%p,%d,%d) \r\n", heap.get(), offset, size);
+        goto lbExit;
+    }
+    //
+    if ( sizeof(DataHeader) > size ) {
+        ALOGE("[MtkCamMsgExtDataHelper] sizeof(DataHeader)(%d) > size(%d) \r\n", sizeof(DataHeader), size);
+        goto lbExit;
+    }
+    //
+    ::memcpy(&mExtDataHdr, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
+    mspData = dataPtr;
+    mspHeap = heap;
+    mDataOffset = offset;
+    mDataSize   = size;
+    mIsValid= true;
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+uninit()
+{
+    mIsValid= false;
+    mspData = NULL;
+    mspHeap = NULL;
+    mDataOffset = 0;
+    mDataSize   = 0;
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+    return  true;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+create(size_t const extParamSize, uint32_t const u4ExtMsgType)
+{
+    bool ret = false;
+    //
+    size_t const extDataSize = sizeof(DataHeader) + extParamSize;
+    sp<IMemoryHeap> heap = 0;
+    sp<IMemory> dataPtr = 0;
+
+    //  (1) Check arguments.
+    if  ( 0 == extParamSize )
+    {
+        ALOGW("[MtkCamMsgExtDataHelper::create] extParamSize==0 \r\n");
+    }
+
+    //  (2) Allocate memory
+    heap = new MemoryHeapBase(extDataSize, 0, NULL);
+    dataPtr = new MemoryBase(heap, 0, extDataSize);
+
+    //  (3) Initialize.
+    ret = init(dataPtr);
+    if  ( ! ret )
+    {
+        ALOGE("[MtkCamMsgExtDataHelper::create] init fail \r\n");
+        goto lbExit;
+    }
+
+    //  (4) Assign the header.
+    mExtDataHdr.extMsgType = u4ExtMsgType;
+    ::memcpy(((uint8_t*)mspHeap->base()) + mDataOffset, &mExtDataHdr, sizeof(DataHeader));
+
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+destroy()
+{
+    return  uninit();
+}
+
+
+uint8_t*
+MtkCamMsgExtDataHelper::
+getExtParamBase() const
+{
+    return  mIsValid
+        ?   static_cast<uint8_t*>(mspHeap->base()) + mDataOffset + sizeof(DataHeader)
+        :   NULL;
+}
+
+
+size_t
+MtkCamMsgExtDataHelper::
+getExtParamSize() const
+{
+    return  mIsValid
+        ?   (mDataSize - sizeof(DataHeader))
+        :   0;
+}
+
+
+ssize_t
+MtkCamMsgExtDataHelper::
+getExtParamOffset() const
+{
+    return  mIsValid
+        ?   (mDataOffset + sizeof(DataHeader))
+        :   0;
+}
+
+
+}; // namespace android
diff --git a/camera/libcamera_client_mtk/MtkCameraParameters.cpp b/camera/libcamera_client_mtk/MtkCameraParameters.cpp
new file mode 100644
index 0000000..e0f0a39
--- /dev/null
+++ b/camera/libcamera_client_mtk/MtkCameraParameters.cpp
@@ -0,0 +1,456 @@
+﻿/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "MTKCameraParams"
+#include <utils/Log.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <camera/MtkCameraParameters.h>
+
+namespace android {
+
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  App Mode.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::PROPERTY_KEY_CLIENT_APPMODE[]   = "client.appmode";
+//
+const char MtkCameraParameters::APP_MODE_NAME_DEFAULT[]         = "Default";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ENG[]         = "MtkEng";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ATV[]         = "MtkAtv";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_STEREO[]      = "MtkStereo";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_VT[]          = "MtkVt";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_PHOTO[]       = "MtkPhoto";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_VIDEO[]       = "MtkVideo";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ZSD[]         = "MtkZsd";
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Scene Mode
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::SCENE_MODE_NORMAL[] = "normal";
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Face Beauty
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL[]       = "fb-smooth-level";
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL_MIN[]   = "fb-smooth-level-min";
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL_MAX[]   = "fb-smooth-level-max";
+//
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR[]         = "fb-skin-color";
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR_MIN[]     = "fb-skin-color-min";
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR_MAX[]     = "fb-skin-color-max";
+//
+const char MtkCameraParameters::KEY_FB_SHARP[]              = "fb-sharp";
+const char MtkCameraParameters::KEY_FB_SHARP_MIN[]          = "fb-sharp-min";
+const char MtkCameraParameters::KEY_FB_SHARP_MAX[]          = "fb-sharp-max";
+//
+const char MtkCameraParameters::KEY_FB_ENLARGE_EYE[]        = "fb-enlarge-eye";
+const char MtkCameraParameters::KEY_FB_ENLARGE_EYE_MIN[]    = "fb-enlarge-eye-min";
+const char MtkCameraParameters::KEY_FB_ENLARGE_EYE_MAX[]    = "fb-enlarge-eye-max";
+//
+const char MtkCameraParameters::KEY_FB_SLIM_FACE[]          = "fb-slim-face";
+const char MtkCameraParameters::KEY_FB_SLIM_FACE_MIN[]      = "fb-slim-face-min";
+const char MtkCameraParameters::KEY_FB_SLIM_FACE_MAX[]      = "fb-slim-face-max";
+//
+const char MtkCameraParameters::KEY_FB_EXTREME_BEAUTY[]     = "fb-extreme-beauty";
+//
+const char MtkCameraParameters::KEY_FB_TOUCH_POS[]          = "fb-touch-pos";
+//
+const char MtkCameraParameters::KEY_FB_FACE_POS[]           = "fb-face-pos";
+//
+const char MtkCameraParameters::KEY_FACE_BEAUTY[]           = "face-beauty";
+//
+const char MtkCameraParameters::KEY_FB_EXTREME_SUPPORTED[]  = "fb-extreme-beauty-supported";
+//
+const char MtkCameraParameters::KEY_FEATURE_MAX_FPS[]       = "feature-max-fps";
+//
+const char MtkCameraParameters::KEY_VIDEO_FACE_BEAUTY_SUPPORTED[] = "vfb-supported";
+
+
+//
+const char MtkCameraParameters::KEY_EXPOSURE[] = "exposure";
+const char MtkCameraParameters::KEY_EXPOSURE_METER[] = "exposure-meter";
+const char MtkCameraParameters::KEY_ISO_SPEED[] = "iso-speed";
+const char MtkCameraParameters::KEY_AE_MODE[] = "ae-mode";
+const char MtkCameraParameters::KEY_FOCUS_METER[] = "focus-meter";
+const char MtkCameraParameters::KEY_EDGE[] = "edge";
+const char MtkCameraParameters::KEY_HUE[] = "hue";
+const char MtkCameraParameters::KEY_SATURATION[] = "saturation";
+const char MtkCameraParameters::KEY_BRIGHTNESS[] = "brightness";
+const char MtkCameraParameters::KEY_CONTRAST[] = "contrast";
+const char MtkCameraParameters::KEY_AF_LAMP_MODE [] = "aflamp-mode";
+const char MtkCameraParameters::KEY_STEREO_3D_PREVIEW_SIZE[] = "stereo3d-preview-size";
+const char MtkCameraParameters::KEY_STEREO_3D_PICTURE_SIZE[] = "stereo3d-picture-size";
+const char MtkCameraParameters::KEY_STEREO_3D_TYPE [] = "stereo3d-type";
+const char MtkCameraParameters::KEY_STEREO_3D_MODE [] = "stereo3d-mode";
+const char MtkCameraParameters::KEY_STEREO_3D_IMAGE_FORMAT [] = "stereo3d-image-format";
+
+// ZSD
+const char MtkCameraParameters::KEY_ZSD_MODE[] = "zsd-mode"; 
+const char MtkCameraParameters::KEY_SUPPORTED_ZSD_MODE[] = "zsd-supported";
+//
+const char MtkCameraParameters::KEY_FPS_MODE[] = "fps-mode";
+//
+const char MtkCameraParameters::KEY_FOCUS_DRAW[] = "af-draw";
+//
+const char MtkCameraParameters::KEY_CAPTURE_MODE[] = "cap-mode";
+const char MtkCameraParameters::KEY_SUPPORTED_CAPTURE_MODES[] = "cap-mode-values";
+const char MtkCameraParameters::KEY_CAPTURE_PATH[] = "capfname";
+const char MtkCameraParameters::KEY_BURST_SHOT_NUM[] = "burst-num";
+//
+const char MtkCameraParameters::KEY_MATV_PREVIEW_DELAY[] = "tv-delay";
+const char MtkCameraParameters::KEY_PANORAMA_IDX[] = "pano-idx";
+const char MtkCameraParameters::KEY_PANORAMA_DIR[] = "pano-dir";
+
+// Values for KEY_EXPOSURE
+const char MtkCameraParameters::EXPOSURE_METER_SPOT[] = "spot";
+const char MtkCameraParameters::EXPOSURE_METER_CENTER[] = "center";
+const char MtkCameraParameters::EXPOSURE_METER_AVERAGE[] = "average";
+
+// Valeus for KEY_ISO_SPEED
+const char MtkCameraParameters::ISO_SPEED_AUTO[] = "auto";
+const char MtkCameraParameters::ISO_SPEED_100[] = "100";
+const char MtkCameraParameters::ISO_SPEED_200[] = "200";
+const char MtkCameraParameters::ISO_SPEED_400[] = "400";
+const char MtkCameraParameters::ISO_SPEED_800[] = "800";
+const char MtkCameraParameters::ISO_SPEED_1600[] = "1600";
+
+// Values for KEY_AE_MODE = "ae-mode"
+
+// Values for KEY_FOCUS_METER
+const char MtkCameraParameters::FOCUS_METER_SPOT[] = "spot";
+const char MtkCameraParameters::FOCUS_METER_MULTI[] = "multi";
+
+// AWB2PASS
+const char MtkCameraParameters::KEY_AWB2PASS[] = "awb-2pass"; 
+
+
+//
+//  Camera Mode
+const char MtkCameraParameters::KEY_CAMERA_MODE[] = "mtk-cam-mode";
+// Values for KEY_CAMERA_MODE
+const int MtkCameraParameters::CAMERA_MODE_NORMAL  = 0;
+const int MtkCameraParameters::CAMERA_MODE_MTK_PRV = 1;
+const int MtkCameraParameters::CAMERA_MODE_MTK_VDO = 2;
+const int MtkCameraParameters::CAMERA_MODE_MTK_VT  = 3;
+
+// Values for KEY_FPS_MODE
+const int MtkCameraParameters::FPS_MODE_NORMAL = 0;
+const int MtkCameraParameters::FPS_MODE_FIX = 1;
+
+// Values for raw save mode
+
+// Values for KEY_FOCUS_DRAW
+
+// Values for capture mode
+const char MtkCameraParameters::CAPTURE_MODE_PANORAMA_SHOT[] = "panoramashot";
+const char MtkCameraParameters::CAPTURE_MODE_BURST_SHOT[] = "burstshot";
+const char MtkCameraParameters::CAPTURE_MODE_NORMAL[] = "normal";
+const char MtkCameraParameters::CAPTURE_MODE_BEST_SHOT[] = "bestshot";
+const char MtkCameraParameters::CAPTURE_MODE_EV_BRACKET_SHOT[] = "evbracketshot";
+const char MtkCameraParameters::CAPTURE_MODE_SMILE_SHOT[] = "smileshot";
+const char MtkCameraParameters::CAPTURE_MODE_MAV_SHOT[] = "mav"; 
+const char MtkCameraParameters::CAPTURE_MODE_AUTO_PANORAMA_SHOT[] = "autorama"; 
+const char MtkCameraParameters::CAPTURE_MODE_MOTION_TRACK_SHOT[] = "motiontrack"; 
+const char MtkCameraParameters::CAPTURE_MODE_HDR_SHOT[] = "hdr"; 
+const char MtkCameraParameters::CAPTURE_MODE_ASD_SHOT[] = "asd"; 
+const char MtkCameraParameters::CAPTURE_MODE_ZSD_SHOT[] = "zsd";
+const char MtkCameraParameters::CAPTURE_MODE_PANO_3D[] = "pano_3d"; 
+const char MtkCameraParameters::CAPTURE_MODE_SINGLE_3D[] = "single_3d"; 
+const char MtkCameraParameters::CAPTURE_MODE_FACE_BEAUTY[] = "face_beauty"; 
+const char MtkCameraParameters::CAPTURE_MODE_CONTINUOUS_SHOT[] = "continuousshot";
+const char MtkCameraParameters::CAPTURE_MODE_MULTI_MOTION[] = "multi_motion";
+const char MtkCameraParameters::CAPTURE_MODE_GESTURE_SHOT[] = "gestureshot";
+
+// Values for panorama direction settings
+const char MtkCameraParameters::PANORAMA_DIR_RIGHT[] = "right";
+const char MtkCameraParameters::PANORAMA_DIR_LEFT[] = "left";
+const char MtkCameraParameters::PANORAMA_DIR_TOP[] = "top";
+const char MtkCameraParameters::PANORAMA_DIR_DOWN[] = "down";
+
+//
+const int MtkCameraParameters::ENABLE = 1;
+const int MtkCameraParameters::DISABLE = 0;
+
+// Values for KEY_EDGE, KEY_HUE, KEY_SATURATION, KEY_BRIGHTNESS, KEY_CONTRAST
+const char MtkCameraParameters::HIGH[] = "high";
+const char MtkCameraParameters::MIDDLE[] = "middle";
+const char MtkCameraParameters::LOW[] = "low";
+
+// Preview Internal Format.
+const char MtkCameraParameters::KEY_PREVIEW_INT_FORMAT[] = "prv-int-fmt";
+
+// Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+// and KEY_VIDEO_FRAME_FORMAT
+const char MtkCameraParameters::PIXEL_FORMAT_YUV420I[] = "yuv420i-yyuvyy-3plane";
+const char MtkCameraParameters::PIXEL_FORMAT_YV12_GPU[] = "yv12-gpu";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_UYVY[] = "yuv422i-uyvy";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_VYUY[] = "yuv422i-vyuy";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_YVYU[] = "yuv422i-yvyu";
+
+const char MtkCameraParameters::PIXEL_FORMAT_BAYER8[] = "bayer8"; 
+const char MtkCameraParameters::PIXEL_FORMAT_BAYER10[] = "bayer10";  
+
+const char MtkCameraParameters::PIXEL_FORMAT_BITSTREAM[] = "bitstream";
+
+const char MtkCameraParameters::KEY_BRIGHTNESS_VALUE[] = "brightness_value";
+
+// ISP Operation mode for meta mode use 
+const char MtkCameraParameters::KEY_ISP_MODE[] = "isp-mode"; 
+// AF 
+const char MtkCameraParameters::KEY_AF_X[] = "af-x"; 
+const char MtkCameraParameters::KEY_AF_Y[] = "af-y"; 
+// Effect 
+const char MtkCameraParameters::EFFECT_SEPIA_BLUE[] = "sepiablue";
+const char MtkCameraParameters::EFFECT_SEPIA_GREEN[] = "sepiagreen";
+const char MtkCameraParameters::EFFECT_NASHVILLE[] = "nashville";
+const char MtkCameraParameters::EFFECT_HEFE[] = "hefe";
+const char MtkCameraParameters::EFFECT_VALENCIA[] = "valencia";
+const char MtkCameraParameters::EFFECT_XPROII[] = "xproll";
+const char MtkCameraParameters::EFFECT_LOFI[] = "lofi";
+const char MtkCameraParameters::EFFECT_SIERRA[] = "sierra";
+const char MtkCameraParameters::EFFECT_KELVIN[] = "kelvin";
+const char MtkCameraParameters::EFFECT_WALDEN[] = "walden";
+const char MtkCameraParameters::EFFECT_F1977[] = "f1977";
+//
+//  on/off => FIXME: should be replaced with TRUE[]
+const char MtkCameraParameters::ON[] = "on";
+const char MtkCameraParameters::OFF[] = "off";
+// 
+const char MtkCameraParameters::WHITE_BALANCE_TUNGSTEN[] = "tungsten";
+//
+const char MtkCameraParameters::ISO_SPEED_ENG[] = "iso-speed-eng";
+const char MtkCameraParameters::KEY_RAW_SAVE_MODE[] = "rawsave-mode";
+const char MtkCameraParameters::KEY_RAW_PATH[] = "rawfname";
+
+const char MtkCameraParameters::KEY_FAST_CONTINUOUS_SHOT[] = "fast-continuous-shot";
+
+const char MtkCameraParameters::KEY_CSHOT_INDICATOR[] = "cshot-indicator";
+
+// AF EM MODE
+const char MtkCameraParameters::KEY_FOCUS_ENG_MODE[]		= "afeng-mode";
+const char MtkCameraParameters::KEY_FOCUS_ENG_STEP[] 		= "afeng-pos";
+const char MtkCameraParameters::KEY_FOCUS_ENG_MAX_STEP[] 	= "afeng-max-focus-step";
+const char MtkCameraParameters::KEY_FOCUS_ENG_MIN_STEP[] 	= "afeng-min-focus-step";
+const char MtkCameraParameters::KEY_FOCUS_ENG_BEST_STEP[]   = "afeng-best-focus-step";
+const char MtkCameraParameters::KEY_RAW_DUMP_FLAG[]         = "afeng_raw_dump_flag";
+const char MtkCameraParameters::KEY_PREVIEW_DUMP_RESOLUTION[] = "prv-dump-res";
+// Values for KEY_PREVIEW_DUMP_RESOLUTION
+const int MtkCameraParameters::PREVIEW_DUMP_RESOLUTION_NORMAL  = 0;
+const int MtkCameraParameters::PREVIEW_DUMP_RESOLUTION_CROP  = 1;
+//
+const char MtkCameraParameters::KEY_MAX_NUM_DETECTED_OBJECT[] = "max-num-ot";
+
+// KEY for Video HDR
+const char MtkCameraParameters::KEY_VIDEO_HDR[] = "video-hdr";
+const char MtkCameraParameters::KEY_VIDEO_HDR_MODE[] = "video-hdr-mode";
+const char MtkCameraParameters::VIDEO_HDR_MODE_IVHDR[] = "video-hdr-mode-ivhdr";
+const char MtkCameraParameters::VIDEO_HDR_MODE_MVHDR[] = "video-hdr-mode-mvhdr";
+
+// KEY for [Engineer Mode] Add new camera paramters for new requirements
+const char MtkCameraParameters::KEY_ENG_AE_ENABLE[] = "ae-e";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_SHUTTER_SPEED[] = "prv-ss";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_SENSOR_GAIN[] = "prv-sr-g";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_ISP_GAIN[] = "prv-isp-g";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_AE_INDEX[] = "prv-ae-i";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_SENSOR_GAIN[] = "cap-sr-g";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_ISP_GAIN[] = "cap-isp-g";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_SHUTTER_SPEED[] = "cap-ss";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_ISO[] = "cap-iso";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_VALUE[] = "flash-duty-value";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_MIN[] = "flash-duty-min";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_MAX[] = "flash-duty-max";
+const char MtkCameraParameters::KEY_ENG_ZSD_ENABLE[] = "eng-zsd-e";
+const char MtkCameraParameters::KEY_SENSOR_TYPE[] = "sensor-type";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_FPS[] = "eng-prv-fps";
+const char MtkCameraParameters::KEY_ENG_MSG[] = "eng-msg";
+const int  MtkCameraParameters::KEY_ENG_FLASH_DUTY_DEFAULT_VALUE = -1;
+const int  MtkCameraParameters::KEY_ENG_FLASH_STEP_DEFAULT_VALUE = -1;
+const char MtkCameraParameters::KEY_ENG_FLASH_STEP_MIN[] = "flash-step-min";
+const char MtkCameraParameters::KEY_ENG_FLASH_STEP_MAX[] = "flash-step-max";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL[] = "focus-fs-fi";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX[] = "focus-fs-fi-max";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN[] = "focus-fs-fi-min";
+const int  MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX_DEFAULT = 65535;
+const int  MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN_DEFAULT = 0;
+const char MtkCameraParameters::KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US[] = "eng-prv-fius";
+const char MtkCameraParameters::KEY_ENG_PARAMETER1[] = "eng-p1";
+const char MtkCameraParameters::KEY_ENG_PARAMETER2[] = "eng-p2";
+const char MtkCameraParameters::KEY_ENG_PARAMETER3[] = "eng-p3";
+
+// KEY for [Engineer Mode] Add new camera paramters for ev value
+const char MtkCameraParameters::KEY_ENG_EV_VALUE[] = "eng-ev-value";
+const char MtkCameraParameters::KEY_ENG_EVB_ENABLE[] = "eng-evb-enable";
+
+
+const char MtkCameraParameters::KEY_ENG_SAVE_SHADING_TABLE[] = "eng-s-shad-t";
+const char MtkCameraParameters::KEY_ENG_SHADING_TABLE[] = "eng-shad-t";
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_AUTO = 0;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_LOW = 1;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_MIDDLE = 2;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_HIGH = 3;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_TSF = 4;
+
+// KEY for [Engineer Mode] Add new camera paramters for ev calibration
+const char MtkCameraParameters::KEY_ENG_EV_CALBRATION_OFFSET_VALUE[] = "ev-cal-o";
+
+// KEY for [Engineer Mode] MFLL: Multi-frame lowlight capture
+const char MtkCameraParameters::KEY_ENG_MFLL_SUPPORTED[] = "eng-mfll-s";
+const char MtkCameraParameters::KEY_ENG_MFLL_ENABLE[] = "eng-mfll-e";
+const char MtkCameraParameters::KEY_ENG_MFLL_PICTURE_COUNT[] = "eng-mfll-pc";
+
+// KEY for [Engineer Mode] Two more sensor mode
+const char MtkCameraParameters::KEY_ENG_SENOSR_MODE_SLIM_VIDEO1_SUPPORTED[] = "sv1-s";
+const char MtkCameraParameters::KEY_ENG_SENOSR_MODE_SLIM_VIDEO2_SUPPORTED[] = "sv2-s";
+
+// KEY for [Engineer Mode] Video raw dump
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_2M_SUPPORTED[] = "vdr-r2m-s";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_4K2K_SUPPORTED[] = "vdr-r4k2k-s";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_CROP_CENTER_2M_SUPPORTED[] = "vdr-cc2m-s";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_RESIZE[] = "vdr-r";
+
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_SUPPORTED[] = "vrd-mfr-s";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_ENABLE[] = "vrd-mfr-e";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MIN[] = "vrd-mfr-min";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MAX[] = "vrd-mfr-max";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_LOW[] = "vrd-mfr-low";
+const char MtkCameraParameters::KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_HIGH[] = "vrd-mfr-high";
+
+const char MtkCameraParameters::KEY_ENG_MTK_AWB_SUPPORTED[] = "mtk-awb-s";
+const char MtkCameraParameters::KEY_ENG_SENSOR_AWB_SUPPORTED[] = "sr-awb-s";
+const char MtkCameraParameters::KEY_ENG_MTK_AWB_ENABLE[] = "mtk-awb-e";
+const char MtkCameraParameters::KEY_ENG_SENSOR_AWB_ENABLE[] = "sr-awb-e";
+
+const char MtkCameraParameters::KEY_ENG_MTK_SHADING_SUPPORTED[] = "mtk-shad-s";
+const char MtkCameraParameters::KEY_ENG_MTK_1to3_SHADING_SUPPORTED[] = "mtk-123-shad-s";
+const char MtkCameraParameters::KEY_ENG_SENSOR_SHADNING_SUPPORTED[] = "sr-shad-s";
+const char MtkCameraParameters::KEY_ENG_MTK_SHADING_ENABLE[] = "mtk-shad-e";
+const char MtkCameraParameters::KEY_ENG_MTK_1to3_SHADING_ENABLE[] = "mtk-123-shad-e";
+const char MtkCameraParameters::KEY_ENG_SENSOR_SHADNING_ENABLE[] = "sr-shad-e";
+
+const char MtkCameraParameters::KEY_ENG_MANUAL_MULTI_NR_SUPPORTED[] = "mnr-s";
+const char MtkCameraParameters::KEY_ENG_MANUAL_MULTI_NR_ENABLE[] = "mnr-e";
+const char MtkCameraParameters::KEY_ENG_MANUAL_MULTI_NR_TYPE[] = "mnr-t";
+const char MtkCameraParameters::KEY_ENG_VIDEO_HDR_SUPPORTED[] = "vhdr-s";
+const char MtkCameraParameters::KEY_ENG_VIDEO_HDR_MODE[]= "vhdr-m";
+
+// Slow motion
+const char MtkCameraParameters::KEY_HSVR_PRV_SIZE[] = "hsvr-prv-size";
+const char MtkCameraParameters::KEY_SUPPORTED_HSVR_PRV_SIZE[] = "hsvr-prv-size-values";
+const char MtkCameraParameters::KEY_HSVR_PRV_FPS[] = "hsvr-prv-fps";
+const char MtkCameraParameters::KEY_SUPPORTED_HSVR_PRV_FPS[] = "hsvr-prv-fps-values";
+const char MtkCameraParameters::KEY_HSVR_SIZE_FPS[] = "hsvr-size-fps";
+const char MtkCameraParameters::KEY_SUPPORTED_HSVR_SIZE_FPS[] = "hsvr-size-fps-values";
+
+
+// MFB
+const char MtkCameraParameters::KEY_MFB_MODE[] = "mfb";
+const char MtkCameraParameters::KEY_MFB_MODE_MFLL[] = "mfll";
+const char MtkCameraParameters::KEY_MFB_MODE_AIS[] = "ais";
+
+//PIP
+const char MtkCameraParameters::KEY_PIP_MAX_FRAME_RATE_ZSD_ON[] = "pip-fps-zsd-on";
+const char MtkCameraParameters::KEY_PIP_MAX_FRAME_RATE_ZSD_OFF[] = "pip-fps-zsd-off";
+
+// Dynamic Frame Rate
+const char MtkCameraParameters::KEY_DYNAMIC_FRAME_RATE[] = "dynamic-frame-rate";
+const char MtkCameraParameters::KEY_DYNAMIC_FRAME_RATE_SUPPORTED[] = "dynamic-frame-rate-supported";
+
+// Stereo Feature
+const char MtkCameraParameters::KEY_STEREO_REFOCUS_MODE[] = "stereo-image-refocus";
+const char MtkCameraParameters::KEY_STEREO_DEPTHAF_MODE[] = "stereo-depth-af";
+const char MtkCameraParameters::KEY_STEREO_DISTANCE_MODE[] = "stereo-distance-measurement";
+const char MtkCameraParameters::KEY_STEREO_PICTURE_SIZE[] = "stereo-picture-size";
+const char MtkCameraParameters::KEY_SUPPORTED_STEREO_PICTURE_SIZE[] = "stereo-picture-size-values";
+const char MtkCameraParameters::KEY_REFOCUS_PICTURE_SIZE[] = "refocus-picture-size";
+const char MtkCameraParameters::KEY_SUPPORTED_REFOCUS_PICTURE_SIZE[] = "refocus-picture-size-values";
+const char MtkCameraParameters::KEY_STEREO_PREVIEW_FRAME_RATE[] = "stereo-preview-frame-rate";
+const char MtkCameraParameters::KEY_STEREO_CAPTURE_FRAME_RATE[] = "stereo-capture-frame-rate";
+
+// Image refocus
+const char MtkCameraParameters::KEY_REFOCUS_JPS_FILE_NAME[] = "refocus-jps-file-name";
+
+// 3DNR
+const char MtkCameraParameters::KEY_3DNR_MODE[] = "3dnr-mode";
+
+// manual shutter speed/gain 
+const char MtkCameraParameters::KEY_ENG_MANUAL_SHUTTER_SPEED[] = "m-ss"; 
+const char MtkCameraParameters:: KEY_ENG_MANUAL_SENSOR_GAIN[] = "m-sr-g"; 
+
+// sensor mode 
+const char MtkCameraParameters::KEY_ENG_SENOSR_MODE_SUPPORTED[] = "sen-mode-s"; 
+
+// Gesture Shot
+const char MtkCameraParameters::KEY_GESTURE_SHOT[] = "gesture-shot";
+const char MtkCameraParameters::KEY_GESTURE_SHOT_SUPPORTED[] = "gesture-shot-supported";
+
+// Native PIP
+const char MtkCameraParameters::KEY_NATIVE_PIP[] = "native-pip";
+const char MtkCameraParameters::KEY_NATIVE_PIP_SUPPORTED[] = "native-pip-supported";
+
+// PDAF    
+const char MtkCameraParameters::KEY_PDAF[] = "pdaf";
+const char MtkCameraParameters::KEY_PDAF_SUPPORTED[] = "pdaf-supported";
+
+// Flash Calibration 
+const char MtkCameraParameters::KEY_ENG_FLASH_CALIBRATION[] = "flash-cali"; 
+
+// flash-on
+const char MtkCameraParameters::KEY_FLASH_ON_VALUE[] = "flash-on";		//wg add flash onoff interface
+
+const char MtkCameraParameters::KEY_MORPHO_HHT[] = "night-shot";
+
+const char MtkCameraParameters::KEY_MORPHO_HHT_ANTI_MOTION[] = "night-anti-motion";
+}; // namespace android
diff --git a/camera/libcamera_client_mtk/NOTICE b/camera/libcamera_client_mtk/NOTICE
new file mode 100755
index 0000000..0519ecb
--- /dev/null
+++ b/camera/libcamera_client_mtk/NOTICE
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff --git a/camera/libcamera_client_mtk/README b/camera/libcamera_client_mtk/README
new file mode 100755
index 0000000..d6fccf1
--- /dev/null
+++ b/camera/libcamera_client_mtk/README
@@ -0,0 +1,14 @@
+WHAT IT DOES?
+=============
+camera framework mtk parameters related module files.
+
+
+HOW IT WAS BUILT?
+==================
+It can build the following shared library file :
+libcamera_client_mtk.so
+
+
+HOW TO USE IT?
+==============
+Provide related api for camera framework mtk parameters related module.
\ No newline at end of file
diff --git a/include/camera/Camera.h b/include/camera/Camera.h
index 2b60842..4c00efe 100644
--- a/include/camera/Camera.h
+++ b/include/camera/Camera.h
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -68,6 +73,10 @@ public:
         USE_CALLING_UID = ICameraService::USE_CALLING_UID
     };
 
+#ifdef MTK_HARDWARE
+    static  status_t    getProperty(String8 const& key, String8& value);
+    static  status_t    setProperty(String8 const& key, String8 const& value);
+#endif
             // construct a camera client from an existing remote
     static  sp<Camera>  create(const sp<ICamera>& camera);
     static  sp<Camera>  connect(int cameraId,
diff --git a/include/camera/CameraParameters.h b/include/camera/CameraParameters.h
index 078f8a3..308dbad 100644
--- a/include/camera/CameraParameters.h
+++ b/include/camera/CameraParameters.h
@@ -100,6 +100,11 @@ public:
     void setPictureFormat(const char *format);
     const char *getPictureFormat() const;
 
+#ifdef MTK_HARDWARE
+    void setCameraPictureFlip(const int format);
+    const int getCameraPictureFlip() const;
+#endif
+
     void dump() const;
     status_t dump(int fd, const Vector<String16>& args) const;
 
@@ -159,6 +164,9 @@ public:
     // Example value: "jpeg" or PIXEL_FORMAT_XXX constants. Read/write.
     static const char KEY_PICTURE_FORMAT[];
     // Supported image formats for captured pictures.
+#ifdef MTK_HARDWARE
+    static const char SNAPSHOT_PICTURE_FLIP[];//add by xueweifeng
+#endif
     // Example value: "jpeg,rgb565". Read only.
     static const char KEY_SUPPORTED_PICTURE_FORMATS[];
     // The width (in pixels) of EXIF thumbnail in Jpeg picture.
diff --git a/include/camera/ICameraService.h b/include/camera/ICameraService.h
index f7f06bb..0e50c22 100644
--- a/include/camera/ICameraService.h
+++ b/include/camera/ICameraService.h
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -53,6 +58,12 @@ public:
         GET_LEGACY_PARAMETERS,
         SUPPORTS_CAMERA_API,
         CONNECT_LEGACY,
+//!++
+#ifdef MTK_HARDWARE
+        GET_PROPERTY, 
+        SET_PROPERTY, 
+#endif
+//!--
     };
 
     enum {
@@ -119,6 +130,13 @@ public:
             /*out*/
             sp<ICameraDeviceUser>& device) = 0;
 
+//!++
+#ifdef MTK_HARDWARE
+    virtual status_t getProperty(String8 const& key, String8& value) const = 0;
+    virtual status_t setProperty(String8 const& key, String8 const& value) = 0;
+#endif
+//!--
+
     virtual status_t getLegacyParameters(
             int cameraId,
             /*out*/
diff --git a/include/camera/MtkCamera.h b/include/camera/MtkCamera.h
new file mode 100644
index 0000000..08f8744
--- /dev/null
+++ b/include/camera/MtkCamera.h
@@ -0,0 +1,297 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+#define _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+
+#include <binder/IMemory.h>
+
+namespace android {
+
+// extended msgType in notifyCallback and dataCallback functions
+enum {
+    MTK_CAMERA_MSG_EXT_NOTIFY       = 0x40000000,
+    MTK_CAMERA_MSG_EXT_DATA         = 0x80000000,
+};
+
+// extended notify message related to MTK_CAMERA_MSG_EXT_NOTIFY used in notifyCallback functions
+enum {
+    //
+    //  Smile Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT      = 0x00000001,
+    //
+    //  Auto Scene Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_ASD               = 0x00000002,
+    //
+    //  Multi Angle View
+    MTK_CAMERA_MSG_EXT_NOTIFY_MAV               = 0x00000003,
+    //
+    // Burst Shutter Callback
+    //  ext2: count-down shutter number; 0: the last one shutter.
+    MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER     = 0x00000004,
+    //
+    // Continuous Shutter Callback
+    //  ext2: current continuous shutter number.
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER= 0x00000005,
+    //
+    // Continuous EndCallback
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END	= 0x00000006,
+
+    // ZSD preview done
+    MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007,
+    //
+    // Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+    MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE      = 0x00000010,
+    //
+    // Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+    //  ext2: 1: CameraService will play shutter sound.
+    MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER           = 0x00000011,
+    //
+    // for EM preview raw dump error notify
+    MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012,
+    //
+    // Gesture Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013,
+    //
+    // Stereo Feature: warning message
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING    = 0x00000014,
+    //
+    // Stereo Feature: distance value
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE   = 0x00000015
+};
+
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // Auto Panorama
+    //  Params:
+    //      int[0]: 0:mAUTORAMAMVCallback, 1:mAUTORAMACallback
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_AUTORAMA            = 0x00000001,
+    //
+    // AF Window Results
+    MTK_CAMERA_MSG_EXT_DATA_AF					= 0x00000002,
+    //
+    // Burst Shot (EV Shot)
+    //      int[0]: the total shut count.
+    //      int[1]: count-down shut number; 0: the last one shut.
+    MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT          = 0x00000003,
+    //
+	//	Continuous Shot
+	//		int[0]: current continuous shut number.
+    MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT     = 0x00000004,
+
+
+    MTK_CAMERA_MSG_EXT_DATA_OT                  = 0x00000005,
+
+    //  Facebeauty Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY          = 0x00000006,
+    //
+    //  MAV Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_MAV                 = 0x00000007,
+    //
+    //  HDR Shot
+    //      int[0]: data type. 0:0EV image.
+    MTK_CAMERA_MSG_EXT_DATA_HDR                 = 0x00000008,
+
+    //
+    // Motion Track
+    //  Params:
+    //      int[0]: 0: frame EIS, 1: captured image, 2: blended image, 3: intermediate data
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK         = 0x00000009,
+
+    //
+    //  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+    //      int[0]: current shut index; 0: the first one shut.
+    MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE    = 0x00000010,
+
+    //
+    //  Stereo Shot
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_JPS                 = 0x00000011,
+
+    //
+    //  Stereo Debug Data
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG          = 0x00000012,
+
+};
+
+//  MTK-extended camera message data helper.
+//  DATA: Header + Params
+class MtkCamMsgExtDataHelper
+{
+public:
+    //  The header type of MTK-extended camera message data.
+    struct DataHeader {
+        uint32_t        extMsgType;
+    };
+
+public:
+    MtkCamMsgExtDataHelper();
+    ~MtkCamMsgExtDataHelper();
+    bool            init(const sp<IMemory>& dataPtr);
+    bool            uninit();
+    bool            create(size_t const extParamSize, uint32_t const u4ExtMsgType);
+    bool            destroy();
+
+    uint8_t*                        getExtParamBase() const;
+    size_t                          getExtParamSize() const;
+    ssize_t                         getExtParamOffset() const;
+    inline uint32_t                 getExtMsgType() const { return mExtDataHdr.extMsgType; }
+    inline DataHeader const&        getExtDataHeader() const { return mExtDataHdr; }
+    inline sp<IMemory>const&        getData() const { return mspData; }
+    inline sp<IMemoryHeap>const&    getHeap() const { return mspHeap; }
+
+protected:
+    bool            mIsValid;
+    sp<IMemory>     mspData;
+    sp<IMemoryHeap> mspHeap;
+    ssize_t         mDataOffset;
+    size_t          mDataSize;
+    DataHeader      mExtDataHdr;
+};
+
+
+// cmdType in sendCommand functions
+enum {
+    CAMERA_CMD_MTK_DEFINE_START     = 0x10000000,
+    CAMERA_CMD_DO_PANORAMA,
+    CAMERA_CMD_CANCEL_PANORAMA,
+    CAMERA_CMD_START_SD_PREVIEW,            //(Smile Detection)
+    CAMERA_CMD_CANCEL_SD_PREVIEW,           //(Smile Detection)
+    CAMERA_CMD_START_OT, 
+    CAMERA_CMD_STOP_OT,  
+    CAMERA_CMD_START_MAV,
+    CAMERA_CMD_STOP_MAV,
+    CAMERA_CMD_START_AUTORAMA,
+    CAMERA_CMD_STOP_AUTORAMA,
+    CAMERA_CMD_GET_MEM_INFO,                //For Video to get PMEM buffer info
+    CAMERA_CMD_GET_REC_BUF_INFO,
+    CAMERA_CMD_CANCEL_CSHOT,
+    CAMERA_CMD_SET_CSHOT_SPEED,
+    CAMERA_CMD_START_3DSHOT,
+    CAMERA_CMD_STOP_3DSHOT,
+    CAMERA_CMD_START_MOTIONTRACK,
+    CAMERA_CMD_STOP_MOTIONTRACK,
+    CAMERA_CMD_START_CLONECAMERA,
+    CAMERA_CMD_SHOT_CLONECAMERA,
+    CAMERA_CMD_STOP_CLONECAMERA,
+    CAMERA_CMD_START_GD_PREVIEW,            //(Gesture Detection)
+    CAMERA_CMD_CANCEL_GD_PREVIEW,           //(Gesture Detection)
+    
+    // For SDK Heartrate
+    CAMERA_CMD_START_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_STOP_HR_PREVIEW,             //(Heartrate Detection)
+    CAMERA_CMD_SETCB_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_SETUSER_HR_PREVIEW,          //(Heartrate Detection)
+};
+
+/*
+ * For Video to get PMEM buffer info
+ *
+ * Command: CAMERA_CMD_GET_MEM_INFO
+ */
+struct CameraMemInfo {
+    enum { eTYPE_PMEM = 0 };
+    uint32_t    u4Type;
+    uint32_t    u4VABase;
+    uint32_t    u4PABase;
+    uint32_t    u4MemSize;
+    uint32_t    u4MemCount;
+};
+
+
+/*
+ *  set camera fatal errors enum
+ *
+ */
+enum {
+    CAMERA_ERROR_NO_MEMORY   = 1000,
+    CAMERA_ERROR_RESET       = 1001,
+    CAMERA_ERROR_CALI_FLASH  = 1002, 
+};
+
+/*
+ * For Video to get buffer info
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecBufInfo {
+    int32_t     i4MemId;
+    uint32_t    u4VirAddr;
+    uint32_t    u4Size;
+};
+
+
+/*
+ * For Video to set setting
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecSetting {
+    int32_t     mi4BufSecu; //security
+    int32_t     mi4BufCohe; //coherent
+};
+
+
+}; // namespace android
+
+#endif  //_MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
diff --git a/include/camera/MtkCameraParameters.h b/include/camera/MtkCameraParameters.h
new file mode 100644
index 0000000..1299c4e
--- /dev/null
+++ b/include/camera/MtkCameraParameters.h
@@ -0,0 +1,507 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERAPARAMETERS_H
+#define _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERAPARAMETERS_H
+
+#include <camera/CameraParameters.h>
+
+namespace android {
+
+
+/**  
+ * @class      MtkCameraParameters
+ * @brief      MTK-proprietary camera parameters.
+ * @details    This class is derived from CameraParameters and defines MTK-proprietary camera parameters.
+ */
+class MtkCameraParameters : public CameraParameters
+{
+public:
+    MtkCameraParameters() : CameraParameters() {}
+    MtkCameraParameters(const String8 &params) { unflatten(params); }
+    ~MtkCameraParameters()  {}
+
+    MtkCameraParameters& operator=(CameraParameters const& params)
+    {
+        unflatten(params.flatten());
+        return  (*this);
+    }
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  App Mode.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char PROPERTY_KEY_CLIENT_APPMODE[];
+    //
+    static const char APP_MODE_NAME_DEFAULT[];
+    static const char APP_MODE_NAME_MTK_ENG[];
+    static const char APP_MODE_NAME_MTK_ATV[];
+    static const char APP_MODE_NAME_MTK_STEREO[];
+    static const char APP_MODE_NAME_MTK_VT[];
+    static const char APP_MODE_NAME_MTK_PHOTO[];
+    static const char APP_MODE_NAME_MTK_VIDEO[];
+    static const char APP_MODE_NAME_MTK_ZSD[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Scene Mode
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char SCENE_MODE_NORMAL[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Face Beauty
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_FB_SMOOTH_LEVEL[];
+    static const char KEY_FB_SMOOTH_LEVEL_MIN[];
+    static const char KEY_FB_SMOOTH_LEVEL_MAX[];
+    //
+    static const char KEY_FB_SKIN_COLOR[];
+    static const char KEY_FB_SKIN_COLOR_MIN[];
+    static const char KEY_FB_SKIN_COLOR_MAX[];
+    //
+    static const char KEY_FB_SHARP[];
+    static const char KEY_FB_SHARP_MIN[];
+    static const char KEY_FB_SHARP_MAX[];
+    //
+    static const char KEY_FB_ENLARGE_EYE[];
+    static const char KEY_FB_ENLARGE_EYE_MIN[];
+    static const char KEY_FB_ENLARGE_EYE_MAX[];
+    //
+    static const char KEY_FB_SLIM_FACE[];
+    static const char KEY_FB_SLIM_FACE_MIN[];
+    static const char KEY_FB_SLIM_FACE_MAX[];
+    //
+    static const char KEY_FB_EXTREME_BEAUTY[];
+    //
+    static const char KEY_FB_TOUCH_POS[];
+    //
+    static const char KEY_FB_FACE_POS[];
+    //
+    static const char KEY_FACE_BEAUTY[];
+    //
+    static const char KEY_FB_EXTREME_SUPPORTED[];
+    //
+    static const char KEY_FEATURE_MAX_FPS[];
+    //
+    static const char KEY_VIDEO_FACE_BEAUTY_SUPPORTED[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_EXPOSURE[];
+    static const char KEY_EXPOSURE_METER[];
+    static const char KEY_ISO_SPEED[];
+    static const char KEY_AE_MODE[];
+    static const char KEY_FOCUS_METER[];
+    static const char KEY_EDGE[];
+    static const char KEY_HUE[];
+    static const char KEY_SATURATION[];
+    static const char KEY_BRIGHTNESS[];
+    static const char KEY_CONTRAST[];
+    static const char KEY_ZSD_MODE[];	
+    static const char KEY_SUPPORTED_ZSD_MODE[];
+    static const char KEY_AWB2PASS[];	
+    static const char KEY_AF_LAMP_MODE [];
+
+    static const char KEY_STEREO_3D_PREVIEW_SIZE[];
+    static const char KEY_STEREO_3D_PICTURE_SIZE[];    
+    static const char KEY_STEREO_3D_TYPE [];		
+    static const char KEY_STEREO_3D_MODE [];
+    static const char KEY_STEREO_3D_IMAGE_FORMAT [];	
+    //
+    static const char KEY_FPS_MODE[];       // normal,fix
+    //
+    static const char KEY_FOCUS_DRAW[];     // 0,1
+    //
+    static const char KEY_CAPTURE_MODE[];   // normal,bestshot,evbracketshot,burstshot,smileshot,panoramashot
+    static const char KEY_SUPPORTED_CAPTURE_MODES[];
+    static const char KEY_CAPTURE_PATH[];
+    static const char KEY_BURST_SHOT_NUM[];
+    //
+    static const char KEY_MATV_PREVIEW_DELAY[];
+    //
+    static const char KEY_PANORAMA_IDX[];
+    static const char KEY_PANORAMA_DIR[];   // right,left,top,bottom
+    //
+    static const char KEY_SENSOR_DEV[];    // main,sub,atv
+    static const char KEY_SUPPORTED_SENSOR_DEVS[];
+	
+    // Values for KEY_EXPOSURE
+    static const char EXPOSURE_METER_SPOT[];
+    static const char EXPOSURE_METER_CENTER[];
+    static const char EXPOSURE_METER_AVERAGE[];
+
+    // Valeus for KEY_ISO_SPEED
+    static const char ISO_SPEED_AUTO[];
+    static const char ISO_SPEED_100[];
+    static const char ISO_SPEED_200[];
+    static const char ISO_SPEED_400[];
+    static const char ISO_SPEED_800[];
+    static const char ISO_SPEED_1600[];
+
+    // Values for KEY_FOCUS_METER
+    static const char FOCUS_METER_SPOT[];
+    static const char FOCUS_METER_MULTI[];
+
+    static const char KEY_CAMERA_MODE[];
+    // Values for KEY_CAMERA_MODE
+    static const int CAMERA_MODE_NORMAL;
+    static const int CAMERA_MODE_MTK_PRV;
+    static const int CAMERA_MODE_MTK_VDO;
+    static const int CAMERA_MODE_MTK_VT;
+
+    // Values for KEY_FPS_MODE
+    static const int FPS_MODE_NORMAL;
+    static const int FPS_MODE_FIX;
+
+    // Values for KEY_CAPTURE_MODE
+    static const char CAPTURE_MODE_PANORAMA_SHOT[];
+    static const char CAPTURE_MODE_BURST_SHOT[];
+    static const char CAPTURE_MODE_NORMAL[];
+    static const char CAPTURE_MODE_BEST_SHOT[];
+    static const char CAPTURE_MODE_EV_BRACKET_SHOT[];
+    static const char CAPTURE_MODE_SMILE_SHOT[];
+    static const char CAPTURE_MODE_AUTO_PANORAMA_SHOT[]; 
+    static const char CAPTURE_MODE_MOTION_TRACK_SHOT[]; 
+    static const char CAPTURE_MODE_MAV_SHOT[]; 
+    static const char CAPTURE_MODE_HDR_SHOT[]; 
+    static const char CAPTURE_MODE_ASD_SHOT[];
+    static const char CAPTURE_MODE_ZSD_SHOT[];
+    static const char CAPTURE_MODE_PANO_3D[]; 
+    static const char CAPTURE_MODE_SINGLE_3D[]; 
+    static const char CAPTURE_MODE_FACE_BEAUTY[]; 	
+    static const char CAPTURE_MODE_CONTINUOUS_SHOT[];
+    static const char CAPTURE_MODE_MULTI_MOTION[];
+    static const char CAPTURE_MODE_GESTURE_SHOT[];
+
+    // Values for KEY_PANORAMA_DIR
+    static const char PANORAMA_DIR_RIGHT[];
+    static const char PANORAMA_DIR_LEFT[];
+    static const char PANORAMA_DIR_TOP[];
+    static const char PANORAMA_DIR_DOWN[];
+    //
+    static const int ENABLE;
+    static const int DISABLE;
+
+    // Values for KEY_EDGE, KEY_HUE, KEY_SATURATION, KEY_BRIGHTNESS, KEY_CONTRAST
+    static const char HIGH[];
+    static const char MIDDLE[];
+    static const char LOW[];
+
+    // Preview Internal Format.
+    static const char KEY_PREVIEW_INT_FORMAT[];
+
+    // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+    // and KEY_VIDEO_FRAME_FORMAT
+    static const char PIXEL_FORMAT_YUV420I[]; // I420
+
+    /**
+     * @var PIXEL_FORMAT_YV12_GPU
+     *
+     * GPU YUV format:
+     *
+     * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
+     * by (W/2) x (H/2) Cr and Cb planes.
+     *
+     * This format assumes
+     * - an even width
+     * - an even height
+     * - a vertical stride equal to the height
+     * - a horizontal stride multiple of 32/16/16 pixels for y/cr/cb respectively
+     *   i.e.
+     *   y_stride = ALIGN(width, 32)
+     *   c_stride = y_stride / 2
+     *
+     *   y_size = y_stride * height
+     *   c_size = c_stride * height / 2
+     *   size = y_size + c_size * 2
+     *   cr_offset = y_size
+     *   cb_offset = y_size + c_size
+     *
+     *   for example:
+     *      width/height = 176x144
+     *      y stride     = 192x144
+     *      cr stride    = 96x72
+     *      cb stride    = 96x72
+     *   
+     */
+    static const char PIXEL_FORMAT_YV12_GPU[];
+
+    /*
+     *  YUV422 format, 1 plane (UYVY)
+     *
+     *  Effective bits per pixel : 16 
+     *
+     *  Y sample at every pixel, U and V sampled at every second pixel horizontally on each line. 
+     *  A macropixel contains 2 pixels in 1 uint32_t.
+     *
+     */
+    static const char PIXEL_FORMAT_YUV422I_UYVY[];   
+    //
+    static const char PIXEL_FORMAT_YUV422I_VYUY[];
+    static const char PIXEL_FORMAT_YUV422I_YVYU[];
+    static const char PIXEL_FORMAT_BAYER8[]; 
+    static const char PIXEL_FORMAT_BAYER10[]; 
+    static const char PIXEL_FORMAT_BITSTREAM[];
+
+    /**
+     * @var KEY_BRIGHTNESS_VALUE
+     *
+     * This is a key string of brightness value, scaled by 10.
+     *
+     */
+    static const char KEY_BRIGHTNESS_VALUE[];
+
+    // ISP Operation mode for meta mode use 
+    static const char KEY_ISP_MODE[];
+    // AF 
+    static const char KEY_AF_X[]; 
+    static const char KEY_AF_Y[]; 
+    static const char KEY_FOCUS_ENG_MAX_STEP[];
+    static const char KEY_FOCUS_ENG_MIN_STEP[];
+    static const char KEY_FOCUS_ENG_BEST_STEP[];
+    static const char KEY_RAW_DUMP_FLAG[];
+    static const char KEY_PREVIEW_DUMP_RESOLUTION[];
+    static const int  PREVIEW_DUMP_RESOLUTION_NORMAL;
+    static const int  PREVIEW_DUMP_RESOLUTION_CROP;
+
+    // Values for effect 
+    static const char EFFECT_SEPIA_BLUE[];
+    static const char EFFECT_SEPIA_GREEN[];    
+    static const char  EFFECT_NASHVILLE[];
+    static const char  EFFECT_HEFE[];
+    static const char  EFFECT_VALENCIA[];
+    static const char  EFFECT_XPROII[];
+    static const char  EFFECT_LOFI[];
+    static const char  EFFECT_SIERRA[];
+    static const char  EFFECT_KELVIN[];
+    static const char  EFFECT_WALDEN[];;
+    static const char  EFFECT_F1977[];
+    // Values for AWB 
+    static const char WHITE_BALANCE_TUNGSTEN[];
+    // Eng
+    static const char ISO_SPEED_ENG[];
+    static const char KEY_FOCUS_ENG_MODE[]; // 0,1,2,3 (0: normal)
+    static const char KEY_FOCUS_ENG_STEP[];	
+    static const char KEY_RAW_SAVE_MODE[];  // on, off
+    static const char KEY_RAW_PATH[];	
+
+	// KEY for Continuous shot speed
+    static const char KEY_FAST_CONTINUOUS_SHOT[];
+
+    // KEY for Video HDR
+    static const char KEY_VIDEO_HDR[];
+    static const char KEY_VIDEO_HDR_MODE[];    
+    static const char VIDEO_HDR_MODE_IVHDR[];
+    static const char VIDEO_HDR_MODE_MVHDR[];
+
+    static const char KEY_MAX_NUM_DETECTED_OBJECT[];
+
+    // KEY for c_shot indicator 
+    static const char KEY_CSHOT_INDICATOR[];
+
+    // KEY for [Engineer Mode] Add new camera paramters for new requirements
+    static const char KEY_ENG_AE_ENABLE[];
+    static const char KEY_ENG_PREVIEW_SHUTTER_SPEED[];
+    static const char KEY_ENG_PREVIEW_SENSOR_GAIN[];
+    static const char KEY_ENG_PREVIEW_ISP_GAIN[];
+    static const char KEY_ENG_PREVIEW_AE_INDEX[];
+    static const char KEY_ENG_CAPTURE_SENSOR_GAIN[];
+    static const char KEY_ENG_CAPTURE_ISP_GAIN[];
+    static const char KEY_ENG_CAPTURE_SHUTTER_SPEED[];
+    static const char KEY_ENG_CAPTURE_ISO[];
+    static const char KEY_ENG_FLASH_DUTY_VALUE[];
+    static const char KEY_ENG_FLASH_DUTY_MIN[];
+    static const char KEY_ENG_FLASH_DUTY_MAX[];
+    static const char KEY_ENG_ZSD_ENABLE[];
+    static const char KEY_SENSOR_TYPE[];
+    static const char KEY_ENG_PREVIEW_FPS[];
+    static const char KEY_ENG_MSG[];
+    static const int  KEY_ENG_FLASH_DUTY_DEFAULT_VALUE;
+    static const int  KEY_ENG_FLASH_STEP_DEFAULT_VALUE;
+    static const char KEY_ENG_FLASH_STEP_MIN[];
+    static const char KEY_ENG_FLASH_STEP_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN[];
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX_DEFAULT;
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN_DEFAULT;
+    static const char KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US[];
+    static const char KEY_ENG_PARAMETER1[];
+    static const char KEY_ENG_PARAMETER2[];
+    static const char KEY_ENG_PARAMETER3[];
+
+    static const char KEY_ENG_EV_VALUE[];
+    static const char KEY_ENG_EVB_ENABLE[];
+
+    static const char KEY_ENG_SAVE_SHADING_TABLE[];
+    static const char KEY_ENG_SHADING_TABLE[];
+    static const int KEY_ENG_SHADING_TABLE_AUTO;
+    static const int KEY_ENG_SHADING_TABLE_LOW;
+    static const int KEY_ENG_SHADING_TABLE_MIDDLE;
+    static const int KEY_ENG_SHADING_TABLE_HIGH;
+    static const int KEY_ENG_SHADING_TABLE_TSF;
+
+    // KEY for [Engineer Mode] Add new camera paramters for ev calibration
+    static const char KEY_ENG_EV_CALBRATION_OFFSET_VALUE[];
+
+    // KEY for [Engineer Mode] MFLL: Multi-frame lowlight capture
+    static const char KEY_ENG_MFLL_SUPPORTED[];
+    static const char KEY_ENG_MFLL_ENABLE[];
+    static const char KEY_ENG_MFLL_PICTURE_COUNT[];
+
+    // KEY for [Engineer Mode] Two more sensor mode
+    static const char KEY_ENG_SENOSR_MODE_SLIM_VIDEO1_SUPPORTED[];
+    static const char KEY_ENG_SENOSR_MODE_SLIM_VIDEO2_SUPPORTED[];
+
+    // KEY for [Engineer Mode] Video raw dump
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_2M_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_4K2K_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_CROP_CENTER_2M_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_ENABLE[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MIN[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MAX[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_LOW[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_HIGH[];
+    static const char KEY_ENG_VIDEO_RAW_DUMP_RESIZE[];
+
+    static const char KEY_ENG_MTK_AWB_SUPPORTED[];
+    static const char KEY_ENG_SENSOR_AWB_SUPPORTED[];
+    static const char KEY_ENG_MTK_AWB_ENABLE[];
+    static const char KEY_ENG_SENSOR_AWB_ENABLE[];
+
+    static const char KEY_ENG_MTK_SHADING_SUPPORTED[];
+    static const char KEY_ENG_MTK_1to3_SHADING_SUPPORTED[];
+    static const char KEY_ENG_SENSOR_SHADNING_SUPPORTED[];
+    static const char KEY_ENG_MTK_SHADING_ENABLE[];
+    static const char KEY_ENG_MTK_1to3_SHADING_ENABLE[];
+    static const char KEY_ENG_SENSOR_SHADNING_ENABLE[];
+
+    static const char KEY_ENG_MANUAL_MULTI_NR_SUPPORTED[];
+    static const char KEY_ENG_MANUAL_MULTI_NR_ENABLE[];
+    static const char KEY_ENG_MANUAL_MULTI_NR_TYPE[];
+    static const char KEY_ENG_VIDEO_HDR_SUPPORTED[];
+    static const char KEY_ENG_VIDEO_HDR_MODE[];
+
+    // Slow Motion
+    static const char KEY_HSVR_PRV_SIZE[];
+    static const char KEY_SUPPORTED_HSVR_PRV_SIZE[];
+    static const char KEY_HSVR_PRV_FPS[];
+    static const char KEY_SUPPORTED_HSVR_PRV_FPS[];
+    static const char KEY_HSVR_SIZE_FPS[];
+    static const char KEY_SUPPORTED_HSVR_SIZE_FPS[];
+
+    // MFB
+    static const char KEY_MFB_MODE[];
+    static const char KEY_MFB_MODE_MFLL[];
+    static const char KEY_MFB_MODE_AIS[];
+
+    //PIP
+    static const char KEY_PIP_MAX_FRAME_RATE_ZSD_ON[];
+    static const char KEY_PIP_MAX_FRAME_RATE_ZSD_OFF[];
+
+    // Dynamic Frame Rate
+    static const char KEY_DYNAMIC_FRAME_RATE[];
+    static const char KEY_DYNAMIC_FRAME_RATE_SUPPORTED[];
+
+    // Stereo Feature
+    static const char KEY_STEREO_REFOCUS_MODE[];
+    static const char KEY_STEREO_DEPTHAF_MODE[];
+    static const char KEY_STEREO_DISTANCE_MODE[];
+    static const char KEY_STEREO_PICTURE_SIZE[];
+    static const char KEY_SUPPORTED_STEREO_PICTURE_SIZE[];
+    static const char KEY_REFOCUS_PICTURE_SIZE[];
+    static const char KEY_SUPPORTED_REFOCUS_PICTURE_SIZE[];
+    static const char KEY_STEREO_PREVIEW_FRAME_RATE[];
+    static const char KEY_STEREO_CAPTURE_FRAME_RATE[];
+
+    // Image refocus
+    static const char KEY_REFOCUS_JPS_FILE_NAME[];
+
+    // 3DNR
+    static const char KEY_3DNR_MODE[];
+    // for manual exposure time / sensor gain 
+    static const char KEY_ENG_MANUAL_SHUTTER_SPEED []; 
+    static const char KEY_ENG_MANUAL_SENSOR_GAIN[]; 
+
+    // for sensor mode 
+    static const char KEY_ENG_SENOSR_MODE_SUPPORTED[]; 
+
+    // Gesture Shot
+    static const char KEY_GESTURE_SHOT[];
+    static const char KEY_GESTURE_SHOT_SUPPORTED[];
+
+    // Native PIP
+    static const char KEY_NATIVE_PIP[];
+    static const char KEY_NATIVE_PIP_SUPPORTED[];
+    
+    // PDAF
+    static const char KEY_PDAF[];
+    static const char KEY_PDAF_SUPPORTED[];
+    
+    // Flash Calibration 
+    static const char KEY_ENG_FLASH_CALIBRATION[]; 
+
+    static const char KEY_FLASH_ON_VALUE[];	//wg add flash onoff interface
+
+    static const char KEY_MORPHO_HHT[];
+
+    static const char KEY_MORPHO_HHT_ANTI_MOTION[];
+
+public:     ////    on/off => FIXME: should be replaced with TRUE[]
+    static const char ON[];
+    static const char OFF[];
+};
+
+}; // namespace android
+
+#endif
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index b17be82..db179fb 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -1,3 +1,8 @@
+#
+# Copyright (C) 2014 MediaTek Inc.
+# Modification based on code covered by the mentioned copyright
+# and/or permission notice(s).
+#
 # Copyright 2010 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -82,7 +87,21 @@ endif
 ifneq ($(BOARD_NUMBER_OF_CAMERAS),)
     LOCAL_CFLAGS += -DMAX_CAMERAS=$(BOARD_NUMBER_OF_CAMERAS)
 endif
+#//!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+# Enable MTK stuff
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+    LOCAL_CFLAGS += -DMTK_HARDWARE
+    LOCAL_SHARED_LIBRARIES += libdl
+    LOCAL_SHARED_LIBRARIES += libcamera_client_mtk
+
+    LOCAL_C_INCLUDES += $(TOP)/frameworks/av/include
+    LOCAL_C_INCLUDES += $(TOP)/hardware/include
 
+
+    LOCAL_SRC_FILES += mediatek/CameraService.cpp
+    LOCAL_SRC_FILES += mediatek/api1/CameraClient.cpp
+endif
+#//!----------------------------------------------------------------------------
 LOCAL_MODULE:= libcameraservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index f18245f..0d0085c 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -50,12 +55,19 @@
 #include "utils/CameraTraces.h"
 #include "CameraDeviceFactory.h"
 
+#ifdef MTK_HARDWARE
+    #include <camera/MtkCameraParameters.h>
+#endif
 namespace android {
 
 // ----------------------------------------------------------------------------
 // Logging support -- this is for debugging only
 // Use "adb shell dumpsys media.camera -v 1" to change it.
+#ifdef MTK_HARDWARE
+volatile int32_t gLogLevel = 1;
+#else
 volatile int32_t gLogLevel = 0;
+#endif
 
 #define LOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
 #define LOG2(...) ALOGD_IF(gLogLevel >= 2, __VA_ARGS__);
@@ -126,7 +138,12 @@ void CameraService::onFirstRef()
                     mNumberOfCameras, MAX_CAMERAS);
             mNumberOfCameras = MAX_CAMERAS;
         }
+#ifdef MTK_HARDWARE
+        for (int i = 0; i < MAX_CAMERAS; i++) { // workaround for MATV
+            LOG1("setCameraFree(%d)", i);
+#else
         for (int i = 0; i < mNumberOfCameras; i++) {
+#endif
             setCameraFree(i);
         }
 
@@ -221,6 +238,9 @@ void CameraService::onDeviceStatusChanged(int cameraId,
 }
 
 int32_t CameraService::getNumberOfCameras() {
+#ifdef MTK_HARDWARE
+    LOG1("[getNumberOfCameras] NumberOfCameras:%d \n", mNumberOfCameras);
+#endif
     return mNumberOfCameras;
 }
 
@@ -230,6 +250,9 @@ status_t CameraService::getCameraInfo(int cameraId,
         return -ENODEV;
     }
 
+#ifdef MTK_HARDWARE
+    LOG1("[getCameraInfo] id:%d NumberOfCameras:%d \n", cameraId, mNumberOfCameras);
+#endif
     if (cameraId < 0 || cameraId >= mNumberOfCameras) {
         return BAD_VALUE;
     }
@@ -586,9 +609,27 @@ status_t CameraService::validateConnect(int cameraId,
     }
 
     if (cameraId < 0 || cameraId >= mNumberOfCameras) {
+#ifdef MTK_HARDWARE
+        String8 s8ClientAppMode;
+        status_t status = getProperty(
+            String8(MtkCameraParameters::PROPERTY_KEY_CLIENT_APPMODE), 
+            s8ClientAppMode
+        );
+        if  ( String8(MtkCameraParameters::APP_MODE_NAME_MTK_ATV) == s8ClientAppMode )
+        {
+        ALOGD("CameraService::connect - mATV (pid %d), (cameraId %d) (mNumberOfCameras %d).",
+            callingPid, cameraId, mNumberOfCameras);
+        }
+        else
+#endif
+        {
+//!--
         ALOGE("CameraService::connect X (pid %d) rejected (invalid cameraId %d).",
             callingPid, cameraId);
         return -ENODEV;
+//!++
+        }
+//!--
     }
 
     char value[PROPERTY_VALUE_MAX];
@@ -1234,11 +1275,25 @@ sp<CameraService::BasicClient> CameraService::findClientUnsafe(
 }
 
 CameraService::BasicClient* CameraService::getClientByIdUnsafe(int cameraId) {
+#ifdef MTK_HARDWARE
+    if (0 == mNumberOfCameras && 0 == cameraId)
+    {
+        ALOGW("[CameraService::getClientByIdUnsafe] mNumberOfCameras==0 && cameraId==0, might be mATV \n");
+        return mClient[cameraId].unsafe_get();
+    }
+#endif
     if (cameraId < 0 || cameraId >= mNumberOfCameras) return NULL;
     return mClient[cameraId].unsafe_get();
 }
 
 Mutex* CameraService::getClientLockById(int cameraId) {
+#ifdef MTK_HARDWARE
+    if (0 == mNumberOfCameras && 0 == cameraId)
+    {
+        ALOGW("[CameraService::getClientLockById] mNumberOfCameras==0 && cameraId==0, might be mATV \n");
+        return &mClientLock[cameraId];
+    }
+#endif
     if (cameraId < 0 || cameraId >= mNumberOfCameras) return NULL;
     return &mClientLock[cameraId];
 }
@@ -1307,6 +1362,9 @@ void CameraService::setCameraFree(int cameraId) {
 // media players.
 
 MediaPlayer* CameraService::newMediaPlayer(const char *file) {
+#ifdef MTK_HARDWARE
+    LOG1("[CameraService::newMediaPlayer] + (%s)\r\n", file);
+#endif
     MediaPlayer* mp = new MediaPlayer();
     if (mp->setDataSource(NULL /* httpService */, file, NULL) == NO_ERROR) {
         mp->setAudioStreamType(AUDIO_STREAM_ENFORCED_AUDIBLE);
@@ -1315,10 +1373,16 @@ MediaPlayer* CameraService::newMediaPlayer(const char *file) {
         ALOGE("Failed to load CameraService sounds: %s", file);
         return NULL;
     }
+#ifdef MTK_HARDWARE
+    LOG1("[CameraService::newMediaPlayer] -\r\n");
+#endif
     return mp;
 }
 
 void CameraService::loadSound() {
+#ifdef MTK_HARDWARE
+    LOG1("[CameraService::loadSound] + tid:%d mSoundLock - ref=%d\r\n", ::gettid(), mSoundRef);
+#endif
     Mutex::Autolock lock(mSoundLock);
     LOG1("CameraService::loadSound ref=%d", mSoundRef);
     if (mSoundRef++) return;
@@ -1348,6 +1412,9 @@ void CameraService::playSound(sound_kind kind) {
         player->seekTo(0);
         player->start();
     }
+#ifdef MTK_HARDWARE
+    LOG1("playSound(%d) - tid:%d", kind, ::gettid());
+#endif
 }
 
 // ----------------------------------------------------------------------------
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index 817622b..0eae654 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -37,10 +42,14 @@
 
 #include <camera/ICameraServiceListener.h>
 
+#ifdef MTK_HARDWARE
+/* This needs to be increased if we can have more cameras */
+#define MAX_CAMERAS 2
+#else
 #ifndef MAX_CAMERAS
 #define MAX_CAMERAS 2
 #endif
-
+#endif
 namespace android {
 
 extern volatile int32_t gLogLevel;
@@ -62,6 +71,10 @@ public:
     // Implementation of BinderService<T>
     static char const* getServiceName() { return "media.camera"; }
 
+#ifdef MTK_HARDWARE
+    virtual status_t    getProperty(String8 const& key, String8& value) const;
+    virtual status_t    setProperty(String8 const& key, String8 const& value);
+#endif
                         CameraService();
     virtual             ~CameraService();
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 248f5f5..9e582a2 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -24,6 +24,13 @@
 #include "device1/CameraHardwareInterface.h"
 #include "CameraService.h"
 
+//!++
+#ifdef MTK_HARDWARE
+    #include <camera/MtkCamera.h>
+    #include <camera/MtkCameraParameters.h>
+#endif
+//!--
+
 namespace android {
 
 #define LOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
@@ -92,6 +99,11 @@ status_t CameraClient::initialize(camera_module_t *module) {
     enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
                   CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);
 
+#ifdef MTK_HARDWARE
+    // Enable MTK-extended messages by default
+    enableMsgType(MTK_CAMERA_MSG_EXT_NOTIFY | MTK_CAMERA_MSG_EXT_DATA);
+#endif
+
     LOG1("CameraClient::initialize X (pid %d, id %d)", callingPid, mCameraId);
     return OK;
 }
@@ -101,9 +113,15 @@ status_t CameraClient::initialize(camera_module_t *module) {
 CameraClient::~CameraClient() {
     // this lock should never be NULL
     Mutex* lock = mCameraService->getClientLockById(mCameraId);
+#ifdef MTK_HARDWARE
+    LOG1("CameraClient::~CameraClient: wait lock");
     lock->lock();
+#endif
     mDestructionStarted = true;
     // client will not be accessed from callback. should unlock to prevent dead-lock in disconnect
+#ifdef MTK_HARDWARE
+    LOG1("CameraClient::~CameraClient: do unlock");
+#endif
     lock->unlock();
     int callingPid = getCallingPid();
     LOG1("CameraClient::~CameraClient E (pid %d, this %p)", callingPid, this);
@@ -306,6 +324,11 @@ status_t CameraClient::setPreviewWindow(const sp<IBinder>& binder,
             result = mHardware->setPreviewWindow(window);
         }
     }
+#ifdef MTK_HARDWARE
+    else if ( window == 0 ) {
+        result = mHardware->setPreviewWindow(window);
+    }
+#endif
 
     if (result == NO_ERROR) {
         // Everything has succeeded.  Disconnect the old window and remember the
@@ -440,7 +463,13 @@ status_t CameraClient::startRecordingMode() {
 
     // start recording mode
     enableMsgType(CAMERA_MSG_VIDEO_FRAME);
+//!++
+#ifdef MTK_HARDWARE
+    playRecordingSound();
+#else
     mCameraService->playSound(CameraService::SOUND_RECORDING);
+#endif
+//!--
     result = mHardware->startRecording();
     if (result != NO_ERROR) {
         ALOGE("mHardware->startRecording() failed with status %d", result);
@@ -487,14 +516,34 @@ void CameraClient::stopRecording() {
                   CAMERA_MSG_COMPRESSED_IMAGE);
     disableMsgType(picMsgType);
     mHardware->stopRecording();
+//!++
+#ifdef MTK_HARDWARE
+    playRecordingSound();
+#else
     mCameraService->playSound(CameraService::SOUND_RECORDING);
+#endif
+//!--
 
     mPreviewBuffer.clear();
 }
 
 // release a recording frame
 void CameraClient::releaseRecordingFrame(const sp<IMemory>& mem) {
+//!++
+#ifdef MTK_HARDWARE
+    ssize_t offset;
+    size_t size;
+    sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);
+    void *data = ((uint8_t *)heap->base()) + offset;
+    LOG1("RRF:VA(%p)", data);
+#endif
+//!--
     Mutex::Autolock lock(mLock);
+//!++
+#ifdef MTK_HARDWARE
+    LOG1("RRF:VA(%p), get mLock (%d)", data, getCallingPid()); 
+#endif
+//!--
     if (checkPidAndHardware() != NO_ERROR) return;
     mHardware->releaseRecordingFrame(mem);
 }
@@ -646,6 +695,9 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
     if (result != NO_ERROR) return result;
 
     if (cmd == CAMERA_CMD_SET_DISPLAY_ORIENTATION) {
+#ifdef MTK_HARDWARE
+        LOG1("CAMERA_CMD_SET_DISPLAY_ORIENTATION - tid(%d), (degrees, mirror)=(%d, %d)", ::gettid(), arg1, mCameraFacing);
+#endif
         // Mirror the preview if the camera is front-facing.
         orientation = getOrientation(arg1, mCameraFacing == CAMERA_FACING_FRONT);
         if (orientation == -1) return BAD_VALUE;
@@ -704,6 +756,14 @@ void CameraClient::enableMsgType(int32_t msgType) {
 
 void CameraClient::disableMsgType(int32_t msgType) {
     android_atomic_and(~msgType, &mMsgEnabled);
+//!++
+#ifdef MTK_HARDWARE
+    if (mHardware == 0) {
+        ALOGW("[disableMsgType] mHardware == 0 (CallingPid %d) (tid %d)", getCallingPid(), ::gettid());
+        return;
+    }
+#endif
+//!--
     mHardware->disableMsgType(msgType);
 }
 
@@ -763,18 +823,6 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
         int32_t ext2, void* user) {
     LOG2("notifyCallback(%d)", msgType);
 
-#ifdef MTK_HARDWARE
-    if (msgType == 0x40000000) { //MTK_CAMERA_MSG_EXT_NOTIFY
-        if (ext1 == 0x11) { //MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER
-            msgType = CAMERA_MSG_SHUTTER;
-        }
-        if (ext1 == 0x10) { //MTK_CAMERA_MSG_EXT_CAPTURE_DONE
-            return;
-        }
-        LOG2("MtknotifyCallback(0x%x, 0x%x)", ext1, ext2);
-    }
-#endif
-
     Mutex* lock = getClientLockFromCookie(user);
     if (lock == NULL) return;
     Mutex::Autolock alock(*lock);
@@ -786,6 +834,13 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
     if (!client->lockIfMessageWanted(msgType)) return;
 
     switch (msgType) {
+//!++
+#ifdef MTK_HARDWARE
+        case MTK_CAMERA_MSG_EXT_NOTIFY:
+            client->handleMtkExtNotify(ext1, ext2);
+            break;
+#endif
+//!--
         case CAMERA_MSG_SHUTTER:
             // ext1 is the dimension of the yuv picture.
             client->handleShutter();
@@ -815,35 +870,12 @@ void CameraClient::dataCallback(int32_t msgType,
         return;
     }
 
+    switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
 #ifdef MTK_HARDWARE
-    if (msgType == 0x80000000) { //MTK_CAMERA_MSG_EXT_DATA
-        struct DataHeader {
-            uint32_t        extMsgType;
-        } dataHeader;
-        sp<IMemoryHeap> heap = 0;
-        ssize_t         offset = 0;
-        size_t          size = 0;
-
-        if (dataPtr.get()) {
-
-            heap = dataPtr->getMemory(&offset, &size);
-            if  ( NULL != heap.get() && NULL != heap->base() )
-                ::memcpy(&dataHeader, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
-
-            if (dataHeader.extMsgType == 0x10) { //MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE
-                msgType = CAMERA_MSG_COMPRESSED_IMAGE;
-                sp<MemoryBase> image = new MemoryBase(heap,
-                        (offset + sizeof(DataHeader) + sizeof(uint_t) * 1),
-                        (size - sizeof(DataHeader) - sizeof(uint_t) * 1));
-                client->handleCompressedPicture(image);
-                return;
-            }
-        }
-        LOG2("MtkDataCallback(0x%x)", dataHeader.extMsgType);
-    }
+        case MTK_CAMERA_MSG_EXT_DATA:
+            client->handleMtkExtData(dataPtr, metadata);
+            break;
 #endif
-
-    switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
             break;
@@ -866,6 +898,11 @@ void CameraClient::dataCallbackTimestamp(nsecs_t timestamp,
         int32_t msgType, const sp<IMemory>& dataPtr, void* user) {
     LOG2("dataCallbackTimestamp(%d)", msgType);
 
+#ifdef MTK_HARDWARE
+    sp<CameraClient> spCameraClient;
+    {
+#endif
+
     Mutex* lock = getClientLockFromCookie(user);
     if (lock == NULL) return;
     Mutex::Autolock alock(*lock);
@@ -882,7 +919,15 @@ void CameraClient::dataCallbackTimestamp(nsecs_t timestamp,
         return;
     }
 
+#ifdef MTK_HARDWARE
+    spCameraClient = client;
+#endif
+
     client->handleGenericDataTimestamp(timestamp, msgType, dataPtr);
+
+#ifdef MTK_HARDWARE
+    }
+#endif
 }
 
 // snapshot taken callback
@@ -893,7 +938,9 @@ void CameraClient::handleShutter(void) {
 
     sp<ICameraClient> c = mRemoteCallback;
     if (c != 0) {
+#ifndef MTK_HARDWARE
         mLock.unlock();
+#endif
         c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
         if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
     }
@@ -901,7 +948,9 @@ void CameraClient::handleShutter(void) {
         disableMsgType(CAMERA_MSG_SHUTTER);
     }
 
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
 }
 
 // preview callback - frame buffer update
@@ -919,7 +968,9 @@ void CameraClient::handlePreviewData(int32_t msgType,
     if (!(flags & CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK)) {
         // If the enable bit is off, the copy-out and one-shot bits are ignored
         LOG2("frame callback is disabled");
+#ifndef MTK_HARDWARE
         mLock.unlock();
+#endif
         return;
     }
 
@@ -942,11 +993,15 @@ void CameraClient::handlePreviewData(int32_t msgType,
             copyFrameAndPostCopiedFrame(msgType, c, heap, offset, size, metadata);
         } else {
             LOG2("frame is forwarded");
+#ifndef MTK_HARDWARE
             mLock.unlock();
+#endif
             c->dataCallback(msgType, mem, metadata);
         }
     } else {
+#ifndef MTK_HARDWARE
         mLock.unlock();
+#endif
     }
 }
 
@@ -955,7 +1010,9 @@ void CameraClient::handlePostview(const sp<IMemory>& mem) {
     disableMsgType(CAMERA_MSG_POSTVIEW_FRAME);
 
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_POSTVIEW_FRAME, mem, NULL);
     }
@@ -970,7 +1027,9 @@ void CameraClient::handleRawPicture(const sp<IMemory>& mem) {
     sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);
 
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_RAW_IMAGE, mem, NULL);
     }
@@ -987,7 +1046,9 @@ void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
     }
 
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mem, NULL);
     }
@@ -997,7 +1058,9 @@ void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
 void CameraClient::handleGenericNotify(int32_t msgType,
     int32_t ext1, int32_t ext2) {
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->notifyCallback(msgType, ext1, ext2);
     }
@@ -1006,7 +1069,9 @@ void CameraClient::handleGenericNotify(int32_t msgType,
 void CameraClient::handleGenericData(int32_t msgType,
     const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata) {
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->dataCallback(msgType, dataPtr, metadata);
     }
@@ -1015,7 +1080,9 @@ void CameraClient::handleGenericData(int32_t msgType,
 void CameraClient::handleGenericDataTimestamp(nsecs_t timestamp,
     int32_t msgType, const sp<IMemory>& dataPtr) {
     sp<ICameraClient> c = mRemoteCallback;
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     if (c != 0) {
         c->dataCallbackTimestamp(timestamp, msgType, dataPtr);
     }
@@ -1041,7 +1108,9 @@ void CameraClient::copyFrameAndPostCopiedFrame(
     }
     if (mPreviewBuffer == 0) {
         ALOGE("failed to allocate space for preview buffer");
+#ifndef MTK_HARDWARE
         mLock.unlock();
+#endif
         return;
     }
     previewBuffer = mPreviewBuffer;
@@ -1064,11 +1133,15 @@ void CameraClient::copyFrameAndPostCopiedFrame(
     sp<MemoryBase> frame = new MemoryBase(previewBuffer, 0, size);
     if (frame == 0) {
         ALOGE("failed to allocate space for frame callback");
+#ifndef MTK_HARDWARE
         mLock.unlock();
+#endif
         return;
     }
 
+#ifndef MTK_HARDWARE
     mLock.unlock();
+#endif
     client->dataCallback(msgType, frame, metadata);
 }
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index 63a9d0f..81176b2 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -162,6 +167,26 @@ private:
     // This function keeps trying to grab mLock, or give up if the message
     // is found to be disabled. It returns true if mLock is grabbed.
     bool                    lockIfMessageWanted(int32_t msgType);
+
+#ifdef MTK_HARDWARE
+        //
+        void                handleMtkExtNotify(int32_t ext1, int32_t ext2);
+        void                handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                handleMtkExtBurstShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                handleMtkExtContinuousShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        void                handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2);
+        //
+        void                handleMtkExtCaptureDone(int32_t ext1, int32_t ext2);
+        void                handleMtkExtShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                playRecordingSound();
+        //
+#endif
 };
 
 }
diff --git a/services/camera/libcameraservice/device1/CameraHardwareInterface.h b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
index e5b3648..411a9c7 100644
--- a/services/camera/libcameraservice/device1/CameraHardwareInterface.h
+++ b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
@@ -1,4 +1,9 @@
 /*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -127,6 +132,14 @@ public:
         ALOGV("%s(%s) buf %p", __FUNCTION__, mName.string(), buf.get());
 
         if (mDevice->ops->set_preview_window) {
+#ifdef MTK_HARDWARE
+            if  ( buf == 0 ) {
+                ALOGD("set_preview_window(0) before mPreviewWindow = 0 \r\n");
+                mDevice->ops->set_preview_window(mDevice, 0);
+                mPreviewWindow = 0;
+                return  OK;
+            }
+#endif
             mPreviewWindow = buf;
             mHalPreviewWindow.user = this;
             ALOGV("%s &mHalPreviewWindow %p mHalPreviewWindow.user %p", __FUNCTION__,
diff --git a/services/camera/libcameraservice/device2/Camera2Device.cpp b/services/camera/libcameraservice/device2/Camera2Device.cpp
index d1158d6..e685aca 100644
--- a/services/camera/libcameraservice/device2/Camera2Device.cpp
+++ b/services/camera/libcameraservice/device2/Camera2Device.cpp
@@ -793,7 +793,13 @@ status_t Camera2Device::MetadataQueue::setStreamSlot(camera_metadata_t *buf)
         mStreamSlotCount = 0;
         return OK;
     }
-
+#ifdef MTK_HARDWARE
+    camera_metadata_t *buf2 = clone_camera_metadata(buf);
+    if (!buf2) {
+        ALOGE("%s: Unable to clone metadata buffer!", __FUNCTION__);
+        return NO_MEMORY;
+    }
+#endif
     if (mStreamSlotCount > 1) {
         List<camera_metadata_t*>::iterator deleter = ++mStreamSlot.begin();
         freeBuffers(++mStreamSlot.begin(), mStreamSlot.end());
@@ -801,9 +807,17 @@ status_t Camera2Device::MetadataQueue::setStreamSlot(camera_metadata_t *buf)
     }
     if (mStreamSlotCount == 1) {
         free_camera_metadata( *(mStreamSlot.begin()) );
+#ifdef MTK_HARDWARE
+        *(mStreamSlot.begin()) = buf2;
+#else
         *(mStreamSlot.begin()) = buf;
+#endif
     } else {
+#ifdef MTK_HARDWARE
+        mStreamSlot.push_front(buf2);
+#else
         mStreamSlot.push_front(buf);
+#endif
         mStreamSlotCount = 1;
     }
     return signalConsumerLocked();
@@ -822,7 +836,16 @@ status_t Camera2Device::MetadataQueue::setStreamSlot(
     mStreamSlotCount = 0;
     for (List<camera_metadata_t*>::const_iterator r = bufs.begin();
          r != bufs.end(); r++) {
+#ifdef MTK_HARDWARE
+        camera_metadata_t *r2 = clone_camera_metadata(*r);
+        if (!r2) {
+            ALOGE("%s: Unable to clone metadata buffer!", __FUNCTION__);
+            return NO_MEMORY;
+        }
+        mStreamSlot.push_back(r2);
+#else
         mStreamSlot.push_back(*r);
+#endif
         mStreamSlotCount++;
     }
     return signalConsumerLocked();
diff --git a/services/camera/libcameraservice/mediatek/CameraService.cpp b/services/camera/libcameraservice/mediatek/CameraService.cpp
new file mode 100644
index 0000000..135d54a
--- /dev/null
+++ b/services/camera/libcameraservice/mediatek/CameraService.cpp
@@ -0,0 +1,100 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright (C) 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "CameraService"
+//
+#include <utils/Log.h>
+#include "CameraService.h"
+//
+#include <dlfcn.h>
+
+
+namespace android {
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+status_t
+CameraService::
+getProperty(String8 const& key, String8& value) const
+{
+    char const* sym = "MtkCam_getProperty";
+    void* pfn = ::dlsym(mModule->common.dso, sym);
+    if  ( ! pfn ) {
+        ALOGW("Cannot find symbol: %s", sym);
+        return  INVALID_OPERATION;
+    }
+    return  reinterpret_cast<status_t(*)(String8 const&, String8&)>(pfn)(key, value);
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+status_t
+CameraService::
+setProperty(String8 const& key, String8 const& value)
+{
+    char const* sym = "MtkCam_setProperty";
+    void* pfn = ::dlsym(mModule->common.dso, sym);
+    if  ( ! pfn ) {
+        ALOGW("Cannot find symbol: %s", sym);
+        return  INVALID_OPERATION;
+    }
+    return  reinterpret_cast<status_t(*)(String8 const&, String8 const&)>(pfn)(key, value);
+}
+
+
+};
diff --git a/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp b/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp
new file mode 100644
index 0000000..af334c1
--- /dev/null
+++ b/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp
@@ -0,0 +1,421 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright (C) 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "CameraService"
+//
+#include <binder/MemoryBase.h>
+//
+#include <camera/CameraParameters.h>
+#include <camera/MtkCamera.h>
+//
+#include "api1/CameraClient.h"
+#include "device1/CameraHardwareInterface.h"
+
+
+namespace android {
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+playRecordingSound()
+{
+    CameraParameters params(mHardware->getParameters());
+    int value = 0;
+    value = params.getInt("rec-mute-ogg");
+    if (value != 1) {
+        mCameraService->playSound(CameraService::SOUND_RECORDING);
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtNotify(int32_t ext1, int32_t ext2)
+{
+    int32_t const extMsgType = ext1;
+    switch  (extMsgType)
+    {
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE:
+        handleMtkExtCaptureDone(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER:
+        handleMtkExtShutter(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER:
+        handleMtkExtBurstShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER:
+        handleMtkExtContinuousShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+        handleMtkExtContinuousEnd(ext1, ext2);
+        break;
+    //
+    default:
+        handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+        break;
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[handleMtkExtData] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p)", dataPtr.get(), this);
+        return;
+    }
+
+//    void*   const pvExtParam   = MtkExtDataHelper.getExtParamBase();
+//    size_t  const ExtParamSize = MtkExtDataHelper.getExtParamSize();
+    switch  (MtkExtDataHelper.getExtMsgType())
+    {
+    case MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE:
+        handleMtkExtDataCompressedImage(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT:
+        handleMtkExtDataBurstShot(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT:
+        handleMtkExtDataContinuousShot(dataPtr, metadata);
+        break;
+    //
+    default:
+        handleGenericData(MTK_CAMERA_MSG_EXT_DATA, dataPtr, metadata);
+        break;
+    }
+    MtkExtDataHelper.uninit();
+}
+
+
+/******************************************************************************
+ *  Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+ *      ext2: 1: CameraService will play shutter sound.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    ALOGD("[%s] (ext2, mPlayShutterSound)=(%d, %d) \r\n", __FUNCTION__, ext2, mPlayShutterSound);
+
+    if  ( 1 == ext2 ) {
+        if (mPlayShutterSound) {
+            mCameraService->playSound(CameraService::SOUND_SHUTTER);
+        }
+    }
+
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+//    disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+}
+
+
+/******************************************************************************
+ *  Burst Shutter Callback Handler
+ *       ext2: count-down shutter number; 0: the last one shutter.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtBurstShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    handleShutter();
+    if  (0 < ext2) {
+        //  not the last one burst shutter.
+        enableMsgType(CAMERA_MSG_SHUTTER);
+        ALOGD("[handleMtkExtBurstShutter] count-down burst shutter number:%d - enableMsgType(CAMERA_MSG_SHUTTER) \r\n", ext2);
+    }
+    else {
+        ALOGD("[handleMtkExtBurstShutter] the last one burst shutter \r\n");
+    }
+}
+
+
+/******************************************************************************
+ *  Burst Shot (EV Shot)
+ *      int[0]: the total shut count.
+ *      int[1]: count-down shut number; 0: the last one shut.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uTotalShutCount = pExtParam[0];
+    uint_t const uCountdownIndex = pExtParam[1];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 2;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 2;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+    //
+    //
+    if  (0 < uCountdownIndex) {
+        //  not the last one burst shut.
+        ALOGD("[%s] count-down burst shut number:%d/%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uCountdownIndex, uTotalShutCount, imageSize, imageOffset);
+    }
+    else {
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+        ALOGD("[%s] the last one burst shut - (size, offset)=(%d, %d) \r\n", __FUNCTION__, imageSize, imageOffset);
+    }
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+*   Continuous Shutter Callback Handler
+*       ext2: current continuous shutter number.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    //if (mPlayShutterSound) {
+    //    mCameraService->playSound(CameraService::SOUND_SHUTTER);
+    //}
+
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+    //disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    //enableMsgType(CAMERA_MSG_SHUTTER);
+    ALOGD("[handleMtkExtContinuousShutter] current continuous shutter number:%d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Continuous Shot
+ *      int[0]: current continuous shut number.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uCurShutCount = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current continuous shut number:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__,  uCurShutCount, imageSize, imageOffset);
+
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+ *  Continuous EndCallback Handler
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2)
+{
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+    ALOGD("[handleMtkExtContinuousEnd] total continuous shut number is %d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtCaptureDone(int32_t /*ext1*/, int32_t /*ext2*/)
+{
+    ALOGD("[%s] disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE \r\n", __FUNCTION__);
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+}
+
+
+/******************************************************************************
+ *  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+ *      int[0]: current shut index; 0: the first one shut.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const      uShutIndex = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current shut index:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uShutIndex, imageSize, imageOffset);
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+};
-- 
1.9.1

